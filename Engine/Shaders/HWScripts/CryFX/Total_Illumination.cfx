// Copyright 2001-2018 Crytek GmbH / Crytek Group. All rights reserved.

// Implementation of SVO based features like GI and volume rendering

#if FEATURE_SVO_GI

#include "Common.cfi"
#include "ShadeLib.cfi"
#include "vertexLib.cfi"
#include "CommonSVO.cfi"
#include "ShadowCommon.cfi"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Defines
#define VOX_AIR_ALBEDO_COLOR      0.01f
#define VOX_COMPUTE_NUM_THREADS   16
#define VOX_DEPTH_BIAS            0
#define VOX_DEPTH_SCALE           1
#define VOX_DEPTH_RANGE_THRESHOLD 0.9

#define vSkyColorTop              float3(SvoTreeSettings5.z, SvoTreeSettings5.w, SvoParamsSpecular.y)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constants

float3x4 SVO_ReprojectionMatrix;
float4 SVO_FrameIdByte;
float4 SVO_CamPos;
#ifdef    SVO_LMAPS
float4 SVO_FrustumVerticesCam0;
float4 SVO_FrustumVerticesCam1;
float4 SVO_FrustumVerticesCam2;
float4 SVO_FrustumVerticesCam3;
float3x4 SVO_CameraMatrix;
float4 SVO_PassId_VS;
#endif // SVO_LMAPS
float4 SVO_TargetResScale;
float4 SVO_SrcPixSize;
float4x4 SVO_NodesForUpdate0;
float4x4 SVO_NodesForUpdate1;
float4x4 SVO_NodesForUpdate2;
float4x4 SVO_NodesForUpdate3;
float4 SVO_CloudShadowAnimParams;
float4 SVO_CloudShadowParams;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Textures

Texture2D sceneGBuffer0: register (t14);
Texture2D sceneGBuffer1: register (t5);
Texture2D sceneGBuffer2: register (t7);
Texture2D sceneSvoMap: register (t13);

Texture2D sceneAld: register (t10);
Texture2D sceneRgb: register (t11);

Texture2D sceneAldMin: register (t10);
Texture2D sceneRgbMin: register (t11);
Texture2D sceneAldMax: register (t12);
Texture2D sceneRgbMax: register (t13);

Texture2D sceneRgbMinPrev: register (t6);
Texture2D sceneAldMinPrev: register (t9);
Texture2D sceneRgbMaxPrev: register (t12);
Texture2D sceneAldMaxPrev: register (t13);

Texture2D sceneFinOutPrev: register (t9);
Texture2D sceneDiffuseFin: register (t15);

Texture2D sceneVelocity: register (t8);

Texture2D shadowFromClouds: register (t15);
Texture2D noiseMap2D: register (t15);
Texture2D shadowFromSvoMinMax: register (t15);
Texture2D shadowFromSvoFinPrev: register (t16);

Texture2D levelHeightmap: register (t8);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Structures
struct vtxOutWPOS
{
	float4 HPosition: SV_POSITION;
	float4 baseTC: TEXCOORD0;
	float4 CamVec: TEXCOORD1;
};

struct vtxInWPOS
{
	IN_P
	IN_TBASE
	float3 CamVec: TEXCOORD1;
};

struct pixoutMRT
{
	half4 Diffuse: SV_Target0;
	half4 Specular: SV_Target1;
	half4 Diffuse1: SV_Target2;
	half4 Specular1: SV_Target3;
};

struct pixout_RenderAtmosphere
{
	half4 Air_RGBA_Min: SV_Target0;
	half4 SVO_Shadow: SV_Target1;
	half4 Air_RGBA_Max: SV_Target2;
};

struct pixout_TraceSunShadows
{
	half4 SVO_Shadow: SV_Target0;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Shader flags

// _RT_SAMPLE0									Low spec mode
// _RT_SAMPLE1									Global environment map is available
// _RT_SAMPLE2									Troposphere is enabled
// _RT_SAMPLE3									Volumetric lightmaps enabled
// _RT_SAMPLE4									ON - diffuse computations, OFF - specular
// _RT_SAMPLE5									Albedo and normals in use
// _RT_HW_PCF_COMPARE						Half-res kernel
// _RT_LIGHT_TEX_PROJ						Simple RSM sun
// _RT_POINT_LIGHT							Simple RSM point lights
// _RT_BLEND_WITH_TERRAIN_COLOR SS depth tracing
// _RT_MOTION_BLUR							Dual tracing for multi-GPU
// _RT_LIGHTVOLUME0             Portals in use
// _RT_SPRITE										Analytical occluders using final ALD light info
// _RT_AMBIENT_OCCLUSION				Sun RSM Inject in modes 1-2
// _RT_VOLUMETRIC_FOG						Use RSM albedo colors and normals
// _RT_LIGHTVOLUME1             Analytical GI mode - voxels are not used
// _RT_TILED_SHADING            Enable voxels tracing
// _RT_ENVIRONMENT_CUBEMAP      Analytical proxies included into voxel tracing
// _RT_REVERSE_DEPTH            Generate sun shadow mask by SVO ray tracing
// _RT_PROJECTION_MULTI_RES     Compute simple specular using ALD results of diffuse tracing
// _RT_QUALITY1                 Include terrain heightmap (whole level) into ray-traced sun shadows

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Functions

float3 GetDiffuseKernel(out int GI_DIFFUSE_KERNEL_TILING, int nElemId, const bool bFullSphere = true)
{
	if (IsDiffuseMode())
	{
#if %_RT_HW_PCF_COMPARE

		const int nGiDiffuseSampleNum = 128;
		nElemId = nElemId & (nGiDiffuseSampleNum - 1);

		GI_DIFFUSE_KERNEL_TILING = sqrt(nGiDiffuseSampleNum / 2);
		if (bFullSphere)
		{
			const float3 arrGiDiffuseKernel[nGiDiffuseSampleNum] = kernel_S_128;
			return arrGiDiffuseKernel[nElemId];
		}
		else
		{
			const float3 arrGiDiffuseKernel[nGiDiffuseSampleNum] = kernel_HS_128;
			return arrGiDiffuseKernel[nElemId];
		}

#else

		const int nGiDiffuseSampleNum = 512;
		nElemId = nElemId & (nGiDiffuseSampleNum - 1);

		GI_DIFFUSE_KERNEL_TILING = sqrt(nGiDiffuseSampleNum / 2);
		if (bFullSphere)
		{
			const float3 arrGiDiffuseKernel[nGiDiffuseSampleNum] = kernel_S_512;
			return arrGiDiffuseKernel[nElemId];
		}
		else
		{
			const float3 arrGiDiffuseKernel[nGiDiffuseSampleNum] = kernel_HS_512;
			return arrGiDiffuseKernel[nElemId];
		}

#endif
	}
	else
	{
#if %_RT_HW_PCF_COMPARE

		const int nGiDiffuseSampleNum = 8;
		nElemId = nElemId & (nGiDiffuseSampleNum - 1);

		GI_DIFFUSE_KERNEL_TILING = sqrt(nGiDiffuseSampleNum / 2);
		const float3 arrGiDiffuseKernel[nGiDiffuseSampleNum] = kernel_HS_8;
		return arrGiDiffuseKernel[nElemId];

#else

		const int nGiDiffuseSampleNum = 32;
		nElemId = nElemId & (nGiDiffuseSampleNum - 1);

		GI_DIFFUSE_KERNEL_TILING = sqrt(nGiDiffuseSampleNum / 2);
		const float3 arrGiDiffuseKernel[nGiDiffuseSampleNum] = kernel_HS_32;
		return arrGiDiffuseKernel[nElemId];

#endif
	}
}

float3 GetWorldSpaceNormals(float2 tc, out float fTransmittanceY, float3 vCamVec)
{
	half4 bufferA = tex2DlodPC(sceneGBuffer0, tc);
	float3 vNorm0 = DecodeGBufferNormal(bufferA);
	if (IsDiffuseMode())
		fTransmittanceY = saturate(DecodeGBufferTransmittanceLum(bufferA));
	else
		fTransmittanceY = 0;
	return vNorm0;
}

MaterialAttribsCommon DecodeGBufferChannels(in float2 tc)
{
	return DecodeGBuffer(tex2DlodPC(sceneGBuffer0, tc), tex2DlodPC(sceneGBuffer1, tc), tex2DlodPC(sceneGBuffer2, tc));
}

float3 GetVoxCenter(uint3 coord, uint3 coord0, uint3 coord1, float4 voxAreaMin, float4 voxAreaMax)
{
	return voxAreaMin + (voxAreaMax - voxAreaMin) * float3(coord - coord0) / float3(coord1 + 1 - coord0) + voxAreaMin.w / VOX_BRICK_TEXRES / 2;
}

float rand(float2 n)
{
	return frac(sin(dot(n.xy, float2(12.9898, 78.233))) * 43758.5453);
}

void GetRndRotationMat(in float3 vPos0, in float3 vNor0, out half2x2 mSampleRotMat)
{
	float3 vNorAbs = abs(vNor0);

	float2 vC = 0;
	if ((vNorAbs.x > vNorAbs.y) && (vNorAbs.x > vNorAbs.z))
		vC = vPos0.yz;
	else if ((vNorAbs.y > vNorAbs.x) && (vNorAbs.y > vNorAbs.z))
		vC = vPos0.xz;
	else
		vC = vPos0.xy;

	const half jitterIndex = dot(rand(vC), half2(1, .25));
	half2 vJitterSinCos = half2(sin(PI_X2 * jitterIndex), cos(PI_X2 * jitterIndex));
	const half2x2 _mSampleRotMat = { vJitterSinCos.y, vJitterSinCos.x, -vJitterSinCos.x, vJitterSinCos.y };
	mSampleRotMat = _mSampleRotMat;
}

vert2FragGeneral VoxelRayTraceVS(app2vertGeneral IN)
{
	vert2FragGeneral OUT = (vert2FragGeneral)0;

	streamPos vertPassPos = (streamPos)0;

	OUT.vView.xyz = g_VS_WorldViewPos.xyz;

	vs_shared_output(IN, OUT, vertPassPos, true);

	OUT.screenProj.x = IN.vertCommon.baseTC.x;
	OUT.screenProj.y = 1 - IN.vertCommon.baseTC.y;

	OUT.baseTC.xyz = IN.vertCommon.Position.xyz;

	return OUT;
}

int GetNodeRequestedForUpdate(int nItemId)
{
	float nRes = -2.f;

	const int SVO_MAX_NODE_GROUPS = 4;

	if (nItemId >= 0 && nItemId < SVO_MAX_NODE_GROUPS * 4 * 4)
	{
		int g = nItemId / 16;
		nItemId -= g * 16;
		int x = nItemId / 4;
		nItemId -= x * 4;
		int y = nItemId;

		if (g == 0)
		{
			nRes = SVO_NodesForUpdate0[x][y];
		}
		else if (g == 1)
		{
			nRes = SVO_NodesForUpdate1[x][y];
		}
		else if (g == 2)
		{
			nRes = SVO_NodesForUpdate2[x][y];
		}
		else if (g == 3)
		{
			nRes = SVO_NodesForUpdate3[x][y];
		}
	}

	return int(nRes + 0.1f);
}

float3 GetSkyColor(const float3 vDir, const float fConeSev)
{
	float fAmplifier = 1.f;
#if %_PS
	fAmplifier = IsDiffuseMode() ? SvoParamsDiffuse.w : SvoParamsSpecular.w;
#endif

#if !%_RT_SAMPLE5 && %_PS && !%_RT_LIGHTVOLUME1
	if (SvoParamsSkyColor.w < 0)
		return -SvoParamsSkyColor.w * vSkyColorTop.xyz * fAmplifier;
	return SvoParamsSkyColor.w * fAmplifier;
#endif

#if %_RT_SAMPLE1
	float3 vAmb = DecodeHDRCubemap(texCUBElodLC(globalSpecCM, half4(vDir, saturate(1.f - fConeSev) * 3.f))) * SvoParamsMisc.w;
#else
	float3 vAmb = vSkyColorTop;
#endif

	if (SvoParamsSkyColor.w < 0)
		return vAmb * -SvoParamsSkyColor.w * fAmplifier;

	return vAmb * SvoParamsSkyColor.w * fAmplifier;
}

struct Segment
{
	float3 P0;
	float3 P1;
};

float GetPointToSegmentDistance(float3 P, Segment S, out float3 vOutDir)
{
	float3 v = S.P1 - S.P0;
	float3 w = P - S.P0;
	float3 closestPoint;

	float c1 = dot(w, v);
	float c2 = dot(v, v);

	if (c1 <= 0)
	{
		closestPoint = S.P0;
	}
	else if (c2 <= c1)
	{
		closestPoint = S.P1;
	}
	else
	{
		float b = c1 / c2;
		closestPoint = S.P0 + b * v;
	}

	vOutDir = closestPoint - P;
	return length(vOutDir);
}

//		Source: http://geomalgorithms.com/a07-_distance.html
float GetSegmentToSegmentDistance(Segment S1, Segment S2)
{
	float3 u = S1.P1 - S1.P0;
	float3 v = S2.P1 - S2.P0;
	float3 w = S1.P0 - S2.P0;
	float a = dot(u, u);            // always >= 0
	float b = dot(u, v);
	float c = dot(v, v);            // always >= 0
	float d = dot(u, w);
	float e = dot(v, w);
	float D = a * c - b * b;       // always >= 0
	float sc, sN, sD = D;          // sc = sN / sD, default sD = D >= 0
	float tc, tN, tD = D;          // tc = tN / tD, default tD = D >= 0

	const float SMALL_NUM = 0.001f;

	// compute the line parameters of the two closest points
	if (D < SMALL_NUM)
	{
		// the lines are almost parallel
		sN = 0.0;         // force using point P0 on segment S1
		sD = 1.0;         // to prevent possible division by 0.0 later
		tN = e;
		tD = c;
	}
	else
	{
		// get the closest points on the infinite lines
		sN = (b * e - c * d);
		tN = (a * e - b * d);
		if (sN < 0.0)
		{
			// sc < 0 => the s=0 edge is visible
			sN = 0.0;
			tN = e;
			tD = c;
		}
		else if (sN > sD)
		{
			// sc > 1  => the s=1 edge is visible
			sN = sD;
			tN = e + b;
			tD = c;
		}
	}

	if (tN < 0.0)
	{
		// tc < 0 => the t=0 edge is visible
		tN = 0.0;
		// recompute sc for this edge
		if (-d < 0.0)
			sN = 0.0;
		else if (-d > a)
			sN = sD;
		else
		{
			sN = -d;
			sD = a;
		}
	}
	else if (tN > tD)
	{
		// tc > 1  => the t=1 edge is visible
		tN = tD;
		// recompute sc for this edge
		if ((-d + b) < 0.0)
			sN = 0;
		else if ((-d + b) > a)
			sN = sD;
		else
		{
			sN = (-d + b);
			sD = a;
		}
	}

	// finally do the division to get sc and tc
	sc = (abs(sN) < SMALL_NUM ? 0.0 : sN / sD);
	tc = (abs(tN) < SMALL_NUM ? 0.0 : tN / tD);

	// get the difference of the two closest points
	float3 dP = w + (sc * u) - (tc * v);  // =  S1(sc) - S2(tc)

	return length(dP);   // return the closest distance
}

struct OBB
{
	float4 ue[3];
	float4 c;
};

//Computes the square distance between point p and OBB b
float SqDistPointOBB(float3 p, OBB b, const bool bCylinder)
{
	float3 v = p - b.c.xyz;
	float sqDist = 0.0f;
	for (int i = 0; i < 3; i++)
	{
		float d = dot(v, b.ue[i].xyz);
		float excess = 0.0f;

		if (d < -b.ue[i].w)
			excess = d + b.ue[i].w;
		else if (d > b.ue[i].w)
			excess = d - b.ue[i].w;

		sqDist += excess * excess;
	}

	if (bCylinder)
	{
		Segment s0;
		s0.P0 = b.c.xyz + b.ue[2].xyz * b.ue[2].w;
		s0.P1 = b.c.xyz - b.ue[2].xyz * b.ue[2].w;

		float3 vOutDir = 0;
		float fSD = GetPointToSegmentDistance(p, s0, vOutDir);

		sqDist = max(sqDist, pow(max(0, fSD - b.ue[0].w), 2.f));
	}

	return sqDist;
}

struct SAnalyticalOccluder
{
	float4 P0;
	float4 P1;
	float4 P2;
	float4 C;
};

#define SVO_MAX_ANALYTICAL_OCCLUDERS 32

float4 SVO_AnalyticalOccluders[SVO_MAX_ANALYTICAL_OCCLUDERS * 4];
float4 SVO_PostOccluders[SVO_MAX_ANALYTICAL_OCCLUDERS * 4];

#define AO_eCapsule       0
#define AO_eOBB           1
#define AO_eCylinder      2
#define AO_eOBB_Hard      3
#define AO_eCylinder_Hard 4

float ProcessAnalyticalOccluders(float fRayLen, Ray r, inout float4 vC, float fDirectionality, const bool bPostOccl)
{
	float fHitDist = 1000;

#if !ORBIS

	float fOccl = 0;

	const float fDistM = length(r.startpoint.xyz - PS_WorldViewPos.xyz);

	for (int n = 0; n < SVO_MAX_ANALYTICAL_OCCLUDERS; n++)
	{
		SAnalyticalOccluder oc;

		if (bPostOccl)
		{
			oc.P0 = SVO_PostOccluders[n * 4 + 0];
			oc.P1 = SVO_PostOccluders[n * 4 + 1];
			oc.P2 = SVO_PostOccluders[n * 4 + 2];
			oc.C = SVO_PostOccluders[n * 4 + 3];
		}
		else
		{
			oc.P0 = SVO_AnalyticalOccluders[n * 4 + 0];
			oc.P1 = SVO_AnalyticalOccluders[n * 4 + 1];
			oc.P2 = SVO_AnalyticalOccluders[n * 4 + 2];
			oc.C = SVO_AnalyticalOccluders[n * 4 + 3];
		}

		if (!oc.P0.w)
			break;

		float fOrigDist = 1000;
		float fRayDist = 1000;
		float fRadius = 0;
		float3 vSegDir = 0;

		bool bHardOcclusion = (oc.C.w == AO_eOBB_Hard || oc.C.w == AO_eCylinder_Hard);

		if (oc.C.w == AO_eCapsule) // capsule
		{
			float3 startpoint = r.startpoint + r.direction * oc.P0.w * .125;

			Segment s0;
			s0.P0 = startpoint;
			s0.P1 = startpoint + r.direction * fRayLen;

			Segment s1;
			s1.P0 = oc.P0.xyz;
			s1.P1 = oc.P1.xyz;

			fRayDist = GetSegmentToSegmentDistance(s0, s1);

			s0.P0 = startpoint;
			s0.P1 = startpoint + r.direction * 0.001f;

			float3 dP;
			fOrigDist = GetPointToSegmentDistance(startpoint, s1, dP);

			vSegDir = normalize(dP);

			fRadius = oc.P0.w;
		}
		else if (oc.C.w <= AO_eCylinder_Hard) // obb or cylinder
		{
			float3 startpoint = r.startpoint + r.direction * (0.001 + 0.001 * fDistM);

			OBB obb;
			obb.ue[0] = oc.P0;
			obb.ue[1] = oc.P1;
			obb.ue[2] = oc.P2;
			obb.ue[1].xyz *= -1;

			obb.c = oc.C;

			bool bCylinder = (oc.C.w == AO_eCylinder || oc.C.w == AO_eCylinder_Hard);

			fOrigDist = sqrt(SqDistPointOBB(startpoint, obb, bCylinder));

			fRayDist = fOrigDist;
			float3 vMinPoint = startpoint;
			float fStepSize = fRayLen;

			for (float t = 0, steps = 0; (t < fRayLen) && (steps < 32) && fStepSize > 0; t += fStepSize, steps++)
			{
				float3 vTestPoint = startpoint + r.direction * t;

				float fD = sqrt(SqDistPointOBB(vTestPoint, obb, bCylinder));

				if (fD < fRayDist)
				{
					fRayDist = fD;
					vMinPoint = vTestPoint;
				}
				else if (fD > fRayDist)
					break;

				fStepSize = min(fD + .002, fStepSize);
			}

			vSegDir = normalize(vMinPoint - startpoint);

			fOrigDist = min(fOrigDist, length(vMinPoint - startpoint));

			fRadius = 0;
		}

		if (fRayDist <= 0)
		{
			if (fOrigDist < fHitDist && fOrigDist < fRayLen)
				fHitDist = fOrigDist;
		}

		float fO = 1.f - max(0, fRayDist - fRadius * .85) / (fRadius * 0.5 + fOrigDist * SvoParamsMisc3.y + 0.001);
		if (fOrigDist > 0)
		{
			fO *= saturate(.5 + dot(vSegDir, r.direction));
			if (!bHardOcclusion)
				fO *= saturate(1 - fOrigDist / fRayLen);
		}

		fOccl = max(fOccl, fO);
	}

	vC = lerp(vC, float4(0, 0, 0, 1), fOccl);

#endif

	return fHitDist;
}

float4 ConeTraceTreeAndSkyEx(float fRayLen, Ray r, float fConeSev, out float4 vNor1, const float fConesColorSatur = 1.f, const float fMultTriRT = 0, const bool bSpecular = false, bool bForceUseLighting = false, const bool bAllowSkyLight = true, float3 vSurfNorm = 0)
{
	float fAoHitDist = 1000;
	float fAoOpacity = 0;

#if !ORBIS
	#if %_RT_LIGHTVOLUME1 || %_RT_ENVIRONMENT_CUBEMAP
	{
		float4 vC = 0;
		float fDirectionality = 1;
		Ray r2 = r;
		r2.startpoint += r2.direction * 0.01f;
		fAoHitDist = ProcessAnalyticalOccluders(fRayLen, r2, vC, fDirectionality, false);
		fAoOpacity = vC.a;
	}
	#endif
#endif

	float4 vPos1 = 0;
	vNor1 = 0;
	float4 vC = 0;

#if %_RT_TILED_SHADING
	vC = ConeTraceTree(r, fConeSev, vPos1, vNor1, bSpecular ? (length(r.startpoint - PS_WorldViewPos.xyz) * .25 + .25) : 0, min(fAoHitDist + VOX_MIN_VOX_SIZE, fRayLen), 0.f, 1.f, 0, fMultTriRT, 0, false, bSpecular, bForceUseLighting, vSurfNorm);
#endif

#if !ORBIS
	#if %_RT_LIGHT_TEX_PROJ && %_RT_LIGHTVOLUME1
	if (fAoHitDist < 200)
	{
		float3 vHitPoint = r.startpoint + r.direction * fAoHitDist;

		half3 vSunLight = 0;
		float4 vShadTC = mul(SVO_RsmSunShadowProj, float4(vHitPoint.xyz - PS_WorldViewPos.xyz, 1.f));
		vShadTC.xy /= vShadTC.w;

		float4 vRGBD = 0;

		if (vShadTC.x >= 0 && vShadTC.x <= 1 && vShadTC.y >= 0 && vShadTC.y <= 1 && vShadTC.z <= 1)
		{
			float fShadowDepth = tex2DlodPC(rsmSunShadowMap, float4(vShadTC.xy, 0, 0)).r;
			vSunLight = (fShadowDepth > vShadTC.z + .00005);

		#if %_RT_VOLUMETRIC_FOG
			half4 vMatColor = tex2DlodPC(rsmSunColorsMap, float4(vShadTC.xy, 0, 0)).rgba;
			half3 vMatNormal = tex2DlodPC(rsmSunNormalMap, float4(vShadTC.xy, 0, 0)).rgb;
		#else
			half4 vMatColor = half4(SvoParamsMisc2.zzz, 0.15f);
			half3 vMatNormal = 0;
		#endif
			//vMatColor.xyz = pow(vMatColor.xyz, 1.0/2.2);
			float fMatIntens = dot(vMatColor.xyz, .333f);
			vMatColor.xyz += saturate(SvoParamsMisc2.z - fMatIntens);
			vSunLight *= vMatColor.xyz;
			vRGBD.xyz = vSunLight * SVO_RsmSunCol.xyz * SVO_RsmSunCol.w;
			float fRSM = saturate(1 - (8 / 8) * 200 * abs(fShadowDepth - vShadTC.z));
			vRGBD.a = max(vRGBD.a, fRSM * vMatColor.a);

		#if %_RT_VOLUMETRIC_FOG
			if (dot(vMatNormal, 1) < 0.01)
				vMatNormal = float3(0, 0, 1); // terrain
			else
				vMatNormal = vMatNormal * 2 - 1;

			if (dot(vMatNormal, r.direction) < 0.85)
		#endif
			if (SvoParamsCommon.z)
				vC.xyz += abs(1.f / SvoParamsCommon.z) * vRGBD.xyz * (vRGBD.a) * saturate(1 - 0);
		}
	}
	#endif
#endif

	vC.a = max(fAoOpacity, vC.a);

	// apply cloud shadows
	float fCloudsShadow = 1.f;
#if %_PS
	fCloudsShadow = GetCloudShadowCommon(r.startpoint, shadowFromClouds, ssSvoLinearWrap, SVO_CloudShadowAnimParams, SVO_CloudShadowParams);

	#if !%_RT_LIGHTVOLUME1
	// prevent sky light leaking from the bottom
	if (r.direction.z < 0)
		vC.a = lerp(1.f, vC.a, SvoParamsMisc4.y);
	#endif
#endif

	//float3 vAOTint = lerp(float3(1,1,1), float3(1.5, 1.5, 0), saturate((vC.a-.3)/.7));
	vC.xyz = vC.xyz * fCloudsShadow + GetSkyColor(r.direction, fConeSev) * (saturate(1 - vC.a)) * bAllowSkyLight * (fCloudsShadow * 0.2 + 0.8);
	vC.xyz = lerp((vC.x + vC.y + vC.z) / 3, vC.xyz, fConesColorSatur);

	return vC;
}

float4 ConeTraceTreeAndSky(float fRayLen, const Ray r, const float fConeSev, const float fConesColorSatur = 1.f, const float fMultTriRT = 0, const bool bSpecular = false, const bool bForceUseLighting = false, float3 vSurfNorm = 0)
{
	float4 vNor1 = 0;
	return ConeTraceTreeAndSkyEx(fRayLen, r, fConeSev, vNor1, fConesColorSatur, fMultTriRT, bSpecular, bForceUseLighting, true, vSurfNorm);
}

pixout SvoDebugDrawPS(vert2FragGeneral IN)
{
	pixout OUT = (pixout)0;

	float4 cDiffuseMap = 1;

	// define ray
	Ray r;
	r.startpoint = PS_WorldViewPos.xyz;
	r.direction = normalize(IN.baseTC.xyz - PS_WorldViewPos.xyz);

	float4 vPos0 = 0, vNormal = 0;

#if DURANGO || ORBIS
	cDiffuseMap = ConeTraceTree(r, SvoParamsSpecular.x, vPos0, vNormal, 0, 256.f);
	cDiffuseMap.xyz = float3(int3(vPos0.xyz) & 1);
#else
	//	cDiffuseMap = ConeTraceTreeAndSky(r,  SvoParamsSpecular.x, 1, 0, true, true);
	cDiffuseMap = ConeTraceTree(r, SvoParamsSpecular.x, vPos0, vNormal, 0, 256.f, 0.f, 1.f, 0, 0, 0, false, false, true, 0, (int)SvoParamsSkyColor.z);
	// cDiffuseMap.xyz = float3(int3(vPos0.xyz) & 1);
#endif

	//	cDiffuseMap.xyz = (vNormal)*.5+.5;

	cDiffuseMap.w = 1;

	OUT.Color = pow(cDiffuseMap, 1) / 16;
	OUT.Color.w = 1;

	return OUT;
}

vert2fragZ RenderLightingCommonVS_Z(vtxInWPOS IN)
{
	vert2fragZ OUT = (vert2fragZ)0;

	OUT.HPosition = Get2dHPos(IN.Position);
	OUT.baseTC.xy = IN.baseTC.xy;
	OUT.baseTC.zw = 0;//IN.baseTC * SVO_ScreenSize.xy * 0.25;
	OUT.vNormalWS.xyz = IN.CamVec;

	return OUT;
}

vtxOutWPOS RenderLightingCommonVS(vtxInWPOS IN)
{
	vtxOutWPOS OUT = (vtxOutWPOS)0;

	OUT.HPosition = Get2dHPos(IN.Position);
	OUT.baseTC.xy = IN.baseTC.xy;
	OUT.baseTC.zw = 0;//IN.baseTC * SVO_ScreenSize.xy * 0.25;
	OUT.CamVec.xyz = IN.CamVec;

	return OUT;
}

float3 GetWorldPos(float fDepth, float3 vCamVec)
{
	return fDepth * vCamVec + PS_WorldViewPos.xyz; // Return world space position
}

void GetRotationV0(half3 n, out half3x3 rotMat)
{
	half h = 1 / (1 + n.z);
	rotMat._m00 = h * n.y * n.y + n.z;
	rotMat._m01 = -h * n.y * n.x;
	rotMat._m02 = -n.x;
	rotMat._m10 = -h * n.y * n.x;
	rotMat._m11 = h * n.x * n.x + n.z;
	rotMat._m12 = -n.y;
	rotMat._m20 = n.x;
	rotMat._m21 = n.y;
	rotMat._m22 = n.z;
}

float3 Reproject(in half2 vScreenPos, in float fDepth, in float3x4 matReproj)
{
	float4 pos = float4(vScreenPos, 1.f, 1.f / fDepth);
	pos.xyz = mul(matReproj, pos);
	pos.xy /= pos.z;
	pos.z *= fDepth;

	float2 vMV = tex2DlodPC(sceneVelocity, vScreenPos);
	if (vMV.x != 0)
		pos.xy = vScreenPos + DecodeMotionVector(vMV);

	return pos.xyz;
}

void GetAverNormAndSmooth(float2 tcIn, out float3 vAverNor, out float fAverSmoothness, out float fAverTransmittanceY, float3 vCamVec, out float3 vAverReflectance, out float fDepthMin, out float fDepthMax, out float3 vNorMin, out float3 vNorMax)
{
	vAverNor = 0;
	fAverSmoothness = 0;
	vAverReflectance = 0;
	fAverTransmittanceY = 0;
	float fSummW = 0;
	int nRange = 1;
	float2 vR = 0.5f / PS_ScreenSize.xy;
	float fDepthRange = 0.12;
	float fDepth0 = SampleLinearDepth(sceneDepth, tcIn);
	fDepthMin = fDepthMax = fDepth0;
	for (int x = 0; x <= nRange; x++)
		for (int y = 0; y <= nRange; y++)
		{
			float fTransmittanceY = 0;
			float2 tc1 = tcIn + vR * float2(x, y);
			MaterialAttribsCommon gbuffer1 = DecodeGBufferChannels(tc1);
			float fDepth1 = SampleLinearDepth(sceneDepth, tc1);
			if (fDepth1 <= fDepthMin)
			{
				fDepthMin = fDepth1;
				vNorMin = GetWorldSpaceNormals(tc1, fTransmittanceY, vCamVec).xyz;
			}
			if (fDepth1 >= fDepthMax)
			{
				fDepthMax = fDepth1;
				vNorMax = GetWorldSpaceNormals(tc1, fTransmittanceY, vCamVec).xyz;
			}

			const float fW = saturate(fDepthRange - abs(1.f - fDepth0 / fDepth1)) + .001;

			fAverSmoothness += gbuffer1.Smoothness * fW;
			vAverReflectance += gbuffer1.Reflectance * fW;
			vAverNor += GetWorldSpaceNormals(tc1, fTransmittanceY, vCamVec).xyz * fW;
			fAverTransmittanceY += fTransmittanceY * fW;

			fSummW += fW;
		}

	float normalVar = 1.0 / length(vAverNor / fSummW) - 1.0;
	vAverNor = normalize(vAverNor);
	fAverSmoothness /= fSummW;
	fAverSmoothness /= 1 + normalVar * 25;
	fAverTransmittanceY /= fSummW;
	vAverReflectance /= fSummW;
}

float GetBlendMin(float2 tc0, float2 tc1, float fAverSmoothness, float fDepth0, float fDepth1)
{
	float fMinBlend = SVO_TargetResScale.z * 0.25f + SVO_TargetResScale.w;

	if (!IsDiffuseMode())
	{
		float fDistTCRat = saturate(length(tc0 - tc1) / .025f);

		// reduce ghosting for mirrors and in case of camera movement
		fMinBlend = saturate(max(fMinBlend + fDistTCRat * (1.f - fMinBlend), 0.5 * saturate(pow(fAverSmoothness, 3))));
	}

	fMinBlend += saturate(abs(fDepth0 - fDepth1) * PS_NearFarClipDist.y - .25);

	fMinBlend += 0.25f * (tc0.x < 0 || tc0.x > 1 || tc0.y < 0 || tc0.y > 1);

	return saturate(fMinBlend);
}

#define SVO_MAX_PORTALS 8

float4 SVO_PortalsPos[SVO_MAX_PORTALS];
float4 SVO_PortalsDir[SVO_MAX_PORTALS];

#define MAX_BEST_PORTALS 3

void FindBestPortals(float3 vPos0, float3 vNor0, out float4 arrBestPortalPos[MAX_BEST_PORTALS], out float4 arrBestPortalDir[MAX_BEST_PORTALS])
{
	float arrBestW[MAX_BEST_PORTALS];
	for (int n = 0; n < MAX_BEST_PORTALS; n++)
	{
		arrBestW[n] = 0;
		arrBestPortalPos[n] = 0;
		arrBestPortalDir[n] = 0;
	}

	for (int p = 0; p < SVO_MAX_PORTALS; p++)
	{
		if (SVO_PortalsPos[p].z)
		{
			float3 vDir = normalize(SVO_PortalsPos[p].xyz - vPos0.xyz);

			if (dot(vDir, vNor0) >= 0 && dot(vDir, -SVO_PortalsDir[p].xyz) >= 0)
			{
				float fD = length(SVO_PortalsPos[p].xyz - vPos0.xyz);

				if (fD > VOX_CONE_MAX_LEN)
					continue;

				float fW = 1.f / (fD + 0.01f);

				int nWorstSlot = 0;
				for (int n = 1; n < MAX_BEST_PORTALS; n++)
				{
					if (arrBestW[n] < arrBestW[nWorstSlot])
						nWorstSlot = n;
				}

				if (fW > arrBestW[nWorstSlot])
				{
					arrBestPortalPos[nWorstSlot] = SVO_PortalsPos[p];
					arrBestPortalDir[nWorstSlot] = SVO_PortalsDir[p];
					arrBestW[nWorstSlot] = fW;
				}
			}
		}
	}
}

pixoutMRT DemosaicPS(vtxOutWPOS IN)
{
	pixoutMRT OUT = (pixoutMRT)0;

	// read position and normal
	float3 vPos0 = GetWorldPos(VOX_DEPTH_SCALE * SampleLinearDepth(sceneDepth, IN.baseTC.xy) - VOX_DEPTH_BIAS, IN.CamVec);

	float3 vNor0 = 0;
	float fAverSmoothness = 0;
	float fAverTransmittanceY = 0;
	float3 vAverReflectance = 0;
	float fDepthMin = 0, fDepthMax = 0;
	float3 vNorMin = 0, vNorMax = 0;
	GetAverNormAndSmooth(IN.baseTC.xy, vNor0, fAverSmoothness, fAverTransmittanceY, normalize(IN.CamVec.xyz), vAverReflectance, fDepthMin, fDepthMax, vNorMin, vNorMax);

	float2 vLowResBestTC = IN.baseTC.xy;

	float4 vALD0 = 0;
	float4 vRGB0 = 0;
	float4 vALD1 = 0;
	float4 vRGB1 = 0;

	// blend with prev frame ALD in order to remove flickering
	float fDepthC = SampleLinearDepth(sceneDepth, IN.baseTC.xy);
	float3 vReprojTC = Reproject(vLowResBestTC.xy, fDepthC, SVO_ReprojectionMatrix);

	int GI_DIFFUSE_KERNEL_TILING;
	GetDiffuseKernel(GI_DIFFUSE_KERNEL_TILING, 0);

#if %_RT_SAMPLE0
	int nRange = GI_DIFFUSE_KERNEL_TILING;
#else
	int nRange = GI_DIFFUSE_KERNEL_TILING;
#endif

	if (!IsDiffuseMode())
		nRange = clamp(saturate(1 - (fAverSmoothness * 1.3 - .5) / (1 - .5)) * (float)nRange, 1, GI_DIFFUSE_KERNEL_TILING);

	// reduce range at distance
	const float fDistM = length(vPos0 - PS_WorldViewPos.xyz);

	//#if %_RT_SAMPLE0
	//nRange = lerp(nRange, nRange / 2, saturate((fDistM - 8) / 8));
	//#endif

	float fResScale = 1.f;
	float2 vR = 2.f * fResScale / (int2(PS_ScreenSize.xy / fResScale) * fResScale);
	float fSumm0 = 0;
	float fSumm1 = 0;
	float fDepthRange = 0.12 + 0.08 * saturate(1.f - dot(normalize(IN.CamVec.xyz), -vNor0)); // floor fix
	float fDotMax = .25;

	float2 vShift;
	if (IsDiffuseMode())
		vShift = vR / 2;
	else
		vShift = vR / 4;

	float2 vSnap = vR / 2;

	float2 vLowResBestTC_Sn = float2(int2(vLowResBestTC / vSnap)) * vSnap + vShift;

#if %_RT_SAMPLE3
	const int nStep = 2;
#else
	const int nStep = 1;
#endif

	float3 vFocus = IsDiffuseMode() ? vNor0 : reflect(normalize(IN.CamVec.xyz), vNor0);

	// reduce border noise
	float2 vBorder = (nRange / 2) * vR * 1;
	vLowResBestTC_Sn = clamp(vLowResBestTC_Sn, vBorder, 1 - vBorder);

	float fRangeFade = 1.2f + 0.5f * saturate(1 - fDistM / 16);

	//	if(SampleLinearDepth(sceneDepth, IN.baseTC.xy) < 0.8f)
	for (int x = -nRange / 2; x <= nRange / 2; x += nStep)
		for (int y = -nRange / 2; y <= nRange / 2; y += nStep)
		{
			float4 tc = saturate(float4(vLowResBestTC_Sn + vR * float2(x, y), 0, 0));

			float4 texALD = tex2DlodLC(sceneAld, tc);
			float4 texRGB = tex2DlodLC(sceneRgb, tc);

			float fNewDepth = texRGB.w;
			float3 vNorm = texALD;

			float fDistW = saturate(fRangeFade - sqrt(x * x + y * y) / max(1, nRange / 2));

			float fDotTest = lerp(.25, saturate(fAverTransmittanceY * 4 + dot(normalize(vNorm), vFocus) - fDotMax), saturate(length(vNorm) / max(0.0001, texALD.w) * 8.f)) + .001;

			float fDepTest0 = saturate((fDepthRange - abs(1.f - fNewDepth / fDepthMin)) * 4) + .001;
			float fDepTest1 = saturate((fDepthRange - abs(1.f - fNewDepth / fDepthMax)) * 4) + .001;

			float fWeigth0 = fDepTest0 * fDotTest * fDistW;
			float fWeigth1 = fDepTest1 * fDotTest * fDistW;

			fWeigth0 = lerp(.015f, fWeigth0, saturate(texALD.w * 1000));
			fWeigth1 = lerp(.015f, fWeigth1, saturate(texALD.w * 1000));

			vALD0 += texALD * fWeigth0;
			vRGB0 += texRGB * fWeigth0;
			vALD1 += texALD * fWeigth1;
			vRGB1 += texRGB * fWeigth1;

			fSumm0 += fWeigth0;
			fSumm1 += fWeigth1;
		}

	if (fSumm0)
	{
		vALD0 /= fSumm0;
		vRGB0.xyz = normalize(vRGB0.xyz);
	}
	if (fSumm1)
	{
		vALD1 /= fSumm1;
		vRGB1.xyz = normalize(vRGB1.xyz);
	}

	OUT.Diffuse.xyz = vRGB0;
	OUT.Diffuse.w = fDepthMin;
	OUT.Specular = vALD0;

	OUT.Diffuse1.xyz = vRGB1;
	OUT.Diffuse1.w = fDepthMax;
	OUT.Specular1 = vALD1;

	bool bSameMinMaxDepth = (abs(fDepthMax - fDepthMin) * PS_NearFarClipDist.y < .1) && (dot(vNorMin, vNorMax) > .7);

#if !ORBIS

	#if %_RT_LIGHTVOLUME1 && %_RT_LIGHTVOLUME0

	OUT.Specular *= SvoParamsCommon.z;
	OUT.Specular1 *= SvoParamsCommon.z;

	float4 arrPortOut[2] =
	{
		float4(0, 0, 0, 0),
		float4(0, 0, 0, 0)
	};

	for (int nPass = 0; nPass < 2; nPass++)
	{
		Ray r;
		r.direction = 0;

		if (!nPass)
			r.startpoint = GetWorldPos(VOX_DEPTH_SCALE * fDepthMin - VOX_DEPTH_BIAS, IN.CamVec);
		else
			r.startpoint = GetWorldPos(VOX_DEPTH_SCALE * fDepthMax - VOX_DEPTH_BIAS, IN.CamVec);

		r.startpoint += vNor0 * 0.01;

		{
			float4 arrBestPortalPos[MAX_BEST_PORTALS];
			float4 arrBestPortalDir[MAX_BEST_PORTALS];
			FindBestPortals(vPos0, vNor0, arrBestPortalPos, arrBestPortalDir);

			for (int nPort = 0; nPort < MAX_BEST_PORTALS; nPort++)
			{
				float4 bestPortalPos = arrBestPortalPos[nPort];
				float4 bestPortalDir = arrBestPortalDir[nPort];
				if (bestPortalPos.z)
				{
					float3 lightPos = bestPortalPos;
					float lightSize = bestPortalPos.w;

					//lightPos += SVO_PortalsDir[0].xyz * 2;
					r.direction = normalize(lightPos - vPos0);
					float fDist = length(lightPos - vPos0);

					float4 vC4;
					if (dot(r.direction, vNor0) > 0)
						vC4 = ConeTraceTreeAndSky(fDist, r, SvoParamsDiffuse.x, SvoParamsInject.z, 0, false, false, vNor0);
					else
						vC4 = float4(0, 0, 0, 1);

					float fBr = GetSkyColor(vNor0, 0).b * saturate(1 - vC4.w) * saturate(dot(normalize(vNor0), r.direction)) * saturate(1 / (fDist * 0.5f + 1));

					fBr *= saturate(16 * dot(-bestPortalDir, r.direction));

					if (!nPass)
					{
						arrPortOut[0].xyz += r.direction * fBr;
						arrPortOut[0].w += fBr;
					}
					else
					{
						arrPortOut[1].xyz += r.direction * fBr;
						arrPortOut[1].w += fBr;
					}
				}
			}
		}

		if (bSameMinMaxDepth)
		{
			arrPortOut[1] = arrPortOut[0];
			break;
		}
	}

	OUT.Specular += arrPortOut[0];
	OUT.Specular1 += arrPortOut[1];

	#endif

	#if %_RT_SPRITE
	{
		float4 vC = 0;
		Ray r;

		r.direction = normalize(OUT.Specular.xyz);
		r.startpoint = GetWorldPos(VOX_DEPTH_SCALE * fDepthMin - VOX_DEPTH_BIAS, IN.CamVec);
		float fDirectionality = saturate(length(OUT.Specular.xyz) / OUT.Specular.w);
		vC = 0;
		ProcessAnalyticalOccluders(VOX_POST_AO_MAX_DIST, r, vC, IsDiffuseMode() ? fDirectionality : pow(fAverSmoothness, .5), true);

		#if %_RT_LIGHTVOLUME1 && %_RT_LIGHTVOLUME0
		OUT.Specular *= saturate(1 - vC.w * 0.5);
		#else
		OUT.Specular *= saturate(1 - vC.w);
		#endif

		if (!bSameMinMaxDepth)
		{
			r.direction = normalize(OUT.Specular1.xyz);
			r.startpoint = GetWorldPos(VOX_DEPTH_SCALE * fDepthMax - VOX_DEPTH_BIAS, IN.CamVec);
			float fDirectionality = saturate(length(OUT.Specular1.xyz) / OUT.Specular1.w);
			vC = 0;
			ProcessAnalyticalOccluders(VOX_POST_AO_MAX_DIST, r, vC, IsDiffuseMode() ? fDirectionality : pow(fAverSmoothness, .5), true);
		}

		#if %_RT_LIGHTVOLUME1 && %_RT_LIGHTVOLUME0
		OUT.Specular1 *= saturate(1 - vC.w * 0.5);
		#else
		OUT.Specular1 *= saturate(1 - vC.w);
		#endif
	}
	#endif

#endif

	float3 vReprojTC_Min = Reproject(IN.baseTC.xy, fDepthMin, SVO_ReprojectionMatrix);
	float3 vReprojTC_Max = Reproject(IN.baseTC.xy, fDepthMax, SVO_ReprojectionMatrix);

	float fDepthMinPrev = tex2DlodLC(sceneRgbMinPrev, float4(vReprojTC_Min.xy, 0, 0)).w;
	float fDepthMaxPrev = tex2DlodLC(sceneRgbMaxPrev, float4(vReprojTC_Max.xy, 0, 0)).w;

	float fBlendMin = GetBlendMin(vReprojTC_Min.xy, IN.baseTC.xy, fAverSmoothness, fDepthMin, fDepthMinPrev);
	float fBlendMax = GetBlendMin(vReprojTC_Max.xy, IN.baseTC.xy, fAverSmoothness, fDepthMax, fDepthMaxPrev);

	OUT.Diffuse = clamp(lerp(tex2DlodLC(sceneRgbMinPrev, float4(vReprojTC_Min.xy, 0, 0)), OUT.Diffuse, fBlendMin), -8, 8);
	OUT.Specular = clamp(lerp(tex2DlodLC(sceneAldMinPrev, float4(vReprojTC_Min.xy, 0, 0)), OUT.Specular, fBlendMin), -8, 8);

	OUT.Diffuse1 = clamp(lerp(tex2DlodLC(sceneRgbMaxPrev, float4(vReprojTC_Max.xy, 0, 0)), OUT.Diffuse1, fBlendMax), -8, 8);
	OUT.Specular1 = clamp(lerp(tex2DlodLC(sceneAldMaxPrev, float4(vReprojTC_Max.xy, 0, 0)), OUT.Specular1, fBlendMax), -8, 8);

	return OUT;
}

void ProcessLights(inout float4 vALD, inout float4 vRGB, in float3 vPos0, in float3 vNor0, in float fOffset, bool bSpec, float3 vReflection, float fSpecPow, float fLightRadMin, bool bAllowDynamicVoxels = true, bool bShadows = true, float fCustomSunConesLen = 0, bool bSkipSun = false)
{
#if %_RT_SAMPLE5

	for (int nLightId = 0; nLightId < 32; nLightId++)
	{
		float4 vPosR = 0, vDirF = 0, vCol = 0;

		if (!GetLightTI(nLightId, vPosR, vDirF, vCol))
			break;

		if (vPosR.w < fLightRadMin)
			continue;

		if (nLightId == 0 && bSkipSun && vPosR.w > 2000)
			continue;

		Ray r;
		r.direction = (vPosR.xyz - vPos0);
		float fDist = length(r.direction);
		if (fDist > vPosR.w)
			continue;

		r.direction = normalize(r.direction);

		float fNdotL = saturate(dot(vNor0, r.direction) + (1.f - length(vNor0)));

		if (fNdotL > 0)
		{
			float fFovAtt = 1.f;

			if (vDirF.w)
			{
				float fAngle = acos(dot(vDirF.xyz, -r.direction));
				float fAngleMax = (vDirF.w / 180.f * 3.14f / 2.f);
				fFovAtt = saturate((fAngleMax - fAngle) * 8.f);
			}

			if (fFovAtt > 0)
			{
				float fRayLen = min(fDist - fOffset * 2, min(fDist * .9f, fCustomSunConesLen ? fCustomSunConesLen : (VOX_CONE_MAX_LEN * 2)));

				if (length(vCol.xyz) < 0.01f)
					continue;

				if (bSpec)
				{
					float fPowAmount = sqrt(saturate(dot(vReflection, r.direction)));
					fPowAmount = saturate(pow(fPowAmount, fSpecPow * 255.f)) - 0.01;

					if (fPowAmount > 0)
					{
						r.startpoint = vPos0 + vNor0 * fOffset / 40 + r.direction * fOffset;

						float4 vPos1 = 0, vNor1 = 0;
						float4 vC = 0;
						if (vCol.a > 0 && bShadows)
							vC = ConeTraceTree(r, SvoParamsCommon.x, vPos1, vNor1, 0, fRayLen);

						float3 vColorAdd = fNdotL * (1.f - vC.a) * vCol.xyz * saturate(1.f - fDist / vPosR.w) * fFovAtt * fPowAmount;// * vShadowCol;

						float fSunBr = length(vColorAdd);
						vALD.xyz += fSunBr * r.direction;
						vALD.w += fSunBr;
						vRGB.xyz += vColorAdd;
					}
				}
				else
				{
					r.startpoint = vPos0 + vNor0 * fOffset / 3 + r.direction * fOffset;

					float4 vPos1 = 0, vNor1 = 0;

					float4 vC = 0;
					if (vCol.a > 0 && bShadows)
						vC = ConeTraceTree(r, SvoParamsCommon.x, vPos1, vNor1, 0, fRayLen);

					float3 vColorAdd = fNdotL * (1.f - vC.a) * vCol.xyz * saturate(1.f - fDist / vPosR.w) * fFovAtt;// * vShadowCol;

					if (vPosR.w < 5000) // if point light
						vColorAdd *= SvoParamsMisc2.x;

					float fSunBr = length(vColorAdd);
					vALD.xyz += fSunBr * r.direction;
					vALD.w += fSunBr;
					vRGB.xyz += vColorAdd;
				}
			}
		}
	}

#endif
}

#ifdef SVO_LMAPS

pixoutMRT ConeTracePS_NID_GS(vtxOutWPOS IN)
{
	pixoutMRT OUT = (pixoutMRT)0;

	int nAtlasOffset = (int)IN.CamVec.w + .45;
	float3 tcMin = ComputeDataTC(nAtlasOffset);

	float4 voxAreaMin, voxAreaMax;
	ReadNodeCropBox(tcMin, voxAreaMin, voxAreaMax);

	IN.HPosition = mul(SVO_ViewProj, IN.baseTC);
	IN.HPosition /= IN.HPosition.w;
	IN.HPosition.xy = IN.HPosition.xy * 0.5f + 0.5f;
	IN.HPosition.y = 1 - IN.HPosition.y;
	IN.baseTC.xy = IN.HPosition.xy;

	float3 x0 = lerp(SVO_FrustumVerticesCam0, SVO_FrustumVerticesCam1, 1 - IN.baseTC.x);
	float3 x1 = lerp(SVO_FrustumVerticesCam3, SVO_FrustumVerticesCam2, 1 - IN.baseTC.x);
	IN.CamVec.xyz = lerp(x0, x1, IN.baseTC.y);

	// reconstruct position
	#if %_RT_SAMPLE3
	float3 vPos0 = GetWorldPos(SampleLinearDepth(sceneDepth, IN.baseTC.xy), IN.CamVec);
	#else
	float3 vPos0 = GetWorldPos(VOX_DEPTH_SCALE * SampleLinearDepth(sceneDepth, IN.baseTC.xy) - VOX_DEPTH_BIAS, IN.CamVec);
	#endif

	if (!IsPointInAABB(vPos0, voxAreaMin, voxAreaMax))
	{
		clip(-1);
		return OUT;
	}

	OUT.Diffuse.w = nAtlasOffset;
	OUT.Diffuse.x = 1.f / 255.f * (nAtlasOffset & 255);
	nAtlasOffset /= 256;
	OUT.Diffuse.y = 1.f / 255.f * (nAtlasOffset & 255);
	nAtlasOffset /= 256;
	OUT.Diffuse.z = 1.f / 255.f * (nAtlasOffset & 255);
	nAtlasOffset /= 256;
	return OUT;
}

bool ConeTraceBrick_LM(const float3 vRayStartPos, inout Ray r, const float _fDistanceIn, inout float fDistance, const float fDistanceMax,
                       inout float4 vPosOut, inout float4 vNormal, const float3 tcMin, inout float4 vRgbOut, const float fAlphaRef, const float fLodRatio,
                       const float fAlphaRefMin, const float fAlphaRefMax, const int nPredictionMode, const float fMultTriRT, const bool bAirOnlyMode, const bool bApplyGlobalDensity, const bool bSpecular)
{
	bool bRes = true;

	float4 voxAreaMin, voxAreaMax;
	ReadNodeCropBox(tcMin, voxAreaMin, voxAreaMax);
	const float ocNodeSize = voxAreaMin.w;

	const float3 vHalfTexSizeWS = 0.5f / VOX_BRICK_TEXRES * ocNodeSize;
	const float3 vBoxSize = voxAreaMax.xyz - voxAreaMin.xyz;

	float tmin = 0, tmax = 0;
	const float fSafetyBorder = 0.001f;
	//	const bool bHit = IntersectRayAABB(r, voxAreaMin.xyz-fSafetyBorder, voxAreaMax.xyz+fSafetyBorder, tmin, tmax);

	//if( bHit && (tmax>0))
	{
		const float3 vMulTC = 1.f / ocNodeSize * vBoxSize / VOX_ATLAS_SIZE * VOX_SUBBLOCK_SIZE_RATIO;

		float3 vNextTC = tcMin + ((clamp(r.startpoint, voxAreaMin + vHalfTexSizeWS, voxAreaMax - vHalfTexSizeWS) - voxAreaMin.xyz) / (vBoxSize)) * vMulTC;

		vRgbOut = tex3DlodLC(brickPool_Rgbs, float4(vNextTC.xyz, 0));

		vNormal = tex3DlodLC(brickPool_Norm, float4(vNextTC.xyz, 0));
	}

	return bRes;
}

void ConeTrace_LM_PS(in vtxOutWPOS IN, out float4 vALD, out float4 vRGB)
{
	float3 vPos0 = GetWorldPos(SampleLinearDepth(sceneDepth, IN.baseTC.xy), IN.CamVec);
	float fTransmittanceY = 0;
	float3 vNor0 = normalize(GetWorldSpaceNormals(IN.baseTC.xy, fTransmittanceY, normalize(IN.CamVec.xyz)).xyz);

	vALD = 0;
	vRGB = 0;

	float fNewDepth = SampleLinearDepth(sceneDepth, IN.baseTC.xy);

	int nAtlasOffset = tex2DlodPC(sceneSvoMap, float4(IN.baseTC.xy, 0, 0)).w;

	if (nAtlasOffset < 0 || tex2DlodPC(sceneSvoMap, float4(IN.baseTC.xy, 0, 0)).z)
	{
		vALD = float4(0, 0, 0, 0);
		vRGB = 0.1;
		vRGB.w = fNewDepth;
		return;
	}

	float3 tcMin = ComputeDataTC(nAtlasOffset);
	float4 voxAreaMin, voxAreaMax;
	ReadNodeCropBox(tcMin, voxAreaMin, voxAreaMax);

	float fOffset = voxAreaMin.w / 96;

	Ray r;
	r.direction = normalize(vNor0);
	r.startpoint = vPos0 + vNor0 * fOffset;

	float4 vRgbOut = 0;
	float fDistance = 0;
	float4 vPos1 = 0, vNor1 = 0;
	bool bCompleted = ConeTraceBrick_LM(r.startpoint, r, 0, fDistance, 8,
	                                    vPos1, vNor1, tcMin, vRgbOut, .9f, 1.8f,
	                                    0, 1, 0, 0, false, false, false);

	vALD = vNor1;
	vALD.xyz = vALD.xyz * 2 - 1;
	vALD /= max(vRgbOut.w, .01f);

	float4 vC = vRgbOut;
	vC /= max(vRgbOut.w, .01f);

	vRGB.xyz = (vC.xyz + .001);

	vRGB.w = fNewDepth;
}

#endif // SVO_LMAPS

pixoutMRT ConeTracePS(vtxOutWPOS IN)
{
	pixoutMRT OUT = (pixoutMRT)0;

	float4 vALD = 0;
	float4 vRGB = 0;

#if %_RT_SAMPLE3
	#ifdef SVO_LMAPS
	ConeTrace_LM_PS(IN, vALD, vRGB);
	#endif
#else

	// reconstruct position
	float3 vPos0 = GetWorldPos(VOX_DEPTH_SCALE * SampleLinearDepth(sceneDepth, IN.baseTC.xy) - VOX_DEPTH_BIAS, IN.CamVec);

	float3 vNor0 = 0;
	float fAverSmoothness = 0;
	float fAverTransmittanceY = 0;
	float3 vAverReflectance = 0;
	float fDepthMin = 0, fDepthMax = 0;
	float3 vNorMin = 0, vNorMax = 0;
	GetAverNormAndSmooth(IN.baseTC.xy, vNor0, fAverSmoothness, fAverTransmittanceY, normalize(IN.CamVec.xyz), vAverReflectance, fDepthMin, fDepthMax, vNorMin, vNorMax);

	float fDistM = length(vPos0 - PS_WorldViewPos.xyz);

	//float fOffset = VOX_MIN_VOX_SIZE*2/3 + fDistM/96; // TODO: make cone trace func skip first 1-2 voxels instead of offset here

	float3 vFocus = IsDiffuseMode() ? vNor0 : reflect(normalize(IN.CamVec.xyz), vNor0);

	float fNewDepth = SampleLinearDepth(sceneDepth, IN.baseTC.xy);

	int2 nXY = int2(IN.baseTC.xy * PS_ScreenSize.xy);

	int GI_DIFFUSE_KERNEL_TILING;
	GetDiffuseKernel(GI_DIFFUSE_KERNEL_TILING, 0);

	int x = nXY.x & (GI_DIFFUSE_KERNEL_TILING - (int)1);
	int y = nXY.y & (GI_DIFFUSE_KERNEL_TILING - (int)1);
	int i = x * GI_DIFFUSE_KERNEL_TILING + y;

	const int nFramesNum = (SVO_TargetResScale.w /*|| !IsDiffuseMode()*/) ? 1 : 2;

	#if %_RT_MOTION_BLUR
	const int nPassesNum = 2;
	#else
	const int nPassesNum = 1;
	#endif

	for (int p = 0; p < nPassesNum; p++)
	{
		int s = (nFramesNum == 2) ? (int(SVO_FrameIdByte.x) & 1) : 0;
		s += p * nFramesNum;

		Ray r;

		const int nGiDiffuseSampleNum = GI_DIFFUSE_KERNEL_TILING * GI_DIFFUSE_KERNEL_TILING * 2;
		float3 kern = GetDiffuseKernel(GI_DIFFUSE_KERNEL_TILING, i + s * nGiDiffuseSampleNum / nFramesNum / nPassesNum);

		{
			// dual kernel
			half3x3 rotMat = 0;
			GetRotationV0(vFocus, rotMat);
			bool bRotate = dot(vFocus, float3(0, 0, 1)) > -0.999f;
			float3 kernOpa = GetDiffuseKernel(GI_DIFFUSE_KERNEL_TILING, i + s * nGiDiffuseSampleNum / nFramesNum / nPassesNum, false);

			if (nFramesNum == 2) // TODO: use rotation instead of flip
			{
				if (int(SVO_FrameIdByte.x / 2) & 1)
					kernOpa.x = -kernOpa.x;
				if (int(SVO_FrameIdByte.x / 2) & 2)
					kernOpa.y = -kernOpa.y;
			}

			kernOpa.z -= SvoParamsCommon.y;

			if (bRotate)
				kernOpa = normalize(mul(normalize(kernOpa), rotMat));
			else
				kernOpa = normalize(float3(kernOpa.x, kernOpa.y, -kernOpa.z));

			if (IsDiffuseMode())
				kern = lerp(kernOpa, kern, saturate(fAverTransmittanceY * 4));
			else
				kern = kernOpa;
		}

		half power;
		if (IsDiffuseMode())
		{
			//kern.z += SvoParamsCommon.y;
			power = 0;
		}
		else
		{
			// Fresnel
			//fAverSmoothness = lerp(fAverSmoothness, 1, pow(1 - dot(-normalize(IN.CamVec.xyz), vNor0), 2));

			power = exp2(10.h * fAverSmoothness + 1.h);
			kern += vFocus * power / 25;
		}

		r.direction = normalize(kern);

		r.startpoint = vPos0;

		#if %_RT_TILED_SHADING
		  r.startpoint += (vFocus * fAverTransmittanceY) * (VOX_MIN_VOX_SIZE + fDistM*.025f);
		#endif

	#if !ORBIS
		#if %_RT_SAMPLE5 && !%_RT_LIGHTVOLUME1 && %_RT_LIGHTVOLUME0
		if (SvoTreeSettings5.y)
		{
			float4 arrBestPortalPos[MAX_BEST_PORTALS];
			float4 arrBestPortalDir[MAX_BEST_PORTALS];
			FindBestPortals(vPos0, vNor0, arrBestPortalPos, arrBestPortalDir);

			float4 bestPortalPos = arrBestPortalPos[i & int(MAX_BEST_PORTALS - 1)];
			float3 lightPos = bestPortalPos;
			float lightSize = bestPortalPos.w;
			if (lightPos.z)
			{
				float3 vDir = normalize(lightPos - vPos0);
				float fDist = length(lightPos - vPos0);
				float fLerp = SvoTreeSettings5.y * saturate(fDist / lightSize) * pow(saturate(dot(vDir, vNor0.xyz)), .25) * saturate(abs(SvoParamsSkyColor.w));
				if (!IsDiffuseMode())
				{
					// reduce kernel distortion for mirrors
					fLerp *= 1 - saturate(fAverSmoothness) * saturate(GetLuminance(vAverReflectance));
				}
				r.direction = normalize(lerp(r.direction, vDir, fLerp));
			}
		}
		#endif
	#endif

		float4 vC = 0;

		float fRayLen;
	#if %_RT_LIGHTVOLUME1
		fRayLen = VOX_POST_AO_MAX_DIST; // in this mode we call ConeTraceTreeAndSky for near range AO info and for light bounces
	#else
		fRayLen = VOX_CONE_MAX_LEN;
	#endif

		vC = ConeTraceTreeAndSky(fRayLen, r, SvoParamsDiffuse.x + power / 10000, SvoParamsInject.z, 0, false, false, normalize(vNor0));

		vC *= lerp(1.f, SvoParamsInject.w, saturate(fAverTransmittanceY * 8));

		vC /= nPassesNum;

		float fBr = length(vC.xyz);
		vALD.xyz += r.direction * fBr;
		vALD.w += fBr;
		vRGB.xyz += vC.xyz;
	}

	vRGB.xyz += 0.001f;
	vRGB.w = fNewDepth;

#endif

	OUT.Diffuse = vALD;
	OUT.Specular = vRGB;
	OUT.Specular.w = vRGB.w;

	return OUT;
}

pixout_RenderAtmosphere RenderAtmospherePS(vtxOutWPOS IN)
{
	pixout_RenderAtmosphere OUT = (pixout_RenderAtmosphere)0;

	MaterialAttribsCommon gbuffer = DecodeGBufferChannels(IN.baseTC.xy);

	float fDepth0 = SampleLinearDepth(sceneDepth, IN.baseTC.xy);
	float fDepthMin = fDepth0;
	float fDepthMax = fDepth0;

	float3 vPos0 = GetWorldPos(fDepth0, IN.CamVec);

	float3 ray_endpoint = vPos0;
	float3 ray_endpoint_min = ray_endpoint;
	float3 ray_endpoint_max = ray_endpoint;

	int nRange = int(SVO_TargetResScale.x); // TODO: SVO_TargetResScale.x is wrong!!!
	float2 vR = 1.f / PS_ScreenSize.xy / nRange;

	// find min/max depth ray end in the area
	for (int x = -nRange / 2; x <= nRange / 2; x++)
		for (int y = -nRange / 2; y <= nRange / 2; y++)
		{
			float2 tc = IN.baseTC.xy + vR * float2(x, y);

			float fDepth = SampleLinearDepth(sceneDepth, tc);

			if (fDepth < fDepthMin)
			{
				ray_endpoint_min = GetWorldPos(fDepth, IN.CamVec);
				fDepthMin = fDepth;
			}

			if (fDepth > fDepthMax)
			{
				ray_endpoint_max = GetWorldPos(fDepth, IN.CamVec);
				fDepthMax = fDepth;
			}
		}

	Ray r;
	r.startpoint = PS_WorldViewPos.xyz + float3(0, 0, .125);

	float fTraceMaxDist = 1024 * 4;
	float fDistanceMax = min(fTraceMaxDist, length(ray_endpoint_max - r.startpoint));
	float fDistanceMin = min(fTraceMaxDist, length(ray_endpoint_min - r.startpoint));

	r.direction = normalize(vPos0.xyz - PS_WorldViewPos.xyz);
	r.startpoint += r.direction / 10;

	float fLod = 2;

	OUT.SVO_Shadow.r = fDepthMin;
	OUT.SVO_Shadow.g = fDepthMax;

	fDistanceMin = min(fTraceMaxDist, length(ray_endpoint_min - r.startpoint));
	fDistanceMax = min(fTraceMaxDist, length(ray_endpoint_max - r.startpoint));

	{
		float4 vPos1 = 0, vNor1 = 0;
		float4 vAirMax = ConeTraceTree(r, fLod, vPos1, vNor1, fDistanceMin, fDistanceMax, 0.f, 1.f, 0, 0, SVO_TRACE_MODE_AIR, true, true); // air

		float4 vAirMin = vNor1;
		if (vAirMin.w == 0)
			vAirMin = vAirMax;
		if (fDepth0 != 1)
			vAirMin.xyz /= saturate(vAirMin.w + .001);
		OUT.Air_RGBA_Min.xyz = (vAirMin.xyz * SvoParamsSpecular.z);
		OUT.Air_RGBA_Min.w = vAirMin.w;

		if (fDepth0 != 1)
			vAirMax.xyz /= saturate(vAirMax.w + .001);
		OUT.Air_RGBA_Max.xyz = (vAirMax.xyz * SvoParamsSpecular.z);
		OUT.Air_RGBA_Max.w = vAirMax.w;
	}

	//	float3 lightDir=0;
	//	float4 vPosR=0, vDirF=0, vCol=0;
	//if(GetLightTI(0, vPosR, vDirF, vCol))
	//lightDir = normalize(vPosR-vPos0.xyz);

	if (fDistanceMax == fTraceMaxDist)
	{
		// add the sky
		//OUT.Diffuse.xyz += (1-OUT.Diffuse.w) * VOX_SKY_COLOR * 6;

		// add the sun spot on the sky
		//if(vPosR.w > SUN_LIGHT_RADIUS)
		{
			//			float fDotRef = .96;
			//		OUT.Diffuse.xyz += (1-OUT.Diffuse.w) * pow(saturate(dot(r.direction, lightDir)-fDotRef)/(1-fDotRef), 22) * vCol * 4;
		}

		//OUT.Diffuse.w = 1;
	}

	//OUT.Diffuse.w = 0;

	//if(vPosR.w > SUN_LIGHT_RADIUS)
	{
		/*#if !%_RT_SAMPLE0
		   if(fDistanceMax != fTraceMaxDist)
		   {
		   // air sun shadows
		   r.direction = lightDir;
		   r.startpoint = vPos0 + r.direction;

		   float4 vPos1=0, vNor1=0;
		   OUT.SVO_Shadow.a = saturate(1.f - ConeTraceTree(r, SvoParamsCommon.x, vPos1, vNor1, 0, 4000, 0.f, 1.f, 0, 0, false).a); // air
		   }
		   else
		 #endif*/
		OUT.SVO_Shadow.a = 1;
	}

	return OUT;
}

pixout_TraceSunShadows TraceSunShadowsPS(vtxOutWPOS IN)
{
	pixout_TraceSunShadows OUT = (pixout_TraceSunShadows)0;

	float fDepth0 = SampleLinearDepth(sceneDepth, IN.baseTC.xy);
	float fDepthMin = fDepth0;
	float fDepthMax = fDepth0;

	float3 vPos0 = GetWorldPos(fDepth0, IN.CamVec);

	int nRange = int(SVO_TargetResScale.x);
	float2 vR = 1.f / PS_ScreenSize.xy / nRange;

	// find min/max depth ray end in the area
	for (int x = -nRange / 2; x <= nRange / 2; x++)
	{
		for (int y = -nRange / 2; y <= nRange / 2; y++)
		{
			float2 tc = IN.baseTC.xy + vR * float2(x, y);

			float fDepth = SampleLinearDepth(sceneDepth, tc);

			if (fDepth < fDepthMin)
			{
				fDepthMin = fDepth;
			}

			if (fDepth > fDepthMax)
			{
				fDepthMax = fDepth;
			}
		}
	}

	OUT.SVO_Shadow = 1;

	if (fDepthMin < 1.f)
	{
		float fTransmittanceY = 0;
		const float3 vNor0 = normalize(GetWorldSpaceNormals(IN.baseTC.xy, fTransmittanceY, normalize(IN.CamVec.xyz)).xyz);

		float3 sunDir = 0;
		float4 vPosR = 0, vDirF = 0, vCol = 0;
		if (GetLightTI(0, vPosR, vDirF, vCol))
			sunDir = normalize(vPosR - vPos0.xyz);

		float3 arrPosMinMax[2] =
		{
			GetWorldPos(fDepthMin, IN.CamVec),
			GetWorldPos(fDepthMax, IN.CamVec)
		};

		// calculate dithered startpoint offset
		int2 nXY = int2(IN.baseTC.xy * PS_ScreenSize.xy);
		nXY.x = (nXY.x + (int(SVO_FrameIdByte.x) & 1)) & 1;
		nXY.y = (nXY.y + (int(SVO_FrameIdByte.x / 2) & 1)) & 1;
		float3 vOffset = sunDir * (0.5f * (float)nXY.x + 0.25f * (float)nXY.y);

		bool bTraceShadows = (fTransmittanceY > 0.1 || dot(sunDir, vNor0) > 0);

		for (int i = 0; i < 2; i++)
		{
			float distance = length(arrPosMinMax[i] - PS_WorldViewPos.xyz);

			Ray r;
			r.direction = sunDir;
			r.startpoint = arrPosMinMax[i] + r.direction * 0.25f + vOffset * saturate(2.f - distance * 0.25f);

			if(bTraceShadows)
			{
				// trace SVO
				#if %_RT_TILED_SHADING
			float4 vPos1 = 0, vNor1 = 0;
					float3 vSurfNorm = (r.direction - normalize(IN.CamVec) * 0.5f);
					OUT.SVO_Shadow[i] = saturate(1.f - ConeTraceTree(r, SvoParamsCommon.x, vPos1, vNor1, 0, 63, 0.f, 1.f, 0, 0, 0, false, false, false, vSurfNorm, 0, 1.f).a);
				#endif

				// trace heightmap
				#if %_RT_QUALITY1 
				if (OUT.SVO_Shadow[i] > 0)
				{
					const int samplesNum = 64;
					const float maxShadowLen = 512.f; // in meters
					const float shadowHardness = 1.f / 10.f;

					const float texturePoolItemSizeScale = 1.f / 16.f; // 1.f / sqrt(e_TerrainTextureStreamingPoolItemsNum)
					const float3 worldToTc = float3(1.f / VOX_WORLD_SIZE * texturePoolItemSizeScale, 1.f / VOX_WORLD_SIZE * texturePoolItemSizeScale, 1.f);
					const float tcMin = 0.01 * texturePoolItemSizeScale;
					const float tcMax = 0.98 * texturePoolItemSizeScale;

					float3 vStepSize = r.direction / samplesNum * maxShadowLen;
					float3 vPos = arrPosMinMax[i] + vStepSize;
					vPos.z += distance * 0.001;
					vPos *= worldToTc;
					vStepSize *= worldToTc;

					for (int t = 0; t < samplesNum; t++)
					{
						float h = tex2DlodLC(levelHeightmap, vPos.yx).x;

						if (vPos.x > tcMin && vPos.x < tcMax && vPos.y >tcMin && vPos.y < tcMax)
							OUT.SVO_Shadow[i] = min(OUT.SVO_Shadow[i], saturate(1.f - (h - vPos.z) * shadowHardness));

						vPos += vStepSize;
					}
				}
				#endif
			}
			else
			{
				OUT.SVO_Shadow[i] = 0;
			}

			if (fDepthMin / fDepthMax > VOX_DEPTH_RANGE_THRESHOLD)
			{
				// skip second trace if min/max depths are close
				OUT.SVO_Shadow[1] = OUT.SVO_Shadow[0];
				break;
			}
		}

		OUT.SVO_Shadow[2] = fDepthMin;
		OUT.SVO_Shadow[3] = fDepthMax;
	}

	return OUT;
}

[numthreads(VOX_COMPUTE_NUM_THREADS, VOX_COMPUTE_NUM_THREADS, 1)]
void ComputeClearBricks(uint3 Gid : SV_GroupID, uint3 GTid : SV_GroupThreadID, uint3 DTid : SV_DispatchThreadID, uint Gidx : SV_GroupIndex)
{
	int nNodeOffset = GetNodeRequestedForUpdate(Gid.x);
	if (nNodeOffset >= 0)
	{
		float3 vDataTC = ComputeDataTC(nNodeOffset);

		uint3 coord0 = vDataTC * float3(VOX_TEX_POOL_DIM);
		uint3 coord1 = coord0 + uint(VOX_BRICK_TEXRES);
		uint3 coord = coord0 + uint3(GTid.x, GTid.y, Gid.y);

		float4 pixel = 0;
		UAV_7[coord] = FlOAT4_TO_UINT(pixel);
		UAV_5[coord] = FlOAT4_TO_UINT(pixel);
		UAV_6[coord] = FlOAT4_TO_UINT(pixel);
		UAV_0[coord] = FlOAT4_TO_UINT(float4(.5, .5, .5, 0));

		UAV_3[coord] = UAV_4[coord];
	}
}

float noise(float3 q)
{
	float fVal = 0;
	fVal += tex2DlodLW(noiseMap2D, float4(q.xz, 0, 0)).g - .5;
	fVal += tex2DlodLW(noiseMap2D, float4(q.yz, 0, 0)).g - .5;
	fVal += tex2DlodLW(noiseMap2D, float4(q.xy, 0, 0)).g - .5;
	return fVal * 1.25f;
}

float MapCloudsInt(float3 vPos0)
{
	float3 q = vPos0 * VOX_TI_ATMO_CLOUDS_GEN_FREQ / float3(VOX_WORLD_SIZE, VOX_WORLD_SIZE, VOX_WORLD_SIZE / 2);

	float noq = noise(q * VOX_TI_ATMO_CLOUDS_TURB_FREQ);
	q.x += sin(noq) * VOX_TI_ATMO_CLOUDS_TURB_SCALE;
	q.z += cos(noq) * VOX_TI_ATMO_CLOUDS_TURB_SCALE;

	float f = 0;
	float k = .5;
	float f2 = 0;

	if (VOX_TI_ATMO_CLOUDS_GEN_FREQ)
		for (int p = 0; p < 4; p++)
		{
			float fNoise = noise(q);
			f += k * fNoise;
			f2 += k * fNoise;
			q = q * VOX_TI_ATMO_CLOUDS_GEN_FREQ_STEP;//2.02;

			float noq = noise(q * VOX_TI_ATMO_CLOUDS_TURB_FREQ);
			q.x += sin(noq) * VOX_TI_ATMO_CLOUDS_TURB_SCALE;
			q.y += cos(noq) * VOX_TI_ATMO_CLOUDS_TURB_SCALE;

			k *= VOX_TI_ATMO_CLOUDS_GEN_SCALE;
		}

	return (f);
}

float MapClouds(float3 vPos0, bool bFogVolumes)
{
	float f = MapCloudsInt(vPos0);

	float fcloudsLayerZ = VOX_TI_ATMO_CLOUDS_GEN_HEIGHT * 2 / 3;
	float fH = pow(saturate((abs(fcloudsLayerZ - vPos0.z) / (VOX_TI_ATMO_CLOUDS_GEN_HEIGHT / 3))), 4);

	float fXYBorder = VOX_WORLD_SIZE / 32;
	fH += saturate((fXYBorder - vPos0.x) / fXYBorder);
	fH += saturate((fXYBorder - vPos0.y) / fXYBorder);
	fH += 1.f - saturate((VOX_WORLD_SIZE - vPos0.x) / fXYBorder);
	fH += 1.f - saturate((VOX_WORLD_SIZE - vPos0.y) / fXYBorder);

	f = min(pow(saturate((f - fH - .35) / 1000), .75), .0025);

	if (bFogVolumes)
	{
		if (VOX_TI_ATMO_HEIGHT_LAYER0 > VOX_TI_ATMO_HEIGHT_GROUND)
			f = max(f, VOX_TI_ATMO_HEIGHT_LAYER0_DENS * saturate(1 - (VOX_TI_ATMO_HEIGHT_LAYER0_RAND * MapCloudsInt(vPos0 * 512 / (VOX_TI_ATMO_HEIGHT_LAYER0 - VOX_TI_ATMO_HEIGHT_GROUND))) - (vPos0.z - VOX_TI_ATMO_HEIGHT_GROUND) / (VOX_TI_ATMO_HEIGHT_LAYER0 - VOX_TI_ATMO_HEIGHT_GROUND)));
		else if (VOX_TI_ATMO_HEIGHT_LAYER0 < 0)
			f = max(f, VOX_TI_ATMO_HEIGHT_LAYER0_DENS * saturate(-VOX_TI_ATMO_HEIGHT_LAYER0 - vPos0.z));

		if (VOX_TI_ATMO_HEIGHT_LAYER1 > VOX_TI_ATMO_HEIGHT_GROUND)
			f = max(f, VOX_TI_ATMO_HEIGHT_LAYER1_DENS * saturate(1 - (VOX_TI_ATMO_HEIGHT_LAYER1_RAND * MapCloudsInt(vPos0 * 512 / (VOX_TI_ATMO_HEIGHT_LAYER1 - VOX_TI_ATMO_HEIGHT_GROUND))) - (vPos0.z - VOX_TI_ATMO_HEIGHT_GROUND) / (VOX_TI_ATMO_HEIGHT_LAYER1 - VOX_TI_ATMO_HEIGHT_GROUND)));
		else if (VOX_TI_ATMO_HEIGHT_LAYER1 < 0)
			f = max(f, VOX_TI_ATMO_HEIGHT_LAYER1_DENS * saturate(-VOX_TI_ATMO_HEIGHT_LAYER1 - vPos0.z));
	}

	return saturate(f);
}

[numthreads(VOX_COMPUTE_NUM_THREADS, VOX_COMPUTE_NUM_THREADS, 1)]
void ComputeInjectAtmosphere(uint3 Gid : SV_GroupID, uint3 GTid : SV_GroupThreadID, uint3 DTid : SV_DispatchThreadID, uint Gidx : SV_GroupIndex)
{
	int nNodeOffset = GetNodeRequestedForUpdate(Gid.x);
	if (nNodeOffset >= 0)
	{
		float3 vDataTC = ComputeDataTC(nNodeOffset);
		float4 voxAreaMin, voxAreaMax;
		float fNodeFrameId = ReadNodeCropBox(vDataTC, voxAreaMin, voxAreaMax);

		// find region for update
		float3 vTC0, vTC1;
		PrepareBrickInjection(vDataTC, vTC0, vTC1);
		uint3 coord0 = saturate(vTC0) * VOX_TEX_POOL_DIM;
		uint3 coord1 = saturate(vTC1) * VOX_TEX_POOL_DIM;
		uint3 coord = coord0 + uint3(GTid.x, GTid.y, Gid.y);

		if ((coord.x <= coord1.x && coord.y <= coord1.y && coord.z <= coord1.z))
		{
			float4 pixOld = UINT_TO_FlOAT4(UAV_7[coord]);

			if (!pixOld.x && !pixOld.y && !pixOld.z)
			{
				float3 vPos0 = GetVoxCenter(coord, coord0, coord1, voxAreaMin, voxAreaMax);

				float f = 0;
				if (SvoParamsSpecular.z)
					f = saturate(MapClouds(vPos0, true));

				pixOld.a = sqrt(f);

				UAV_7[coord] = FlOAT4_TO_UINT(pixOld);
			}
		}
	}
}

[numthreads(VOX_COMPUTE_NUM_THREADS, VOX_COMPUTE_NUM_THREADS, 1)]
void ComputeDirectStaticLighting(uint3 Gid : SV_GroupID, uint3 GTid : SV_GroupThreadID, uint3 DTid : SV_DispatchThreadID, uint Gidx : SV_GroupIndex)
{
	int nNodeOffset = GetNodeRequestedForUpdate(Gid.x);
	if (nNodeOffset >= 0)
	{
		float3 vDataTC = ComputeDataTC(nNodeOffset);
		float4 voxAreaMin, voxAreaMax;
		float fNodeFrameId = ReadNodeCropBox(vDataTC, voxAreaMin, voxAreaMax);

		// find region for update
		float3 vTC0, vTC1;
		PrepareBrickInjection(vDataTC, vTC0, vTC1);
		uint3 coord0 = saturate(vTC0) * VOX_TEX_POOL_DIM;
		uint3 coord1 = saturate(vTC1) * VOX_TEX_POOL_DIM;
		uint3 coord = coord0 + uint3(GTid.x, GTid.y, Gid.y);

		float4 pixel = UINT_TO_FlOAT4(UAV_2[coord]);

		if ((coord.x <= coord1.x && coord.y <= coord1.y && coord.z <= coord1.z))
		{
			// get geom normal
			float3 vNor0 = 0;

			// get world position
			float3 vPos0 = GetVoxCenter(coord, coord0, coord1, voxAreaMin, voxAreaMax);

			bool bFogVolumes = true;

			float4 vOPAC = LoadTexel(brickPool_Opac, coord);
			bool bAir = (!vOPAC.x && !vOPAC.y && !vOPAC.z);

			if (bAir)
			{

			}
			else
			{
				// get geom normal
				vNor0 = LoadTexel(brickPool_Norm, coord);
				vNor0.xyz = (vNor0.zyx - .5) * 2;
			}

			// compute normal from density
			/*float3 vNormD=0;
			   {
			   float4 pixel_c = UINT_TO_FlOAT4(UAV_2[coord]); // bad
			   float fSumm=0;
			   for(int x=-1; x<=1; x++)
			   for(int y=-1; y<=1; y++)
			   for(int z=-1; z<=1; z++)
			   {
			   int3 coord_n = coord+int3(x,y,z);
			   coord_n = clamp(coord_n, coord0, coord1);
			   float4 pixel_n = UINT_TO_FlOAT4(UAV_2[coord_n]);
			   vNormD += float3(x,y,z)*(pixel_c.w - pixel_n.w);
			   fSumm++;
			   }
			   if(length(vNormD.xyz)>.5)
			   vNormD = normalize(vNormD);
			   else
			   vNormD = 0;
			   }*/

			float4 vALD = 0;
			float4 vRGB = 0;

			bool bSunRsmSUccess = false;
			/*
			   float4 vSunPosR=0, vSunDirF=0, vSunCol=0;
			   GetLightTI(0, vSunPosR, vSunDirF, vSunCol);

			   // use sun RSM if possibe
			   if(dot(vNor0, normalize(vSunPosR.xyz - vPos0.xyz))>0.5 && vSunPosR.w>5000)
			   if(SVO_RsmSunCol.r || SVO_RsmSunCol.g || SVO_RsmSunCol.b)
			   {
			   float4 vShadTC = mul(SVO_RsmSunShadowProj, float4(vPos0.xyz + vNor0.xyz*voxAreaMin.w/VOX_BRICK_TEXRES/4 - PS_WorldViewPos.xyz, 1.f));

			   vShadTC.xy /= vShadTC.w;

			   float fFilerScale = 1;//(0.9 + 0.1*voxAreaMin.w / 1);

			   half4 vSunLightAlbedo = 0;

			   if(vShadTC.x >= 0 && vShadTC.x <= 1 && vShadTC.y >= 0 && vShadTC.y <= 1 && vShadTC.z <= 1)
			   {
			   for(int x=-1; x<=1; x++) for(int y=-1; y<=1; y++)
			   {
			   float2 tc = vShadTC.xy + float2(x,y) / 1024.f * fFilerScale;

			   float fShadowDepth = tex2DlodPC(rsmSunShadowMap, float4(tc,0,0)).r;

			   float fSunVis = saturate(1.f - abs(fShadowDepth - vShadTC.z - 0.00025)*1000 / fFilerScale);

			   vSunLightAlbedo.xyz += tex2DlodPC(rsmSunColorsMap, float4(tc,0,0)).xyz*fSunVis;

			   vSunLightAlbedo.w += 1.f;
			   }

			   vSunLightAlbedo /= vSunLightAlbedo.w;

			   if(length(vSunLightAlbedo)>.1)
			   {
			   vRGB.xyz = SVO_RsmSunCol.rgb;
			   pixel.xyz = vSunLightAlbedo;
			   }

			   bSunRsmSUccess = true;
			   }
			   }*/

			// cone-trace if RSM was not possibe
			{
				float fLength = length(vNor0);

#if %_RT_SAMPLE2
				if (fLength > 0.25 || !fLength)
#else
				if (fLength > 0.25)
#endif
					ProcessLights(vALD, vRGB, vPos0, fLength ? (vNor0 / fLength * 0.75) : 0, voxAreaMin.w / VOX_BRICK_TEXRES * 2, false, 0, 0, 1.f, false, true, 4000, bSunRsmSUccess);
			}

			vRGB.xyz *= SvoParamsInject.x;

			// add glow
			vRGB.xyz += pixel.w * SvoParamsMisc.x;

			// add bias
			vRGB.xyz += max(0, SvoParamsCommon.z * vSkyColorTop.z);

#if %_RT_LIGHTVOLUME0
			if (SvoTreeSettings5.x > 0)
			{
				float4 arrBestPortalPos[MAX_BEST_PORTALS];
				float4 arrBestPortalDir[MAX_BEST_PORTALS];
				FindBestPortals(vPos0, vNor0, arrBestPortalPos, arrBestPortalDir);

				for (int i = 0; i < MAX_BEST_PORTALS; i++)
				{
					float4 bestPortalPos = arrBestPortalPos[i];
					float3 lightPos = bestPortalPos;
					float lightSize = bestPortalPos.w;
					if (lightPos.z)
					{
						float3 vDir = normalize(lightPos - vPos0);
						float fDist = length(lightPos - vPos0);

						Ray r;
						r.direction = vDir;
						r.startpoint = vPos0;
						float4 vNor1 = 0;
						vRGB.xyz += ConeTraceTreeAndSkyEx(fDist, r, SvoParamsDiffuse.x, vNor1, 1.f, 0, false, false, true) * SvoTreeSettings5.x / 2 * saturate(fDist / lightSize);
					}
				}
			}
#endif

			if (bAir)
			{
#if %_RT_SAMPLE2
				float3 vAmb = 0;
				/*float fSky = saturate(vPos0.z-abs(VOX_TI_ATMO_HEIGHT_LAYER1));
				   if(fSky) // simple sky AO
				   {

				   // AO
				   float fAirAO = 1;
				   int nRange = 1;
				   float f = MapClouds(vPos0, false);
				   for(int x=-nRange; x<=nRange; x+=nRange*2)
				   for(int y=-nRange; y<=nRange; y+=nRange*2)
				   for(int z=-nRange; z<=nRange; z+=nRange*2)
				   fAirAO -= (MapClouds(vPos0 + float3(x,y,z) * 40, false))*100;
				   fAirAO = saturate(fAirAO);

				   vAmb = GetSkyColor(vNor0, 0) * fSky * fAirAO / 2;
				   }*/

				pixel = float4(vAmb + vRGB.xyz * VOX_AIR_ALBEDO_COLOR, 0);
#endif
			}
			else
			{
				pixel.xyz *= vRGB.xyz;
			}

			pixel.w = 0;

			pixel = EncodeHDR(pixel);

			UAV_7[coord] = FlOAT4_TO_UINT(pixel);
			UAV_6[coord] = FlOAT4_TO_UINT(pixel);
		}
	}
}

[numthreads(VOX_COMPUTE_NUM_THREADS, VOX_COMPUTE_NUM_THREADS, 1)]
void ComputeDirectDynamicLighting(uint3 Gid : SV_GroupID, uint3 GTid : SV_GroupThreadID, uint3 DTid : SV_DispatchThreadID, uint Gidx : SV_GroupIndex)
{
	int nNodeOffset = GetNodeRequestedForUpdate(Gid.x);
	if (nNodeOffset >= 0)
	{
		float3 vDataTC = ComputeDataTC(nNodeOffset);
		float4 voxAreaMin, voxAreaMax;
		float fNodeFrameId = ReadNodeCropBox(vDataTC, voxAreaMin, voxAreaMax);

		// find region for update
		float3 vTC0, vTC1;
		PrepareBrickInjection(vDataTC, vTC0, vTC1);
		uint3 coord0 = saturate(vTC0) * VOX_TEX_POOL_DIM;
		uint3 coord1 = saturate(vTC1) * VOX_TEX_POOL_DIM;
		uint3 coord = coord0 + uint3(GTid.x, GTid.y, Gid.y);

		float4 pixel = UINT_TO_FlOAT4(UAV_2[coord]);

		float4 vOPAC = LoadTexel(brickPool_Opac, coord);
		bool bAir = (!vOPAC.x && !vOPAC.y && !vOPAC.z);

		if (!bAir)
			if ((coord.x <= coord1.x && coord.y <= coord1.y && coord.z <= coord1.z))
			{
				// get geom normal
				float3 vNor0 = 0;

				// get world position
				float3 vPos0 = GetVoxCenter(coord, coord0, coord1, voxAreaMin, voxAreaMax);

				bool bFogVolumes = true;

				// compute geom normal
				//				vNor0 = LoadTexel( brickPool_Norm,  coord );
				//			vNor0.xyz = (vNor0.zyx-.5)*2;

				float4 vALD = 0;
				float4 vRGB = 0;

				//			float fLength = length(vNor0);
				//			if(fLength > 0.25)

				if (length(vPos0.xyz - SVO_CamPos.xyz) < 24)
				{
					ProcessTiledLights(vRGB, vPos0, 0, voxAreaMin.w / VOX_BRICK_TEXRES);

#if %_RT_AMBIENT_OCCLUSION
					// additional sun RSM inject
					if (voxAreaMin.w <= VOX_MIN_NODE_SIZE * SVO_RsmSunDir.w)
					{
						if (SVO_RsmSunCol.r || SVO_RsmSunCol.g || SVO_RsmSunCol.b)
						{
							float4 vShadTC = mul(SVO_RsmSunShadowProj, float4(vPos0.xyz + vNor0.xyz * voxAreaMin.w / VOX_BRICK_TEXRES / 4 + SVO_RsmSunDir.xyz * voxAreaMin.w / VOX_BRICK_TEXRES - PS_WorldViewPos.xyz, 1.f));
							vShadTC.xy /= vShadTC.w;

							if (vShadTC.x >= 0 && vShadTC.x <= 1 && vShadTC.y >= 0 && vShadTC.y <= 1 && vShadTC.z <= 1)
							{
								float fShadowDepth = tex2DlodPC(rsmSunShadowMap, float4(vShadTC.xy, 0, 0)).r;
								half3 vMatNormal = tex2DlodPC(rsmSunNormalMap, float4(vShadTC.xy, 0, 0)).rgb;

								if (dot(vMatNormal, 1) < 0.01)
									vMatNormal = float3(0, 0, 1); // terrain
								else
									vMatNormal = vMatNormal * 2 - 1;

								vRGB.xyz += SVO_RsmSunCol.xyz * (fShadowDepth > vShadTC.z) * saturate(dot(vMatNormal.xyz, SVO_RsmSunDir.xyz));
							}
						}
					}
#endif    // _RT_AMBIENT_OCCLUSION
				}

				{
					pixel.xyz *= vRGB.xyz * SvoParamsInject.x;
				}

				float4 pixOld = UINT_TO_FlOAT4(UAV_5[coord]);
				pixOld.xyz = DecodeHDR(pixOld);
				pixOld.w = 0;
				pixOld.xyz = max(pixel.xyz, pixOld.xyz);
				pixOld = EncodeHDR(pixOld);
				UAV_7[coord] = FlOAT4_TO_UINT(pixOld);
			}
	}
}

[numthreads(VOX_COMPUTE_NUM_THREADS, VOX_COMPUTE_NUM_THREADS, 1)]
void ComputePropagateLighting(uint3 Gid : SV_GroupID, uint3 GTid : SV_GroupThreadID, uint3 DTid : SV_DispatchThreadID, uint Gidx : SV_GroupIndex)
{
	int nNodeOffset = GetNodeRequestedForUpdate(Gid.x);
	if (nNodeOffset >= 0)
	{
		float3 vDataTC = ComputeDataTC(nNodeOffset);
		float4 voxAreaMin, voxAreaMax;
		float fNodeFrameId = ReadNodeCropBox(vDataTC, voxAreaMin, voxAreaMax);

		// find region for update
		float3 vTC0, vTC1;
		PrepareBrickInjection(vDataTC, vTC0, vTC1);
		uint3 coord0 = saturate(vTC0) * VOX_TEX_POOL_DIM;
		uint3 coord1 = saturate(vTC1) * VOX_TEX_POOL_DIM;

		uint3 coord = coord0 + uint3(GTid.x, GTid.y, Gid.y);

		float4 pixel = LoadTexel(brickPool_Rgbs, coord);

		pixel.xyz = DecodeHDR(pixel);
		pixel.w = 0;

		float4 vOPAC = LoadTexel(brickPool_Opac, coord);
		const bool bSolid = (vOPAC.x || vOPAC.y || vOPAC.z);

#if !%_RT_SAMPLE2
		if (!bSolid)
			return;
#endif

		const int nPassId = SvoParamsMisc.y;
		const int nPassesNum = SvoParamsMisc.z;

		if (SvoParamsInject.y && (coord.x <= coord1.x && coord.y <= coord1.y && coord.z <= coord1.z))
		{
			// get world normal
			float3 vNor0 = LoadTexel(brickPool_Norm, coord);
			vNor0.xyz = 2 * (vNor0.zyx - 0.5f);

			if (!bSolid)
				vNor0 = float3(0, 0, 1);
			else
			{
				/*
				   float3 vNormD = 0;

				   float pixel_c = tex3DlodLC(brickPool_Norm, vTC).w;

				   for (int x = -1; x <= 1; x++)
				   for (int y = -1; y <= 1; y++)
				    for (int z = -1; z <= 1; z++)
				    {
				      int3 coord_n = coord + int3(x, y, z);

				      if (coord_n.x <= coord1.x && coord_n.y <= coord1.y && coord_n.z <= coord1.z)
				        if (coord_n.x >= coord0.x && coord_n.y >= coord0.y && coord_n.z >= coord0.z)
				        {
				          float4 vTC_N = float4(1.f / VOX_TEX_POOL_DIM * coord_n.xyz + 0.5f / VOX_TEX_POOL_DIM, 0);

				          float pixel_n = tex3DlodLC(brickPool_Norm, vTC_N).w;

				          vNormD += float3(x, y, z)*(pixel_c - pixel_n);
				        }
				    }

				   vNormD /= 16;

				   if (length(vNormD) > length(vNor0))
				   vNor0.xyz = normalize(vNormD);
				 */

				if (length(vNor0) < .25)
					return;

				vNor0.xyz = normalize(vNor0.xyz);
			}

			// get world position
			float3 vPos0 = GetVoxCenter(coord, coord0, coord1, voxAreaMin, voxAreaMax);

			float fVoxSize = voxAreaMin.w / VOX_BRICK_TEXRES;

			half3x3 rotMat = 0;
			GetRotationV0(vNor0, rotMat);

			float3 vCollectedLight = 0;
			float4 vCollectedALD = 0;

			{
				half2x2 mSampleRotMat;
				if (bSolid)
					GetRndRotationMat(vPos0 + nPassId, vNor0, mSampleRotMat);
				else
					GetRndRotationMat(vPos0 + vPos0.z, vNor0, mSampleRotMat);

#if %_RT_HW_PCF_COMPARE
				const int nSampleNum = 16;
#else
				const int nSampleNum = 32;
#endif

				for (int s = 0; s < nSampleNum; s++)
				{
					float3 kern;

#if %_RT_HW_PCF_COMPARE
					if (bSolid)
						kern = kernel_HS_16[s];
					else
						kern = kernel_S_16[s];
#else
					if (bSolid)
						kern = kernel_HS_32[s];
					else
						kern = kernel_S_32[s];
#endif

					// apply random rotation
					kern.xy = mul(kern.xy, mSampleRotMat);

					Ray r;
					if (bSolid)
						r.direction = mul(normalize(kern), rotMat);
					else
						r.direction = kern;

					r.startpoint = vPos0 + vNor0 * fVoxSize * 2 + r.direction * fVoxSize * 1.5f;

					float fConeSev = SvoParamsDiffuse.x; // .1f;

					float4 vNor1 = 0;

					float4 vC = ConeTraceTreeAndSkyEx(VOX_CONE_MAX_LEN, r, fConeSev, vNor1, 1.f, 0, false, false, nPassId == 0);

					vCollectedLight += vC;

					vCollectedALD.xyz += length(vC.xyz) * r.direction;
					vCollectedALD.w += length(vC.xyz);
				}

				if (bSolid)
					vCollectedLight /= nSampleNum;
				else
					vCollectedLight /= nSampleNum;///2;

				vCollectedALD /= nSampleNum;
			}

			// desaturate
			vCollectedLight.xyz = lerp((vCollectedLight.x + vCollectedLight.y + vCollectedLight.z) / 3, vCollectedLight.xyz, SvoParamsInject.z);

			RWTexture3D<uint> UAV_Albedo = UAV_0;
			RWTexture3D<uint> UAV_Direct = UAV_1;
			RWTexture3D<uint> UAV_Popag1 = UAV_2;
			RWTexture3D<uint> UAV_Popag2 = UAV_3;
			RWTexture3D<uint> UAV_Out = UAV_5;
			RWTexture3D<uint> UAV_OutDir = UAV_6;
			RWTexture3D<uint> UAV_DYNL = UAV_7;

			float4 vAlbedo = UINT_TO_FlOAT4(UAV_Albedo[coord]);
			if (!bSolid)
				vAlbedo = VOX_AIR_ALBEDO_COLOR;

#if %_RT_SAMPLE3
			//			vCollectedLight *= SvoParamsInject.y;
#else
			vCollectedLight *= vAlbedo.xyz;// * SvoParamsInject.y;
#endif

			vCollectedLight.xyz = pow(vCollectedLight.xyz, SvoParamsInject.y); // helps to propagate bounces furter

			if ((nPassId == 0) && (nPassesNum == 1))
			{
				// single propagation pass
#if %_RT_SAMPLE3
				pixel.xyz = vCollectedLight.xyz;
#else
				pixel.xyz = (pixel.xyz + vCollectedLight);
#endif
			}
			else if ((nPassId == 0) && (nPassesNum == 2))
			{
				// first of two passes
				pixel.xyz = vCollectedLight;
			}
			else if ((nPassId == 1) && (nPassesNum == 2))
			{
				// second of two passes
				pixel.xyz = (pixel.xyz + vCollectedLight);

#if %_RT_SAMPLE3
				pixel.xyz = pixel.xyz;
#else
				pixel.xyz = (pixel.xyz + DecodeHDR(UINT_TO_FlOAT4(UAV_Direct[coord])));
#endif
			}

			pixel = EncodeHDR(pixel);

			UAV_Out[coord] = FlOAT4_TO_UINT(pixel);
			UAV_DYNL[coord] = FlOAT4_TO_UINT(pixel);

#if %_RT_SAMPLE3
			{
				vCollectedALD.xyz = vCollectedALD.xyz * .75 + .5;
				UAV_OutDir[coord] = FlOAT4_TO_UINT(vCollectedALD);

				for (int x = -1; x <= 1; x++)
					for (int y = -1; y <= 1; y++)
						for (int z = -1; z <= 1; z++)
						{
							int3 coord_n = coord + int3(x, y, z);
							if (coord_n.x <= coord1.x && coord_n.y <= coord1.y && coord_n.z <= coord1.z)
								if (coord_n.x >= coord0.x && coord_n.y >= coord0.y && coord_n.z >= coord0.z)
								{
									float4 vOldRGB = UINT_TO_FlOAT4(UAV_Out[coord_n]);
									float4 vOldALD = UINT_TO_FlOAT4(UAV_OutDir[coord_n]);

									float4 pixel_N = tex3DlodLC(brickPool_Rgbs, float4(1.f / VOX_TEX_POOL_DIM * coord_n.xyz + 0.5f / VOX_TEX_POOL_DIM, 0));

									if (vCollectedALD.w > vOldALD.w && pixel_N.w == 0)
									{
										UAV_Out[coord_n] = FlOAT4_TO_UINT(pixel);
										UAV_OutDir[coord_n] = FlOAT4_TO_UINT(vCollectedALD);
									}
								}
						}
			}
#endif
		}
	}
}

#ifdef SVO_LMAPS

vert2FragGeneral VoxelRayTraceVS_GS(app2vertGeneral IN)
{
	vert2FragGeneral OUT = (vert2FragGeneral)0;

	streamPos vertPassPos = (streamPos)0;

	OUT.vView.xyz = g_VS_WorldViewPos.xyz;
	OUT.vView.w = IN.vertCommon.baseTC.x;

	OUT.HPosition.xyz = IN.vertCommon.Position.xyz;
	OUT.HPosition.w = 1.0f;

	OUT.screenProj.x = IN.vertCommon.baseTC.x;
	OUT.screenProj.y = 1 - IN.vertCommon.baseTC.y;

	float fNodeSize = IN.vertCommon.baseTC.y;
	OUT.baseTC.x = IN.vertCommon.Color.r * fNodeSize;
	OUT.baseTC.y = IN.vertCommon.Color.g * fNodeSize;
	OUT.baseTC.z = IN.vertCommon.Color.b * fNodeSize;
	OUT.baseTC.w = IN.vertCommon.Color.a;

	return OUT;
}

[maxvertexcount((2 + 4 * 2) + 4 * 2)]
void BoxGenGS_GS(point vert2FragGeneral InPos[1], inout TriangleStream<vtxOutWPOS> SpriteStream)
{
	vtxOutWPOS OUT = (vtxOutWPOS)0;

	#if !%_RT_SAMPLE3
	if (SVO_PassId_VS.x == 0 && InPos[0].baseTC.w < SVO_PassId_VS.w) // skip non opac bricks for layer 0
		return;
	#endif

	float4 vWorldPos;
	vWorldPos.xyz = InPos[0].HPosition.xyz;// -g_VS_WorldViewPos.xyz;
	vWorldPos.w = 1.0f;

	OUT.baseTC.w = 1.0f;

	OUT.CamVec.w = InPos[0].vView.w;

	float3 vBoxSize = InPos[0].baseTC.xyz;

	for (int v = 0; v < 18; v++)
	{
		OUT.HPosition = vWorldPos;

		OUT.HPosition.xyz += box_expansion[v] * vBoxSize;

		OUT.CamVec.xyz = OUT.HPosition.xyz - g_VS_WorldViewPos.xyz;

		OUT.baseTC = OUT.HPosition; // box vertex pos WS

		OUT.HPosition = mul(g_VS_ViewProjMatr, OUT.HPosition); // transform into screen space

		//OUT.baseTC.xy = (OUT.HPosition.xy / OUT.HPosition.w / 2 + .5);

		if (v == 10 || v == 14)
			SpriteStream.RestartStrip();

		SpriteStream.Append(OUT);
	}

	SpriteStream.RestartStrip();
}

#endif // SVO_LMAPS

pixoutMRT UpScalePS(vtxOutWPOS IN)
{
	pixoutMRT OUT = (pixoutMRT)0;

	const float fDepthRange = .12;
	const float fDotMax = .35;
	const float fDepthC = SampleLinearDepth(sceneDepth, IN.baseTC.xy);
	float fTransmittanceY = 0;
	const float3 vNor0 = normalize(GetWorldSpaceNormals(IN.baseTC.xy, fTransmittanceY, normalize(IN.CamVec.xyz)).xyz);

	float3 vFocus = IsDiffuseMode() ? vNor0 : reflect(normalize(IN.CamVec.xyz), vNor0);

	float4 vRGB = 0;
	float4 vALD = 0;
	float fShadowSvoFin = 0, fShadowSvoDepthMin = 1.f, fShadowSvoDepthMax = 0;
	float fAverSmoothness = 0;
	for (int x = -1; x <= 1; x += 2)
		for (int y = -1; y <= 1; y += 2)
		{
#if %_RT_LIGHTVOLUME1
			const float2 tc1 = IN.baseTC.xy + float2(x, y) * SVO_SrcPixSize.xy / 2 - SVO_SrcPixSize.xy / 2;
#else
			const float2 tc1 = IN.baseTC.xy + float2(x, y) * SVO_SrcPixSize.xy / 2;
#endif

			const float4 tc = float4(tc1, 0, 0);

			const float4 vDiff_RGB_Min = tex2DlodPC(sceneRgbMin, tc);
			const float4 vDiff_ALD_Min = tex2DlodPC(sceneAldMin, tc);
			const float4 vDiff_RGB_Max = tex2DlodPC(sceneRgbMax, tc);
			const float4 vDiff_ALD_Max = tex2DlodPC(sceneAldMax, tc);

			const float fDepthMin = vDiff_RGB_Min.w;
			const float fDepthMax = vDiff_RGB_Max.w;

			float fLerp = saturate((fDepthC - fDepthMin) / max(fDepthMax - fDepthMin, 0.0001f));

			float4 vDiff_RGB = lerp(vDiff_RGB_Min, vDiff_RGB_Max, fLerp);
			float4 vDiff_ALD = lerp(vDiff_ALD_Min, vDiff_ALD_Max, fLerp);

#if %_RT_LIGHTVOLUME1
			const float fDepth1 = SampleLinearDepth(sceneDepth, tc.xy);
#else
			const float fDepth1 = vDiff_RGB.w;
#endif

#if %_RT_LIGHTVOLUME1
			float fTr = 0;
			const float3 vNorm = normalize(GetWorldSpaceNormals(tc.xy, fTr, normalize(IN.CamVec.xyz)).xyz);
#else
			const float3 vNorm = vDiff_ALD;
#endif

			float fDotTest = lerp(.25, saturate(fTransmittanceY * 4 + dot(normalize(vNorm), vFocus) - fDotMax), saturate(length(vNorm) / max(0.0001, vDiff_ALD.w) * 8.f)) + .001;

			float fDepTest = saturate((fDepthRange - abs(1.f - fDepthC / fDepth1)) * 4) + .001;

			const float fW = fDepTest * fDotTest;

			vRGB.xyz += vDiff_RGB.xyz * fW;
			vALD += vDiff_ALD * fW;
			MaterialAttribsCommon gbuffer = DecodeGBufferChannels(tc1);
			fAverSmoothness += gbuffer.Smoothness * fW;
			vRGB.w += fW;

#if %_RT_REVERSE_DEPTH
			if (IsDiffuseMode())
			{
				// upscale svo sun shadow
				float4 vShadowSvo = tex2DlodPC(shadowFromSvoMinMax, tc);   // shadowMin, shadowMax, depthMin, depthMax
				float lerpShadow = saturate((fDepthC - vShadowSvo[2]) / max(vShadowSvo[3] - vShadowSvo[2], 0.0001f));
				float shadowSvoLerped = lerp(vShadowSvo[0], vShadowSvo[1], lerpShadow);
				fShadowSvoDepthMin = min(fShadowSvoDepthMin, vShadowSvo[2]);
				fShadowSvoDepthMax = max(fShadowSvoDepthMax, vShadowSvo[3]);
				fShadowSvoFin += shadowSvoLerped * fW;
			}
#endif
		}

	if (vRGB.w)
	{
		vRGB.xyz /= vRGB.w;
		vALD /= vRGB.w;
		fAverSmoothness /= vRGB.w;
		fShadowSvoFin /= vRGB.w;
	}

	// copmute lighting
	float fDirIntens = max(0, length(vALD.xyz)) * saturate(1 - fTransmittanceY);

	MaterialAttribsCommon gbuffer = DecodeGBufferChannels(IN.baseTC.xy);
	half power = IsDiffuseMode() ? 1.f : exp2(12.h * gbuffer.Smoothness + 0.5h);

	float3 vH = IsDiffuseMode() ? normalize(vALD.xyz) : normalize(-normalize(IN.CamVec.xyz) + normalize(vALD.xyz));

	float NdotH = dot(vNor0, vH);
	float fIntensity = fDirIntens * pow(saturate(NdotH), power) + max(0, vALD.w - fDirIntens);

	if (IsDiffuseMode())
	{
		OUT.Diffuse.xyz = vRGB * fIntensity;
	}
	else
	{
		float so = gbuffer.Smoothness;
		// Fresnel smoothness
		//		gbuffer.Smoothness = lerp(gbuffer.Smoothness, 1, pow(1 - dot(-normalize(IN.CamVec.xyz), vNor0), 2));

		//OUT.Diffuse.xyz = vRGB * vALD.w;

		OUT.Diffuse.xyz = lerp(vRGB * fIntensity, vRGB * vALD.w, pow(gbuffer.Smoothness, 2));

		float4 vFinalDiffuse = tex2DlodPC(sceneDiffuseFin, float4(IN.baseTC.xy, 0, 0)) / SvoParamsDiffuse.w * SvoParamsSpecular.w;

		OUT.Diffuse = lerp(vFinalDiffuse, OUT.Diffuse, saturate(pow(gbuffer.Smoothness * 3 - .75, 1)));

		// Fresnel amplify
		//OUT.Diffuse.xyz *= 1 + pow(saturate(1 - so), 4) * pow(saturate(1 - dot(-normalize(IN.CamVec.xyz), vNor0)), 7) * 2;

		OUT.Diffuse.a = 1;
	}

#if !%_RT_SAMPLE5 && !%_RT_LIGHTVOLUME1
	if (SvoParamsCommon.z > 0)
		OUT.Diffuse.xyz += SvoParamsCommon.z * vSkyColorTop.z;
	else
		OUT.Diffuse.xyz += -SvoParamsCommon.z * vSkyColorTop.z * 0.15f;
#endif

	OUT.Diffuse.w = fDepthC;

	float3 vReprojTC = Reproject(IN.baseTC.xy, fDepthC, SVO_ReprojectionMatrix);

	float4 valPrev = tex2DlodPC(sceneFinOutPrev, float4(vReprojTC.xy, 0, 0));

	float fBlend = GetBlendMin(vReprojTC.xy, IN.baseTC.xy, fAverSmoothness, fDepthC, valPrev.w);

	// detect high contrast difference
	float fDiff = dot(abs(1.f - OUT.Diffuse.xyz / valPrev.xyz), half3(0.33f, 0.33f, 0.33f));
	if (fDiff > 0)
		fBlend += (1.f - fBlend) * saturate(fDiff * 3);

	OUT.Diffuse = clamp(lerp(valPrev, OUT.Diffuse, fBlend), 0, 8);

#if %_RT_REVERSE_DEPTH
	if (IsDiffuseMode())
	{
		if (fShadowSvoDepthMin / fShadowSvoDepthMax > VOX_DEPTH_RANGE_THRESHOLD)
		{
			float4 vShadowSvoFiltered = tex2DlodLC(shadowFromSvoMinMax, IN.baseTC.xy);
			fShadowSvoFin = (vShadowSvoFiltered[0] + vShadowSvoFiltered[1]) * 0.5;
		}
		float4 shadowSvoFinPrev = tex2DlodPC(shadowFromSvoFinPrev, float4(vReprojTC.xy, 0, 0));
		OUT.Specular = clamp(lerp(shadowSvoFinPrev, fShadowSvoFin, fBlend), 0, 1);
	}
#endif

#if %_RT_PROJECTION_MULTI_RES
	{
		// simple specular
		half power = exp2(7.h * gbuffer.Smoothness + 0.5f);
		float3 vH = normalize(-normalize(IN.CamVec.xyz) + normalize(vALD.xyz));
		float NdotH = dot(vNor0, vH);	
		float intensity = fDirIntens * pow(saturate(NdotH), power) * (1 + max(0, vALD.w - fDirIntens) / 2) + max(0, vALD.w - fDirIntens)/2;
		OUT.Diffuse1.xyz = vRGB * intensity;

	#if !%_RT_SAMPLE5 && !%_RT_LIGHTVOLUME1
		if (SvoParamsCommon.z > 0)
			OUT.Diffuse1.xyz += SvoParamsCommon.z * vSkyColorTop.z;
		else
			OUT.Diffuse1.xyz += -SvoParamsCommon.z * vSkyColorTop.z * 0.15f;
	#endif

		OUT.Diffuse1.xyz *= SvoParamsSpecular.w;
		OUT.Diffuse1.w = fDepthC;
	}
#endif

	return OUT;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Rendering techniques

technique SvoDebugDraw
{
	pass p0
	{
		VertexShader = VoxelRayTraceVS() GeneralVS;
		PixelShader = SvoDebugDrawPS() GeneralPS;
		CullMode = None;
	}
}

technique ConeTracePass
{
	pass p0
	{
		VertexShader = RenderLightingCommonVS();
		PixelShader = ConeTracePS();
		CullMode = None;
	}
}

#ifdef SVO_LMAPS

technique ConeTracePS_NID
{
	pass p0
	{
		VertexShader = VoxelRayTraceVS_GS();
		GeometryShader = BoxGenGS_GS();
		PixelShader = ConeTracePS_NID_GS();

		ZEnable = true;
		ZWriteEnable = true;
		CullMode = Front;
	}
}

#endif

technique RenderAtmosphere
{
	pass p0
	{
		VertexShader = RenderLightingCommonVS();
		PixelShader = RenderAtmospherePS();
		CullMode = None;
	}
}

technique TraceSunShadows
{
	pass p0
	{
		VertexShader = RenderLightingCommonVS();
		PixelShader = TraceSunShadowsPS();
		CullMode = None;
	}
}

technique DemosaicPass
{
	pass p0
	{
		VertexShader = RenderLightingCommonVS();
		PixelShader = DemosaicPS();
		CullMode = None;
	}
}

technique UpScalePass
{
	pass p0
	{
		VertexShader = RenderLightingCommonVS();
		PixelShader = UpScalePS();
		CullMode = None;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Compute techniques

technique
  ComputeClearBricks {
	pass p0 {
		ComputeShader =
		  ComputeClearBricks();
	}
}

technique
  ComputeInjectAtmosphere {
	pass p0 {
		ComputeShader =
		  ComputeInjectAtmosphere();
	}
}

technique
  ComputeDirectStaticLighting {
	pass p0 {
		ComputeShader =
		  ComputeDirectStaticLighting();
	}
}

technique
  ComputeDirectDynamicLighting {
	pass p0 {
		ComputeShader =
		  ComputeDirectDynamicLighting();
	}
}

technique
  ComputePropagateLighting {
	pass p0 {
		ComputeShader =
		  ComputePropagateLighting();
	}
}

#endif // FEATURE_SVO_GI
