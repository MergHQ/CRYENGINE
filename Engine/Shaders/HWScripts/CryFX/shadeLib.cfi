// Copyright 2001-2019 Crytek GmbH / Crytek Group. All rights reserved.

// Common Samplers //////////////////////
#ifndef SHADELIB_USE_CUSTOM_TEXTURES
DIFFUSEMAP
NORMALMAP
HEIGHTMAP
SPECULARMAP
SMOOTHNESSMAP
DETAILMAP
SCENEDEPTHMAP



// Deferred Shading Samplers /////////////

SCENE_NORMALS_MAP
SCENE_NORMALS_BENT
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

Texture2DMS sceneDepthTexMS       : TS_ZTargetMS          < float4; >;

half4 GetDecodedSceneDepthMS( float2 baseTC, int NumSamples, int nCurrSample ) 
{
#if %_RT_MSAA_QUALITY || %_RT_MSAA_QUALITY1
	int3 vPixCoord = int3( baseTC * PS_ScreenSize.xy, 0);  
	return GetLinearDepth(sceneDepthTexMS.Load(vPixCoord, nCurrSample).x, true);
#else
	return 0;
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////
struct AreaLightShadingAttribs
{
    float4x4 transform;
    float3 position;
    float3 lightPos;
    uint lightArrayIdx;
};

struct ForwardShadingAttribs
{
	float2  screenUV;
	float3  worldPos;
	float3  normal;
	float3  normalSpecProbe;
	float3  reflectance;
	float3  albedo;
	float   smoothness;
	
	CustomForwardShadingAttribs  custom;
    AreaLightShadingAttribs areaAttribs;
};

struct STiledLightShadeInfo
{
	uint      lightType;
	uint      resIndex;
	uint      shadowMaskIndex;
	uint      stencilID;
	float4    posRad;
	float2    attenuationParams;
	float2    shadowParams;
	float4    color;
	float4x4  projectorMatrix;
	float4x4  shadowMatrix;
};
struct ForwardLightParams
{
	int     type;
	float3  lightVec;
	float3  illuminance;
};

#define TILED_SHADING_SPECPROBE_MAXMIP  6

////////////////////////////////////////////////////////////////////////////////////////////////////

float GetDissolveThreshold5(int2 sc)
{
	// 4 transparency levels for a 2x2 quad. We're using dot/abs instead, since rsx doens't support array indexing.
	return abs(dot(half4(0.0h, 0.76h, 0.5h,-1.0h), sc.xxyy % 2));
}

float GetDissolveThreshold9(int2 sc)
{
	float tm[2][4] =
	{
		{  0.0f / 8,  4.0f / 8,  2.0f / 8,  6.0f / 8 },
		{  3.0f / 8,  7.0f / 8,  1.0f / 8,  5.0f / 8 }
	};

	return tm[sc.y & 1][sc.x & 3];
}

float GetDissolveThreshold17(int2 sc)
{
	float tm[4][4] =
	{
		{  0.0f / 16,  12.0f / 16,   3.0f / 16,  15.0f / 16 },
		{  8.0f / 16,   4.0f / 16,  11.0f / 16,   7.0f / 16 },
		{  2.0f / 16,  14.0f / 16,   1.0f / 16,  13.0f / 16 },
		{ 10.0f / 16,   6.0f / 16,   9.0f / 16,   5.0f / 16 }
	};

	return tm[sc.y & 3][sc.x & 3];
}

float GetDissolveThreshold33(int2 sc)
{
	float tm[4][8] =
	{
		{  0.0f / 32,  16.0f / 32,   8.0f / 32,  24.0f / 32,   2.0f / 32,  18.0f / 32,  10.0f / 32,  26.0f / 32 },
		{ 12.0f / 32,  28.0f / 32,   4.0f / 32,  20.0f / 32,  14.0f / 32,  30.0f / 32,   6.0f / 32,  22.0f / 32 },
		{  3.0f / 32,  19.0f / 32,  11.0f / 32,  27.0f / 32,   1.0f / 32,  17.0f / 32,   9.0f / 32,  25.0f / 32 },
		{ 15.0f / 32,  31.0f / 32,   7.0f / 32,  23.0f / 32,  13.0f / 32,  29.0f / 32,   5.0f / 32,  21.0f / 32 }
	};

	return tm[sc.y & 3][sc.x & 7];
}

float TestDissolve(float fDissolve, int2 sc, int levels = 17)
{
#if %_RT_DISSOLVE
	float fThreshold = 0;
	if (levels <= 5)
		fThreshold = GetDissolveThreshold5(sc);
	else if (levels <= 9)
		fThreshold = GetDissolveThreshold9(sc);
	else if (levels <= 17)
		fThreshold = GetDissolveThreshold17(sc);
	else if (levels <= 33)
		fThreshold = GetDissolveThreshold33(sc);
	else
		fThreshold = 0;

	return (fDissolve > 0 ? 1 : -1) * (fThreshold - abs(fDissolve));
#else
	return 0.0f;
#endif
}

void ApplyDissolve(float fDissolve, int2 sc, int levels = 17)
{
#if %_RT_DISSOLVE
	clip(TestDissolve(fDissolve, sc, levels));
#endif
}

//////////////////////////////// Common shading utilities ////////////////

// assumes 0 is min
half smoothstep_opt(in half maxi, in half x)
{
  x = saturate( x / maxi );
  return  x * x  * (3.0 - 2.0 * x);
}

half GlossToSpecExp255(in half gloss)
{
	return gloss * 255.h;
}

half GetFresnel(half NdotI, half bias, half power)
{
  half facing = (1.0 - NdotI);
  return saturate(bias + (1-bias)*pow(facing, power));
}

half3 GetEnvmapFresnel(half3 specCol0, half gloss, half fNdotE)
{
	const half3 specCol90 = half3( 1, 1, 1 );

	// Empirical approximation to the reduced gain at grazing angles for rough materials
	return lerp( specCol0, specCol90, pow( 1 - saturate( fNdotE ), 5 ) / (40 - 39 * gloss) );
}

half GetAttenuation(half3 L, half fInvRadius, bool bUserFalloff = false, half fFalloffMax = 1.0h)
{
  half3 vDist = L * fInvRadius;
  half fFallOff = saturate(1 + dot(vDist, -vDist));

	if( bUserFalloff )
		fFallOff = smoothstep_opt( fFalloffMax, fFallOff);

  return fFallOff;
}

half GetPhysicalLightAttenuation(half fDist, half fInvRadius, half fAttenuationBulbSize)
{
	const half radius = 1 / fInvRadius;
	half d = fDist;

	// Fadeout last 20% of radius
	half fadeoutFactor = saturate((radius - d) * (fInvRadius / 0.2h));

	// Light attenuation model: 1 / (1 + d/lightsize)^2
	d = max(d - fAttenuationBulbSize, 0);
	half denom = 1 + d / fAttenuationBulbSize;
	half fAttenuation = fadeoutFactor * fadeoutFactor / (denom * denom);

	return fAttenuation;
}

half GetSpotAttenuation(half fPdotL, half fCosAngle, half fRadius)
{
	// Compute cosine of spot direction and light.
	half fSpotFalloff = fCosAngle / (fPdotL+1e-6); // 1 alu
	
	// Apply planar falloff and computed spot falloff.
	half fFallOff = 1.0h - pow(saturate(fSpotFalloff), fRadius); //  4 alu

	return fFallOff;
}

float3 MapCubeToSphere(float3 pos)
{
	float3 pos2 = pos.xyz * pos.xyz;
	return pos * sqrt(1 - rcp(2) * (pos2.yzx + pos2.zxy) + rcp(3) * (pos2.yzx * pos2.zxy));
}

half3 ShiftVector(half3 V, half3 N, half shiftAmount)
{
  return normalize(V + shiftAmount * N);
  // 3 alu, 1 mad
}

// optimized shift vector - skips normalization - use only when vector lenght not relevant
half3 ShiftVectorOpt(half3 V, half3 N, half shiftAmount)
{
  return (V + shiftAmount * N);
  // 1 mad
}

//////////////////////////////// Common HDR encoding/decoding ////////////////////////////////

#define MAX_FLOAT						128.h

#define fHDR_EXP_BASE_1_04	1.04h
#define fHDR_EXP_BASE_1_06	1.06h
#define fHDR_EXP_OFFSET			128.h

// Using RGBK format (multiplier in alpha - filtering should work fine)
// quality: good	
half4 EncodeRGBK(in half4 Color, const half fMultiplier, bool bUsePPP = false)
{
	const half4 cScale = half4(half3(1.h, 1.h, 1.h) / fMultiplier, 1.h / 255.0);
	half fMax = saturate(dot(half4(Color.rgb, 1.h), cScale));   // 1 alu

	Color.a = ceil(fMax * 255.h) / 255.h;                       // 3 alu

	Color.xyz /= Color.a * fMultiplier;                         // 2alu

  if( bUsePPP )
  {
	//Color *= rsqrt( Color ); // for best quality

	Color.a = sqrt( Color.a ); // encode just multiplier for performance reasons
  }

  return Color;
}

void EncodeRGBKPair(inout half4 Color0, inout half4 Color1, const half fMultiplier, bool bUsePPP = false)
{
  half fMax0 = saturate(dot(Color0.rgb, 1.h / fMultiplier));    // 1 alu
  half fMax1 = saturate(dot(Color1.rgb, 1.h / fMultiplier));    // 1 alu

  Color0.a = ceil(fMax0 * 255.h) / 255.h;                       // 3 alu
  Color1.a = ceil(fMax1 * 255.h) / 255.h;                       // 3 alu

  Color0.xyz /= Color0.a * fMultiplier;                         // 2alu
  Color1.xyz /= Color1.a * fMultiplier;                         // 2alu
  
  if( bUsePPP )
  {
	  //Color0 *= rsqrt( Color0 ); // for best quality
	  //Color0 *= rsqrt( Color0 ); 

		Color0.a = sqrt( Color0.a ); // encode just multiplier for performance reasons
		Color1.a = sqrt( Color1.a );

  }
}

half4 DecodeRGBK(in half4 Color, const half fMultiplier, bool bUsePPP= false)
{
  if( bUsePPP )
  {
	 //Color.rgb *= Color.rgb * (Color.a * Color.a) * fMultiplier;

	Color.rgb *= (Color.a * Color.a) * fMultiplier;
  }
  else
    Color.rgb *= Color.a * fMultiplier;

  return Color;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// These functions are used for each and every manipulation with compressed HDR buffer 

#define SCENE_HDR_MULTIPLIER 32.h

half4 EncodeHDRBuffer( in half4 color )
{
	return color;
}

void EncodeLightBufferPair( inout half4 diffuse, inout half4 specular )
{
}

half4 DecodeHDRBuffer( in half4 rgbk )
{
	return rgbk;
}

half4 EncodeLightBuffer( in half4 color )
{
	return color;
}

half4 Decode7E3F(in half4 color)
{
	// Reference	
	//vColor.rgb *= 8.0f;  // Shift performed in resolve and tex bias
	//float3 e = floor( vColor.rgb );
	//float3 m = frac( vColor.rgb );
	//vColor.rgb  = (e == 0.0f) ? 2*m/8 : (1+m)/8 * pow(2,e);  

	float3 me = color.xyz;
	float3 e  = floor(me);
	float3 m  = frac(me);	
		
	color.xyz = (e == 0.0f) ? 2.0f * m : (1.0f+m) * exp2(e);
	color.xyz *= 0.125f;

	return color;
}

half4 DecodeLightBuffer( in half4 color , bool bRangeAdaptHDR = false)
{
	return color;
}

//////////////////////////////// Common Brdfs ////////////////////////////////

half SmoothnessToRoughness(half smoothness)
{
	return (1.0f - smoothness) * (1.0f - smoothness);
}

half RoughnessToSmoothness(half roughness)
{
	return 1.0f - sqrt(roughness);
}

//////////////////////////////// Phong model /////////////////////////////////////
// - Phong model has good properties for plastic and some metallic surfaces. 
// - Good for general use. Very cheap.

#define ONE_OVER_PI 0.31831h
#define ONE_OVER_TWO_PI 0.159155h

// Optimized phong, use if mirrowed reflection vector pre-computed
half Phong(half3 R, half3 L, half Exp)
{	
	half fNormFactor = Exp * ONE_OVER_TWO_PI + ONE_OVER_TWO_PI;		// 1 ALU
  return fNormFactor *  pow(saturate(dot(L, R)), Exp);					// 4 ALU
	// 5 ALU
}

half Phong(half3 N, half3 V, half3 L, half Exp)
{
  half3 R = reflect(-V, N);	// 3 ALU
  return Phong(R, L, Exp);	// 5 ALU
  // 8 ALU
}

//////////////////////////////// Blinn BRDF model /////////////////////////////////////
// - Blinn model has good properties for plastic and some metallic surfaces. 
// - Good for general use. Very cheap.
// *NOTE* We should also multiply by the clamped N.L factor. However this is 
// delegated to the shader part for performance reasons

half BlinnBRDF(half3 N, half3 V, half3 L, half Gloss)
{
  half3 H = normalize(V + L);
	
	// Compute perceptually linear exponent in range 2-2048
	half power = exp2( 10.h * Gloss + 1.h );
	
	half fNormFactor = power * (1.0/8.0) + (2.0/8.0);
	return fNormFactor * pow( saturate( dot( N, H ) ), power );
}

half3 SpecularBRDF(half3 N, half3 V, half3 L, half m, half3 f0, half NormalizationFactor)
{
	half m2 = m * m;
	half3 H = normalize( V + L );

	// GGX NDF
	half NdotH = saturate( dot( N, H ) );
	half spec = (NdotH * m2 - NdotH) * NdotH + 1;
	spec = m2 / (spec * spec) * NormalizationFactor;
	
	// Correlated Smith Visibility Term (including Cook-Torrance denominator)
	half NdotL = saturate( dot( N, L ) );
	half NdotV = abs( dot( N, V ) ) + 1e-5h;
	half Gv = NdotL * sqrt( (-NdotV * m2 + NdotV) * NdotV + m2 );
	half Gl = NdotV * sqrt( (-NdotL * m2 + NdotL) * NdotL + m2 );
	spec *= 0.5h / (Gv + Gl);
		
	// Fresnel (Schlick approximation)
	half f90 = saturate( dot( f0, 0.33333h ) / 0.02h );  // Assume micro-occlusion when reflectance is below 2%
	half3 fresnel = lerp( f0, f90, pow( 1 - saturate( dot( L, H ) ), 5 ) );

	return fresnel * spec;
}

half3 SpecularBRDF(half3 N, half3 V, half3 L, half Gloss, half3 SpecCol)
{
	half m = max(SmoothnessToRoughness( Gloss ), 0.001);  // Prevent highlights from getting too tiny without area lights
	return SpecularBRDF(N, V, L, m, SpecCol, 1.0f);
}

////////////////////////////////////////////////////////////////////////////
// Anisotropic Kajiya Kay model

half KajiyaKayAnisotropic(half3 T, half3 H, half Exp)
{	
	half TdotH = dot( T, H );
	half fSpec = sqrt( max( 1.0 - TdotH * TdotH, 0.01) );
  
	return pow( fSpec, Exp );
}

// Constants
static const float LTC_LUT_SIZE = 64.0f;
static const float LTC_LUT_SCALE = (LTC_LUT_SIZE - 1.0f) / LTC_LUT_SIZE;
static const float LTC_LUT_BIAS = 0.5f / LTC_LUT_SIZE;

#define AREALIGHT_TYPE_RECTANGLE 1
#define AREALIGHT_TYPE_DISK 2

// Precomputed textures
Texture2D<float4> LTCTex_1 : register(t48); 
Texture2D<float4> LTCTex_2 : register(t49); 

// Utility functions
float3 IntegrateEdgeVec(float3 v1, float3 v2)
{
    float x = dot(v1, v2);
    float y = abs(x);

    float a = 0.8543985 + (0.4965155 + 0.0145206 * y) * y;
    float b = 3.4175940 + (4.1616724 + y) * y;
    float v = a / b;

    float theta_sintheta = (x > 0.0) ? v : 0.5 * rsqrt(max(1.0 - x * x, 1e-7)) - v;

    return cross(v1, v2) * theta_sintheta;
}
float IntegrateEdge(float3 v1, float3 v2)
{
    return IntegrateEdgeVec(v1, v2).z;
}
float3 SolveCubic(float4 Coefficient)
{
    // Normalize the polynomial
    Coefficient.xyz /= Coefficient.w;
    // Divide middle coefficients by three
    Coefficient.yz /= 3.0f;

    float A = Coefficient.w;
    float B = Coefficient.z;
    float C = Coefficient.y;
    float D = Coefficient.x;

    // Compute the Hessian and the discriminant
    float3 Delta = float3(-Coefficient.z * Coefficient.z + Coefficient.y,
                          -Coefficient.y * Coefficient.z + Coefficient.x,
                          dot(float2(Coefficient.z, -Coefficient.y), Coefficient.xy));

    float Discriminant = dot(float2(4.0f * Delta.x, -Delta.y), Delta.zy);

    float3 RootsA, RootsD;

    float2 xlc, xsc;

    // Algorithm A
    {
        float A_a = 1.0f;
        float C_a = Delta.x;
        float D_a = -2.0f * B * Delta.x + Delta.y;

        // Take the cubic root of a normalized complex number
        float Theta = atan2(sqrt(Discriminant), -D_a) / 3.0f;

        float x_1a = 2.0f * sqrt(-C_a) * cos(Theta);
        float x_3a = 2.0f * sqrt(-C_a) * cos(Theta + (2.0f / 3.0f) * PI);

        float xl;
        if ((x_1a + x_3a) > 2.0f * B)
            xl = x_1a;
        else
            xl = x_3a;

        xlc = float2(xl - B, A);
    }

    // Algorithm D
    {
        float A_d = D;
        float C_d = Delta.z;
        float D_d = -D * Delta.y + 2.0f * C * Delta.z;

        // Take the cubic root of a normalized complex number
        float Theta = atan2(D * sqrt(Discriminant), -D_d) / 3.0f;

        float x_1d = 2.0f * sqrt(-C_d) * cos(Theta);
        float x_3d = 2.0f * sqrt(-C_d) * cos(Theta + (2.0f / 3.0f) * PI);

        float xs;
        if (x_1d + x_3d < 2.0f * C)
            xs = x_1d;
        else
            xs = x_3d;

        xsc = float2(-D, xs + C);
    }

    float E = xlc.y * xsc.y;
    float F = -xlc.x * xsc.y - xlc.y * xsc.x;
    float G = xlc.x * xsc.x;

    float2 xmc = float2(C * F - B * G, -B * F + C * E);

    float3 Root = float3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);

    if (Root.x < Root.y && Root.x < Root.z)
        Root.xyz = Root.yxz;
    else if (Root.z < Root.x && Root.z < Root.y)
        Root.xyz = Root.xzy;

    return Root;
}
float3 FetchDiffuseFilteredTexture(Texture2DArray<float4> texArray, float lightArrayIdx, float3 p1_, float3 p2_, float3 p3_, float3 p4_, bool useMips)
{
    // area light plane basis
    float3 V1 = p2_ - p1_;
    float3 V2 = p4_ - p1_;
    float3 planeOrtho = (cross(V1, V2));
    float planeAreaSquared = dot(planeOrtho, planeOrtho);
    float planeDistxPlaneArea = dot(planeOrtho, p1_);

    // orthonormal projection of (0,0,0) in area light space
    float3 P = planeDistxPlaneArea * planeOrtho / planeAreaSquared - p1_;

    // find tex coords of P
    float dot_V1_V2 = dot(V1, V2);
    float inv_dot_V1_V1 = 1.0f / dot(V1, V1);
    float3 V2_ = V2 - V1 * dot_V1_V2 * inv_dot_V1_V1;
    float2 Puv;
    Puv.y = dot(V2_, P) / dot(V2_, V2_);
    Puv.x = dot(V1, P) * inv_dot_V1_V1 - dot_V1_V2 * inv_dot_V1_V1 * Puv.y;

    // LOD
    float d = 0;
	if(useMips)
    {
        d = abs(planeDistxPlaneArea) / pow(planeAreaSquared, 0.75f);
    }	
    return texArray.SampleLevel(SampStateTrilinearClamp, float3(float2(0.125f, 0.125f) + 0.75f * Puv, lightArrayIdx), log(2048.0f * d) / log(3.0f)).r;
}

float2 LTC_Evaluate(float3 N, float3 V, float Gloss, inout float3x3 matILT, inout float3x3 matIdentity,
                    inout float3 T1, inout float3 T2)
{
    // Fetch precomputed data (InverseLinearTransformMatrix / GGX normalization)
    float m = max(SmoothnessToRoughness(Gloss), 0.02f);
    float NdotV = saturate(dot(N, V));
    float2 texUV = float2(m, sqrt(1.0f - NdotV));
    texUV = texUV * LTC_LUT_SCALE + LTC_LUT_BIAS;
    float4 t1 = LTCTex_1.SampleLevel(SampStateTrilinearClamp, texUV, 0);
    float4 t2 = LTCTex_2.SampleLevel(SampStateTrilinearClamp, texUV, 0);

    matILT = float3x3(t1.x, 0, t1.z,
		                 0, 1, 0,
		              t1.y, 0, t1.w);

    matIdentity = float3x3(1, 0, 0,
                           0, 1, 0,
                           0, 0, 1);


    // Construct orthonormal basis around N
    T1 = normalize(V - N * NdotV);
    T2 = cross(N, T1);

    return float2(t2.x, t2.y);
}

float3 LTC_Rectangle(float3 N, float3 P, float3x3 mat, float3 points[4],
                     float3 T1, float3 T2, float lightArrayIdx, bool twoSided, bool behind, 
                     bool textured, Texture2DArray<float4> texArray)
{
    // Rotate area light in (T1, T2, N) basis
    mat = mul(mat, float3x3(T1, T2, N));

    // Polygon
    float3 L[4];
    L[0] = mul(mat, points[0] - P);
    L[1] = mul(mat, points[1] - P);
    L[2] = mul(mat, points[2] - P);
    L[3] = mul(mat, points[3] - P);

    float3 texturedLight = 1.0f;
    if(textured)
    {
        texturedLight = FetchDiffuseFilteredTexture(texArray, lightArrayIdx, L[0], L[1], L[2], L[3], true);
    }    

    // Integrate
    float sum = 0.0f;
    L[0] = normalize(L[0]);
    L[1] = normalize(L[1]);
    L[2] = normalize(L[2]);
    L[3] = normalize(L[3]);
        
    float3 vsum = 0.0f;       
    vsum += IntegrateEdgeVec(L[0], L[1]);
    vsum += IntegrateEdgeVec(L[1], L[2]);
    vsum += IntegrateEdgeVec(L[2], L[3]);
    vsum += IntegrateEdgeVec(L[3], L[0]);

    float len = length(vsum);
    float z = (behind ? -vsum.z : vsum.z) / len;
    float2 uv = float2(z * 0.5f + 0.5f, len);
    uv = uv * LTC_LUT_SCALE + LTC_LUT_BIAS;
    float scale = LTCTex_2.SampleLevel(SampStateTrilinearClamp, uv, 0).w;
    sum = len * scale;

    float3 output = float3(sum, sum, sum);
    output *= texturedLight;

    return output;
}

float3 LTC_Disk(float3 N, float3 P, float3x3 mat, float3 points[4],
                float3 T1, float3 T2, bool twoSided, bool behind)
{
    // rotate area light in (T1, T2, N) basis
    float3x3 R = float3x3(T1, T2, N);

    // polygon (allocate vertices for clipping)
    float3 L_[3];
    L_[0] = mul(R, points[0] - P);
    L_[1] = mul(R, points[1] - P);
    L_[2] = mul(R, points[2] - P);

    float3 sum = 0;

    // init ellipse
    float3 C =  0.5f * (L_[0] + L_[2]);
    float3 V1 = 0.5f * (L_[1] - L_[2]);
    float3 V2 = 0.5f * (L_[1] - L_[0]);

    C = mul(mat, C);
    V1 = mul(mat, V1);
    V2 = mul(mat, V2);

    float earlyOut = dot(cross(V1, V2), C);
    if (!twoSided && earlyOut < 1e-6)
        return 0.0f;
    else if (twoSided && earlyOut < 1e-6 && earlyOut > -1e-6)
        return 0.0f;
    
    // compute eigenvectors of ellipse
    float a = 0;
    float b = 0;
  
    float d11 = dot(V1, V1);
    float d22 = dot(V2, V2);
    float d12 = dot(V1, V2);

    if (abs(d12) / sqrt(d11 * d22) > 0.001f)
    {
        float tr = d11 + d22;
        float det = -d12 * d12 + d11 * d22;

        // use sqrt matrix to solve for eigenvalues
        det = sqrt(det);
        float u = 0.5f * sqrt(tr - 2.0f * det);
        float v = 0.5f * sqrt(tr + 2.0f * det);
        float e_max = (u + v);
        float e_min = (u - v);
        float e_max2 = e_max * e_max; // e_max²     
        float e_min2 = e_min * e_min; // e_min²

        float3 V1_, V2_;

        if (d11 > d22)
        {
            V1_ = d12 * V1 + (e_max2 - d11) * V2;
            V2_ = d12 * V1 + (e_min2 - d11) * V2;
        }
        else
        {
            V1_ = d12 * V2 + (e_max2 - d22) * V1;
            V2_ = d12 * V2 + (e_min2 - d22) * V1;
        }

        a = 1.0f / e_max2;
        b = 1.0f / e_min2;
        V1 = normalize(V1_);
        V2 = normalize(V2_);
    }
    else
    {
        a = 1.0f / dot(V1, V1);
        b = 1.0f / dot(V2, V2);
        V1 *= sqrt(a);
        V2 *= sqrt(b);
    }
   
    float3 V3 = cross(V1, V2);
    
    if (dot(C, V3) < 0.0f)
        V3 *= -1.0f;  
    
    float L = dot(V3, C);
    float x0 = dot(V1, C) / L;
    float y0 = dot(V2, C) / L;

    a *= (L * L);
    b *= (L * L);

    float c0 = a * b;
    float c1 = a * b * (1.0f + x0 * x0 + y0 * y0) - a - b;
    float c2 = 1.0f - a * (1.0f + x0 * x0) - b * (1.0f + y0 * y0);
    float c3 = 1.0f;
   
    float3 roots = SolveCubic(float4(c0, c1, c2, c3));

    float e1 = roots.x;
    float e2 = roots.y;
    float e3 = roots.z;

    float3 avgDir = float3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0f);
    float3x3 rotate = transpose(float3x3(V1, V2, V3));

    avgDir = mul(rotate, avgDir);
    avgDir = normalize(avgDir);

    float L1 = sqrt(-e2 / e3);
    float L2 = sqrt(-e2 / e1);
    float formFactor = L1 * L2 * rsqrt((1.0f + L1 * L1) * (1.0f + L2 * L2));

    // use tabulated horizon-clipped sphere
    float2 uv = float2(avgDir.z * 0.5f + 0.5f, formFactor);
    uv = uv * LTC_LUT_SCALE + LTC_LUT_BIAS;
    float scale = LTCTex_2.SampleLevel(SampStateTrilinearClamp, uv, 0).w;
    sum = formFactor * scale;
    float3 output = sum;

    return output;
}

void AreaLightLTC_GGX(float3 N, float3 V, float Gloss, float3 SpecCol, float3 position, float3 lightPos, 
                      float lightArrayIdx, float4x4 lightParamMatrix, Texture2DArray<float4> texArray,
                      inout float3 outDiffuse, inout float3 outSpecular)
{
    // Define Light shape
    float3 points[4];
	points[0] = float3(lightParamMatrix[0][0], lightParamMatrix[0][1], lightParamMatrix[0][2]);
    points[1] = float3(lightParamMatrix[1][0], lightParamMatrix[1][1], lightParamMatrix[1][2]);
    points[2] = float3(lightParamMatrix[2][0], lightParamMatrix[2][1], lightParamMatrix[2][2]);
    points[3] = float3(lightParamMatrix[3][0], lightParamMatrix[3][1], lightParamMatrix[3][2]);
               
    uint shape = lightParamMatrix[0][3];
    bool twoSided = lightParamMatrix[1][3];
    bool textured = lightParamMatrix[2][3];

	// Early out
    float3 center = float3((points[0].x + points[1].x) / 2, points[0].y, (points[0].z + points[2].z) / 2) - position;
    float3 lightNormal = cross(points[1] - points[0], points[3] - points[0]);
    bool behindLight = dot(points[0] - position, lightNormal) < 0.0f;  

    if ((behindLight && !twoSided))
    {
        outDiffuse = 0;
        outSpecular = 0;
        return;
    }
                                 
    // Retrieve precomputed data
    float3x3 matILT, matIdentity;
    float3 T1, T2;
    float2 F_G = LTC_Evaluate(N, V, Gloss, matILT, matIdentity, T1, T2);

    // Evaluate
    if (shape == AREALIGHT_TYPE_RECTANGLE)
    {
        outDiffuse = LTC_Rectangle(N, position, matIdentity, points, T1, T2, lightArrayIdx, twoSided, behindLight, textured, texArray);
        outSpecular = LTC_Rectangle(N, position, matILT, points, T1, T2, lightArrayIdx, twoSided, behindLight, textured, texArray);
    }
    else if (shape == AREALIGHT_TYPE_DISK)
    {
        outDiffuse = LTC_Disk(N, position, matIdentity, points, T1, T2, twoSided, behindLight);
        outSpecular = LTC_Disk(N, position, matILT, points, T1, T2, twoSided, behindLight);
    }

	// Apply fresnel and shadowing term + cosine factor
    float cosTheta_i = saturate(dot(center, N));
    outSpecular *= cosTheta_i * SpecCol * F_G.x + (1.0 - SpecCol) * F_G.y;
}

// Diffuse BRDFs
half3 ComputeNearestLightOnRectangle(half3 vLightPoint, float4x4 mAreaLightMatr)
{
	// Calculate light space plane.
	half3 vLightDir = dot(mAreaLightMatr[0].xyz, vLightPoint.xyz) * mAreaLightMatr[0].xyz - vLightPoint.xyz;

	// Calculate the nearest point.
	half2 vSurfArea = float2(dot(vLightDir.xyz, mAreaLightMatr[1].xyz), dot(vLightDir.xyz, mAreaLightMatr[2].xyz));
	half2 vSurfAreaClamp = clamp(vSurfArea.xy, -mAreaLightMatr[3].xy, mAreaLightMatr[3].xy); // 1 alu
	half3 vNearestPoint = mAreaLightMatr[1].xyz * vSurfAreaClamp.x + (mAreaLightMatr[2].xyz * vSurfAreaClamp.y);

	return vLightPoint.xyz + vNearestPoint.xyz;
}

half OrenNayarBRDF(half3 N, half3 V, half3 L, half Gloss, half NdotL)
{
	half m = SmoothnessToRoughness(Gloss);
	m *= m * m;  // Map GGX to Oren-Nayar roughness (purely empirical remapping)
	
	// Approximation of the full quality Oren-Nayar model
	half s = dot(L, V) - dot(N, L) * dot(N, V);
	half t = s <= 0 ? 1 : max(max(dot(N, L), dot(N, V)), 1e-6);
	half A = 1.0h / (1.0h + (0.5h - 2.0h / (3.0h * PI)) * m);
	half B = m * A;
	
	return NdotL * max(A + B * (s / t), 0);
}

half Pow5(half v)
{
	return v * v * v * v * v;
}

half BurleyBRDF(half3 NdotL, half3 NdotV, half3 VdotH, half roughness)
{
	NdotV = max(NdotV, 0.1);  // Prevent overly dark edges
	
	// Burley BRDF with renormalization to conserve energy
	half energyBias = 0.5 * roughness;
	half energyFactor = lerp(1, 1 / 1.51, roughness);
	half fd90 = energyBias + 2.0 * VdotH * VdotH * roughness;
	half scatterL = lerp(1, fd90, Pow5(1 - NdotL));
	half scatterV = lerp(1, fd90, Pow5(1 - NdotV));
	
	return scatterL * scatterV * energyFactor * NdotL;
}

half DiffuseBRDF(half3 N, half3 V, half3 L, half Gloss, half NdotL)
{
	// TODO: Share computations with Specular BRDF
	half m = SmoothnessToRoughness(min(Gloss, 1));
	half VdotH = saturate(dot(V, normalize(V + L)));
	half NdotV = abs(dot(N, V)) + 1e-5h;
	
	// Burley BRDF with renormalization to conserve energy
	return BurleyBRDF(NdotL, NdotV, VdotH, m);
}

half3 ThinTranslucencyBRDF(half3 N, half3 L, half3 transmittanceColor)
{
	half w = lerp(0, 0.5, GetLuminance(transmittanceColor));
	half wn = rcp((1 + w) * (1 + w));
	half NdotL = dot(N, L);
	half transmittance = saturate((-NdotL + w) * wn);
	half diffuse = saturate((NdotL + w) * wn);
	
	return transmittanceColor * transmittance + diffuse;
}


////////////////////////////////////////////////////////////////////////////
// Occlusion

half DeriveSpecularOcclusion(half fNdotV, half aoAmount, half smoothness)
{
	// Derive specular occlusion term form ambient occlusion:
	//   Rough surfaces receive full ambient occlusion
	//   Smooth surfaces get more occlusion at grazing angles and less at normal incidence
	return saturate(pow(fNdotV + aoAmount, smoothness) - 1 + aoAmount);
}


//////////////////////////////// Vegetation shading ////////////////

// Common vegetation shading

half3 LeafShadingBack(half3 vEye, half3 vLight, half3 vNormal, half3 cDiffBackK, half backViewDep)
{            
  half EdotL=saturate(dot(vEye.xyz, -vLight.xyz));          
  
  // Tweaked NdotL wrapping - Artists request
  half fLdotNBack=saturate(dot(vNormal.xyz, vLight.xyz)*0.6+0.4);

  half powEdotL = EdotL*EdotL;
  powEdotL *= powEdotL;
    
  half3 vBackShading = saturate(powEdotL*backViewDep + (1.0-backViewDep) * fLdotNBack);    

  return vBackShading * cDiffBackK.xyz;
}   

void LeafShadingFront(half3 vEye, half3 vLight, half3 vNormal, half3 cDifK, half3 cSpecK, inout half3 outDif, inout half3 outSpec, half fGloss)
{                                                                                                                                  
  half fLdotNFront=dot(vNormal.xyz, vLight.xyz);      
  // Compute front diffuse term  
#if %GRASS   
  outDif=max(fLdotNFront, 0.5)*cDifK.xyz; 
#else
  outDif=saturate(fLdotNFront)*cDifK.xyz;
#endif
  // compute specular if necessary 
#if !%GRASS
  outSpec = BlinnBRDF(vNormal, vEye, vLight, fGloss) * saturate(fLdotNFront) * cSpecK.xyz;  
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Parallel view opacity falloff (for close to parallel leaf polys)

float ParallelOpacityFalloff(float3 vWorldPos, float3 vNormal, float fCapOpacityFalloff, float fAlphaTest)
{
	half3 inverseViewVec = normalize(vWorldPos.xyz); // we use the abs of the dot on next line, so direction of view vec doesn't matter
	half parallelViewOpacity = abs(dot(inverseViewVec, vNormal));

	// cos(alpha ramp start angle) = 0.05
	// cos(alpha ramp end angle) = 0.3
	const half a = 1.0h / (0.3h - 0.05h);
	const half b = -0.05h / (0.3h - 0.05h);

	half x = parallelViewOpacity;

	x = saturate(x*a + b); // remap alpha ramp range to [0..1]
	//x *= (2.0h - x); // eval 2nd order polynomial

	parallelViewOpacity = max(x, fCapOpacityFalloff);

	return 1.0f + parallelViewOpacity * (fAlphaTest - 1.0f);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Layer blending

half GetLayerBlendingValue(in Texture2D blendTex, in float2 uv, in float lod, in half vtxAlpha, in half blendFactor, in half blendFalloff)
{
	#if !ENABLE_TESSELLATION && !%SILHOUETTE_PARALLAX_OCCLUSION_MAPPING // TODO: find way to compute lod without gradients as they cause pixel artifacts at fin / shell transition
		half4 blendMap = GetBlendTex(blendTex, uv);
	#else
		half4 blendMap = GetBlendTexLod(blendTex, float4(uv, 0, lod));
	#endif

	half blendFac = vtxAlpha * blendMap.r * (1 + blendFactor);
	blendFac = saturate(pow(blendFac, blendFalloff));
	return blendFac;
}

// Terrain layers are a particular case of blend layer, where blendmap is the heightmap and blending
// is only valid on transition from full opaque (vtx alpha = 1) to fully transparent (vtx alpha = 0)	
half GetTerrainLayerBlendingValue(in Texture2D heightTex, in float2 uv, in float lod, in half vtxAlpha, in half blendFactor, in half blendFalloff)
{
	#if !ENABLE_TESSELLATION && !%SILHOUETTE_PARALLAX_OCCLUSION_MAPPING // TODO: find way to compute lod without gradients as they cause pixel artifacts at fin / shell transition
		half4 blendMap = GetHeightTex(heightTex, uv);
	#else
		half4 blendMap = GetHeightTexLod(heightTex, float4(uv, 0, lod));
	#endif


	blendMap = saturate(saturate(vtxAlpha*2-1) + blendMap.x); // 2 inst

	half blendFac = vtxAlpha * blendMap.r * (1 + blendFactor);
	blendFac = saturate(pow(blendFac, blendFalloff));
	return blendFac;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Silhouette POM, POM & OBM tex coord gen

float4 ComputeBarycentricCorrespondence(in float3 wsPos, in float3 wsTriPos[3], in float3 wsTriDispl[3]) // WS -> TS
{
	float w = 0.0;
	float stepsize = 0.5;

	float3 p0, p1, p2;
	float3 u, v, n, d;

	[unroll]
	for (int i=0; i<10; ++i)
	{
		p0 = wsTriPos[0] + w * wsTriDispl[0];
		p1 = wsTriPos[1] + w * wsTriDispl[1];
		p2 = wsTriPos[2] + w * wsTriDispl[2];

		u = p1 - p0;
		v = p2 - p0;
		n = cross(u, v);
		d = wsPos - p0;

		const float dist = dot(n, d);
		w += (dist > 0.0) ? stepsize : -stepsize;
		stepsize *= 0.5;
	}

	float oneOver4ASquared = 1.0 / dot(n, n);
	float2 bary_uv = float2(dot(cross(d, v), n), dot(cross(u, d), n)) * oneOver4ASquared;

	return float4(1.0 - dot(bary_uv, float2(1, 1)), bary_uv, w);
}

struct CbcWsRes
{
	float3 wsPos;
	float3 wsNorm;
};

CbcWsRes ComputeBarycentricCorrespondence(in float4 bary, in float3 wsTriPos[3], in float3 wsTriDispl[3]) // TS to WS
{
	const float3 disp = wsTriDispl[0].xyz * bary.x + wsTriDispl[1].xyz * bary.y + wsTriDispl[2].xyz * bary.z;
	const float3 pos = wsTriPos[0].xyz * bary.x + wsTriPos[1].xyz * bary.y + wsTriPos[2].xyz * bary.z + disp * bary.w;

	CbcWsRes res;
	res.wsPos = pos;
	res.wsNorm = normalize(disp);

	return res;
}

struct SilMapRes
{
	float2 uvHitPos;
	float4 baryHitPos;
};

SilMapRes SilhouetteMap(in const float3 wsTriPos[3], in const float3 wsTriDispl[3], in const float4 wsClipPlane[5], in const float3 wsViewDir, in const float3 texGenU, in const float3 texGenV, in float lod, in float numSteps, in float displacement)
{
	const float stepSize = 1.0 / clamp(numSteps, 1.f, 512.f);
	
	const float3 wsStartPos = wsViewDir;
	float3 wsEndPos = wsStartPos;
	{
		float tEnd = 1e8;
		for (int i=0; i<5; i++)
		{
			const float3 o = wsStartPos;
			const float3 d = wsViewDir;
	
			const float denom = dot(wsClipPlane[i].xyz, d);
			//if (denom > 0)
			{
				const float t = (wsClipPlane[i].w - dot(wsClipPlane[i].xyz, o)) / denom;
				if (denom > 0 && t < tEnd)
				{
					wsEndPos.xyz = o + d * t;
					tEnd = t;
				}
			}
		}
	}
	
	const float4 baryStart = ComputeBarycentricCorrespondence(wsStartPos, wsTriPos, wsTriDispl);
	const float4 baryEnd = ComputeBarycentricCorrespondence(wsEndPos, wsTriPos, wsTriDispl);
	
	const float3 uvStart = float3(dot(texGenU, baryStart.xyz), dot(texGenV, baryStart.xyz), baryStart.w);
	const float3 uvEnd = float3(dot(texGenU, baryEnd.xyz), dot(texGenV, baryEnd.xyz), baryEnd.w);
	const float3 uvDeltaStep = (uvEnd - uvStart) * stepSize;
	
	float stepped = 0;
	float4 uv = float4(uvStart, lod);
	
	float height = GetHeightTexLod(heightTex, uv);
	
	if (height < uv.z)
	{
		{
			for (; stepped < 1.0; stepped += stepSize)
			{
				[flatten]
				if (height >= uv.z)
					break;
	
				uv.xyz += uvDeltaStep;
	
				height = GetHeightTexLod(heightTex, uv);
			}
	
			clip(height - uv.z + 0.001);
		}
	
		{
			float pivot = -0.5;
			float bstep = 0.5;
	
			for (int i=0; i<10; i++)
			{
				const float3 lookup = uv.xyz + pivot * uvDeltaStep;
				bstep *= 0.5;
				
				height = GetHeightTexLod(heightTex, float4(lookup, uv.w));

				pivot += (height >= lookup.z) ? -bstep : bstep;
			}
	
			uv.xyz += uvDeltaStep * pivot;
			stepped += stepSize * pivot;
		}
	}
	
	SilMapRes res;
	res.uvHitPos = uv.xy;
	res.baryHitPos = baryStart + (baryEnd - baryStart) * stepped;
	
	return res;
}

float3 ParallaxOcclusionMap(in float2 baseTC, in float lod, in float3 viewDirNrm, in int numSteps, in float displacement, in float bias, in float blendLayerFactor, in float blendLayer2Tiling)
{
	float step =  1.0 / numSteps;
	float bumpScale = displacement;

	float2 delta = float2(viewDirNrm.x, viewDirNrm.y) * bumpScale / (-viewDirNrm.z * numSteps); // / max(-viewDirNrm.z * numSteps, 0.1)

	baseTC -= (1.0 - bias) * numSteps * delta;

	float NB0 = GetHeightTex(heightTex, baseTC);
#if %BLENDLAYER
	float NB02 = GetHeight2Tex(Height2Tex, baseTC.xy * blendLayer2Tiling);

	NB0 += blendLayerFactor * (NB02 - NB0);
#endif

	float height = 1 - step;
	float4 offset = float4(baseTC + delta, 0, lod);
	
	float NB1 = GetHeightTex(heightTex, offset);
#if %BLENDLAYER
	float NB12 = GetHeight2Tex(Height2Tex, offset.xy * blendLayer2Tiling);

	NB1 += blendLayerFactor * (NB12 - NB1);
#endif

	for (int i=0; i<numSteps; i++)
	{
		[flatten]
		if (NB1 >= height)
			break;

		NB0 = NB1;

		height -= step;
		offset.xy += delta;

		NB1 = GetHeightTexLod(heightTex, offset);
#if %BLENDLAYER
		NB12 = GetHeightTexLod(Height2Tex, float4(offset.xy * blendLayer2Tiling, offset.zw));

		NB1 += blendLayerFactor * (NB12 - NB1);
#endif
	}

	float4 offsetBest = offset;
	float error = 1.0;

	float t1 = height;
	float t0 = t1 + step;

	float delta1 = t1 - NB1;
	float delta0 = t0 - NB0;

	float4 intersect = float4(delta * numSteps, delta * numSteps + baseTC);

	float t = 0;

	for (int i=0; i<10; i++)
	{
		[flatten]
		if (abs(error) <= 0.01)
			break;

		float denom = delta1 - delta0;
		t = (t0 * delta1 - t1 * delta0) / denom;
		offsetBest.xy = -t * intersect.xy + intersect.zw;

		float NB = GetHeightTexLod(heightTex, offsetBest);
#if %BLENDLAYER
		float NB2 = GetHeightTexLod(heightTex, float4(offsetBest.xy * blendLayer2Tiling, offsetBest.zw));

		NB += blendLayerFactor * (NB2 - NB);
#endif

		error = t - NB;
		if (error < 0)
		{
			delta1 = error;
			t1 = t;
		}
		else
		{
			delta0 = error;
			t0 = t;
		}
	}
	return float3(offsetBest.xy, t);
}

float2 OffsetMap(in float2 baseTC, in half3 viewDirNrm, in int numSteps, in half displacement, in half bias, in half blendLayerFactor, in float blendLayer2Tiling)
{
	half offset = -bias * displacement;
	float3 newCoords = float3(baseTC, 0);
	for (int i=0; i<numSteps; ++i)
	{
		half nz = GetNormalMap(normalsTex, newCoords.xy).z;
		half h = GetHeightTex(heightTex, newCoords.xy);

#if %BLENDLAYER
		const float2 newCoords2 = newCoords.xy * blendLayer2Tiling;
		nz += blendLayerFactor * (GetNormalMap(Bump2Tex, newCoords2.xy).z - nz);
		h += blendLayerFactor * (GetHeight2Tex(Height2Tex, newCoords2.xy) - h);
#endif

		half height = h * displacement + offset;
		newCoords += (height - newCoords.z) * nz * viewDirNrm;
	}
	return newCoords.xy;
}

#define MICRO_DETAIL_QUALITY_DEF 0
#define MICRO_DETAIL_QUALITY_OBM 1
#define MICRO_DETAIL_QUALITY_POM 2
#define MICRO_DETAIL_QUALITY_SPM 3

void GetMicroDetailParams(out int mdQuality, out half mdDisplacement, out half mdHeightBias, out half mdSelfShadowStrength)
{
	mdQuality = MICRO_DETAIL_QUALITY_DEF;
	mdDisplacement = 0.0h;
	mdHeightBias = 1.0h;
	mdSelfShadowStrength = 0.0h;

#if %OFFSET_BUMP_MAPPING || %PARALLAX_OCCLUSION_MAPPING || %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
	int shQuality = GetShaderQuality();
	#if %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
		{
			mdQuality = MICRO_DETAIL_QUALITY_SPM;
			mdDisplacement = SilPomDisplacement;
			mdHeightBias = HeightBias;
			mdSelfShadowStrength = SelfShadowStrength;
			return;
		}
	#endif

	#if %OFFSET_BUMP_MAPPING && %PARALLAX_OCCLUSION_MAPPING
		if (shQuality > QUALITY_MEDIUM)
		{
			mdQuality = MICRO_DETAIL_QUALITY_POM;
			mdDisplacement = PomDisplacement;
		}
		else if (shQuality == QUALITY_MEDIUM)
		{
			mdQuality = MICRO_DETAIL_QUALITY_OBM;
			mdDisplacement = ObmDisplacement;
		}
	#elif %PARALLAX_OCCLUSION_MAPPING
		if (shQuality > QUALITY_MEDIUM)
		{
			mdQuality = MICRO_DETAIL_QUALITY_POM;
			mdDisplacement = PomDisplacement;
		}
	#elif %OFFSET_BUMP_MAPPING
		if (shQuality > QUALITY_LOW)
		{
			mdQuality = MICRO_DETAIL_QUALITY_OBM;
			mdDisplacement = ObmDisplacement;
		}
	#endif

	mdHeightBias = HeightBias;
	mdSelfShadowStrength = SelfShadowStrength;
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// EnvMap Samplers
////////////////////////////////////////////////////////////////////////////////////////////////////

half4 DecodeHDRCubemap(half4 color)
{
	return color;
}

half4 GetEnvironmentCMap(TextureCube envCubeTex, SamplerState envCubeSampler, in half3 envTC, in half fGloss)
{
	const half numCMapMips = 6.0;  // TODO: Use real cubemap size
	
	half fGlossinessLod = numCMapMips - fGloss * numCMapMips;
	half4 envColor = DecodeHDRCubemap(envCubeTex.SampleLevel(envCubeSampler, envTC, fGlossinessLod));

	return envColor;
}

void CubemapBoxParallaxCorrection(inout half3 vReflVec, in half3 vPosLightDist, in half3 vBoxExtentsMin, in half3 vBoxExtentsMax, inout half fGloss)
{
	// Parallax correction for local cubemaps using a box as geometry proxy

	half3 vReflVecN = normalize(vReflVec.xyz);
		
	// Min/max intersection
	half3 vBoxIntersectionMax = (vPosLightDist + vBoxExtentsMax) / vReflVecN;
	half3 vBoxIntersectionMin = (vPosLightDist + vBoxExtentsMin) / vReflVecN;
	
	// Intersection test
	half3 vFurthestPlane = vReflVecN > 0.0f ? vBoxIntersectionMax : vBoxIntersectionMin;
	half fDistance = min(min(vFurthestPlane.x, vFurthestPlane.y), vFurthestPlane.z);

	// Apply new reflection position
	half3 vInterectionPos = -vPosLightDist;
	vReflVec = vInterectionPos + (vReflVecN * fDistance);

	// Modulate glossiness based on reflection vector length.
	//half3 vDist = vBoxPos - vPosition;
	//half fSqrLen = 1.h - saturate(dot(vDist, vDist));
	//fGloss = lerp(fGloss, 1.h, saturate(fGloss * fSqrLen));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// HDR output

void HDRFogOutput( out pixout OUT, half4 Color, half fDepth, half3 FogColor, half fFogFactor )
{
  Color.xyz = lerp(FogColor.xyz, Color.xyz, fFogFactor);
  OUT.Color = Color;
}

void HDROutput( out pixout OUT, half4 Color, half fDepth)
{
  OUT.Color = Color;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Depth/Fog output

#include "VolumetricFog.cfi"

// NOTE: float[X] was used in favor of half[X] as precision is curcial and half's is not sufficient!
half4 EncodeSceneDepth( float depth )
{
  return half4(depth,depth,depth,depth);
} 

// This function encodes a depth value so it can be stored in an ARGB8 rendertarget and sets a specific alpha value
float4 EncodeSceneDepthWithAlpha( float depth, half alpha, half alphaTestRef)
{
  float4 ret = EncodeSceneDepth( depth );

	clip(alpha - alphaTestRef);

	ret.a = alpha;

  return ret;
}

// This function encodes a depth value so it can be stored in an ARGB8 rendertarget and sets a specific alpha value
float4 EncodeSceneDepthNoAlpha( float depth)
{
  return EncodeSceneDepth( depth );
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Common culling/interpolation functions

float4 BilinearInterp(float2 UV, float4 p0, float4 p1, float4 p2, float4 p3)
{
	float4 bl = float4( (1.f - UV.x) * (1.f - UV.y), UV.x * (1.f - UV.y), (1.f - UV.x) * UV.y, UV.x * UV.y );

	return bl.x * p0 + bl.y * p1 + bl.z * p2+ bl.w * p3;
}

float4 BarycentricInterp(float3 bcs, float4 p0, float4 p1, float4 p2)
{
	return bcs.x * p0 + bcs.y * p1 + bcs.z * p2;
}

float DistanceFromPlane (float3 f3Position, float4 f4PlaneEquation)
{
  return dot(float4( f3Position, 1.0f ), f4PlaneEquation);
}

bool ViewFrustumCull(
                    float3 f3EdgePosition0,         // World space position of patch control point 0
                    float3 f3EdgePosition1,         // World space position of patch control point 1
                    float3 f3EdgePosition2,         // World space position of patch control point 2
                    float4x4 f4ViewFrustumPlanes,   // 4 plane equations (left, right, top, bottom)
                    float fCullEpsilon              // Epsilon to determine the distance outside the view frustum is still considered inside
                    )
{    
	bool4 f4PlaneTest;
	// Left clip plane
	f4PlaneTest.x = (DistanceFromPlane(f3EdgePosition0, f4ViewFrustumPlanes[0]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition1, f4ViewFrustumPlanes[0]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition2, f4ViewFrustumPlanes[0]) < fCullEpsilon);
	// Right clip plane
	f4PlaneTest.y = (DistanceFromPlane(f3EdgePosition0, f4ViewFrustumPlanes[1]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition1, f4ViewFrustumPlanes[1]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition2, f4ViewFrustumPlanes[1]) < fCullEpsilon);
	// Top clip plane
	f4PlaneTest.z = (DistanceFromPlane(f3EdgePosition0, f4ViewFrustumPlanes[2]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition1, f4ViewFrustumPlanes[2]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition2, f4ViewFrustumPlanes[2]) < fCullEpsilon);
	// Bottom clip plane
	f4PlaneTest.w = (DistanceFromPlane(f3EdgePosition0, f4ViewFrustumPlanes[3]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition1, f4ViewFrustumPlanes[3]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition2, f4ViewFrustumPlanes[3]) < fCullEpsilon);
	
	// Triangle has to pass all 4 plane tests to be visible
	return !all( f4PlaneTest );
}

bool ViewFrustumCull(
                    float3 f3EdgePosition0,         // World space position of patch control point 0
                    float3 f3EdgePosition1,         // World space position of patch control point 1
                    float3 f3EdgePosition2,         // World space position of patch control point 2
                    float3 f3EdgePosition3,         // World space position of patch control point 3
                    float4x4 f4ViewFrustumPlanes,   // 4 plane equations (left, right, top, bottom)
                    float fCullEpsilon              // Epsilon to determine the distance outside the view frustum is still considered inside
                    )
{    
	bool4 f4PlaneTest;
	// Left clip plane
	f4PlaneTest.x = (DistanceFromPlane(f3EdgePosition0, f4ViewFrustumPlanes[0]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition1, f4ViewFrustumPlanes[0]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition2, f4ViewFrustumPlanes[0]) < fCullEpsilon)
    || (DistanceFromPlane(f3EdgePosition3, f4ViewFrustumPlanes[0]) < fCullEpsilon);
	// Right clip plane
	f4PlaneTest.y = (DistanceFromPlane(f3EdgePosition0, f4ViewFrustumPlanes[1]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition1, f4ViewFrustumPlanes[1]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition2, f4ViewFrustumPlanes[1]) < fCullEpsilon)
    || (DistanceFromPlane(f3EdgePosition3, f4ViewFrustumPlanes[1]) < fCullEpsilon);
	// Top clip plane
	f4PlaneTest.z = (DistanceFromPlane(f3EdgePosition0, f4ViewFrustumPlanes[2]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition1, f4ViewFrustumPlanes[2]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition2, f4ViewFrustumPlanes[2]) < fCullEpsilon)
    || (DistanceFromPlane(f3EdgePosition3, f4ViewFrustumPlanes[2]) < fCullEpsilon);
	// Bottom clip plane
	f4PlaneTest.w = (DistanceFromPlane(f3EdgePosition0, f4ViewFrustumPlanes[3]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition1, f4ViewFrustumPlanes[3]) < fCullEpsilon)
		|| (DistanceFromPlane(f3EdgePosition2, f4ViewFrustumPlanes[3]) < fCullEpsilon)
    || (DistanceFromPlane(f3EdgePosition3, f4ViewFrustumPlanes[3]) < fCullEpsilon);
	
	// Quad has to pass all 4 plane tests to be visible
	return !all( f4PlaneTest );
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// Setup alpha coverage/alpha value

void GetAlphaCoverageMask( Texture2D texDiffuse, in float2 baseTC, in half fAlphaRef, inout half fDiffuseAlpha, inout uint uCoverageMask, bool bOneBitAlpha = false) 
{
#if %_RT_ALPHATEST

#if %_RT_MSAA_QUALITY || %_RT_MSAA_QUALITY1
	fDiffuseAlpha = 0;

	float2 vDDX = ddx( baseTC.xy );
	float2 vDDY = ddy( baseTC.xy );

	int nSamplesNum = GetMSAASampleNum();

	// DX11 has standardized MSAA offsets
#if %_RT_MSAA_QUALITY && %_RT_MSAA_QUALITY1
	static const float2 vMSAAOffsets[8] = 
	{ 
		float2(0.0625, -0.1875),  float2(-0.0625,  0.1875),
		float2(0.3125,  0.0625),  float2(-0.1875, -0.3125),
		float2(-0.3125,  0.3125), float2(-0.4375, -0.0625),
		float2(0.1875,  0.4375),  float2(0.4375, -0.4375)
	};
#elif %_RT_MSAA_QUALITY && !%_RT_MSAA_QUALITY1
	static const float2 vMSAAOffsets[4] = 
	{ 
		float2(-0.125, -0.375), float2(0.375, -0.125),
		float2(-0.375,  0.125), float2(0.125,  0.375)
	};
#elif !%_RT_MSAA_QUALITY && %_RT_MSAA_QUALITY1
	static const float2 vMSAAOffsets[2] = 
	{ 
		float2(0.25, 0.25), float2(-0.25, -0.25) 
	};
#endif

	// Loop through all sub-samples
	float2 vDifAlphaAcc = float2(0, 0);
	[unroll] for( int i = 0; i < nSamplesNum; ++i )
	{
		// TODO: use gather
		float2 v2TexelOffset = vMSAAOffsets[i].x * vDDX + vMSAAOffsets[i].y * vDDY;
		float fSampleDiffuseAlpha = GetAlphaTex(texDiffuse, baseTC + v2TexelOffset);
		if( bOneBitAlpha )
			fSampleDiffuseAlpha = fSampleDiffuseAlpha > 0.0h;

		if( ( fSampleDiffuseAlpha - fAlphaRef ) >= 0 )
		{ 
			// Update output coverage mask 
			uCoverageMask |= ( uint(0x1) << i );
			vDifAlphaAcc.xy += float2(fSampleDiffuseAlpha, 1);
		}
	}

	// Output average of summed alpha
	if( vDifAlphaAcc.y )
		fDiffuseAlpha = vDifAlphaAcc.x / vDifAlphaAcc.y;
#endif

#endif
}
