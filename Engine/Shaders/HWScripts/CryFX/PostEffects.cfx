// Copyright 2001-2018 Crytek GmbH / Crytek Group. All rights reserved.

#include "Common.cfi"
#include "PostEffectsLib.cfi"
#include "ShadeLib.cfi"

// Shader global descriptions
float Script : STANDARDSGLOBAL
<
  string Script =
           "NoPreview;"
           "LocalConstants;"
           "ShaderDrawType = Custom;"
           "ShaderType = PostProcess;"
>; 


/// Common constants ////////////////////////////

float4x4 mColorMatrix;

float g_fWaterLevel
<
  Position;
> = {PB_WaterLevel};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Texture To Texture technique ///////////////////////////////////////////////////////////////////

/// Constants ////////////////////////////

float4 texToTexParams0;
float4 texToTexParams1;
float4 texToTexParams2;
float4 texToTexParams3;
float4 texToTexParamsTC;

////////////////// samplers /////////////////////

Texture2D<float4> Tx2Tx_Source          : register(t0); 
SamplerState Tx2Tx_Sampler              : register(s0);

///////////////// vertex shader //////////////////

struct vtxOutTexToTex
{
  float4 HPosition  : SV_POSITION;
  float2 baseTC     : TEXCOORDN;       

  MSAA_SAMPLE_INDEX_PS
};

vtxOutTexToTex TexToTexVS(uint VertexID : SV_VertexID)
{
  vtxOutTexToTex OUT; 
  OUT.HPosition = GetHPos_FromTriVertexID(VertexID);
  float2 baseTC = GetBaseTC_FromTriVertexID(VertexID);
  OUT.baseTC.xy = baseTC;
  return OUT;
}

vtxOutTexToTex TexToTexRegVS(vtxIn IN)
{
  vtxOutTexToTex OUT; 
  OUT.HPosition = IN.Position;
  OUT.baseTC.xy = float2(IN.baseTC.x, 1-IN.baseTC.y) * texToTexParamsTC.zw + texToTexParamsTC.xy;
  return OUT;
}

///////////////// pixel shader //////////////////

[earlydepthstencil]
pixout TexToTexPS(vtxOutTexToTex IN)
{
  pixout OUT = (pixout) 0;

#if %_RT_SAMPLE0
	int nSampleCountMS = GetMSAASampleNum();
	//if( nSampleCountMS )
	//{
 //   // Avg resolve
	//	half4 cSampleAcc = 0;
	//	for(int s= 0; s < nSampleCountMS; s++)
	//	{
	//		half4 vSample = GetTargetIndexMS(0, IN.baseTC.xy, nSampleCountMS, s);
	//		cSampleAcc += vSample;
	//	}
	//	OUT.Color.rgb =  cSampleAcc / (float) nSampleCountMS;
	//}
 // else
  {
    // Custom per-sample/per-pixel frequency resolve
    uint uSample = 0;
    #if %_RT_MSAA_SAMPLEFREQ_PASS
      uSample = IN.uSample;
    #endif
    OUT.Color = GetTargetIndexMS(0, IN.baseTC.xy, nSampleCountMS, uSample);
  }

#else
	{
		half4 c0 = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy); 

		#if %_RT_SAMPLE2
				c0 = DecodeRGBK(c0, SCENE_HDR_MULTIPLIER, true);
		#endif

		#if %_RT_SAMPLE5
				c0 = EncodeRGBK(half4(c0.rgb, 1.0h), SCENE_HDR_MULTIPLIER, true);
		#endif

		OUT.Color= c0;
	}
#endif
  
  return OUT;
}

[earlydepthstencil]
pixout TexToTexTintedPS(vtxOutTexToTex IN)
{
    pixout OUT = TexToTexPS(IN);
    OUT.Color.rgba *= texToTexParams2.rgba;
    return OUT;
}


Texture2D<float4> Tx2TxCube_Source          : register(t0); 
SamplerState Tx2TxCube_Sampler              : register(s0);

///////////////// pixel shader //////////////////
pixout CubeTexToTexPS(vtxOutTexToTex IN)
{
	pixout OUT = (pixout)0;
	float theta = 1.0 - IN.baseTC.x * PI * 2;
	float phi = IN.baseTC.y * PI;
	float3 vec = float3(cos(theta) * sin(phi), cos(phi), sin(theta) * sin(phi));
	half4 c0 = Tx2TxCube_Source.Sample(Tx2TxCube_Sampler, vec);//texCUBE(_cubetex0, vec);
	OUT.Color = c0;
	return OUT;
}

pixout TexToTexSampledPS(vtxOutTexToTex IN)
{
  pixout OUT = (pixout) 0;

  float2 tc = IN.baseTC.xy;

  half4 _c0 = 0;
  half4 _c1 = 0;
  half4 _c2 = 0;
  half4 _c3 = 0;
  half4 _c4 = 0;

#if %_RT_SAMPLE0
  int nSampleCountMS = GetMSAASampleNum();
  if( nSampleCountMS )
  {
    // note: input texcoords have to match src texture resolution (hence the x2, assuming only half resolution downscale - will not work for diferent res..)
    // - ideally we should have exposed Sampler0/1/etc info
    _c1 = GetTargetIndexMS(0, (tc + texToTexParams0.xy)*2, nSampleCountMS, 0);
    _c2 = GetTargetIndexMS(0, (tc + texToTexParams0.zw)*2, nSampleCountMS, 0);
    _c3 = GetTargetIndexMS(0, (tc + texToTexParams1.xy)*2, nSampleCountMS, 0);
    _c4 = GetTargetIndexMS(0, (tc + texToTexParams1.zw)*2, nSampleCountMS, 0);
    OUT.Color = (_c1 + _c2 + _c3 + _c4) * 0.25h;
    return OUT;
  }
#endif

  _c0 = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, tc); // Use slightly better quality for DX11
  _c1 = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, tc + texToTexParams0.xy);
  _c2 = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, tc + texToTexParams0.zw);
  _c3 = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, tc + texToTexParams1.xy);
  _c4 = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, tc + texToTexParams1.zw);

  bool bRgbkUsePPP = true;
#if %_RT_SAMPLE1
	bRgbkUsePPP = false;
#endif

#if %_RT_SAMPLE2
	_c1 = DecodeRGBK(_c1, SCENE_HDR_MULTIPLIER, bRgbkUsePPP);
	_c2 = DecodeRGBK(_c2, SCENE_HDR_MULTIPLIER, bRgbkUsePPP);
	_c3 = DecodeRGBK(_c3, SCENE_HDR_MULTIPLIER, bRgbkUsePPP);
	_c4 = DecodeRGBK(_c4, SCENE_HDR_MULTIPLIER, bRgbkUsePPP); 
#endif	

	OUT.Color = (_c0 + _c1 + _c2 + _c3 + _c4) * 0.2h;

		#if %_RT_SAMPLE5
			OUT.Color = EncodeRGBK(half4(OUT.Color.xyz, 1.0h), SCENE_HDR_MULTIPLIER, bRgbkUsePPP);
		#endif

		#if %_RT_SAMPLE4 // min/max depth
			half4 depths  = half4(_c1.x,_c2.x,_c3.x,_c4.x);
			#if %_RT_REVERSE_DEPTH
				depths.xy      = min(depths.xy,depths.zw);
				OUT.Color.xyzw = min(depths.x, depths.y);
			#else
				depths.xy      = max(depths.xy,depths.zw);
				OUT.Color.xyzw = max(depths.x, depths.y);
			#endif
		#endif

		#if %_RT_SAMPLE1 && !%_RT_SAMPLE4 && !%_RT_SAMPLE2 && !%_RT_SAMPLE5
			OUT.Color.a = 0;
		#endif
	return OUT;
}

pixout TexToTexTintedSampledPS(vtxOutTexToTex IN)
{
  pixout OUT = TexToTexSampledPS(IN);
  OUT.Color.rgba *= texToTexParams2.rgba;
  return OUT;
}

float4 g_vUITextureColor;

pixout TexToTexOneAlphaPS(vtxOutTexToTex IN)
{
	pixout OUT = (pixout) 0;

	OUT.Color =  GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy) * g_vUITextureColor;
	OUT.Color.rgb *= OUT.Color.a;

	return OUT;
}


float GetWeight(float2 vSamplePos)
{
#if %_RT_SAMPLE0 // tent
	const float2 vWeight = 1.f.xx - abs(vSamplePos);
	return vWeight.x * vWeight.y;
#elif %_RT_SAMPLE1 // gauss
	return exp2(-4.f * dot(vSamplePos, vSamplePos));
#elif %_RT_SAMPLE2 // lanczos
	const float2 vPiProd = PI * (vSamplePos + 1e-4f);
	const float2 vWeight = (sin(vPiProd) * sin(vPiProd * 0.5f) * 2.f) / (vPiProd * vPiProd);
	return vWeight.x * vWeight.y;
#else // box
	return 1.f;
#endif
}

pixout TexToTexSampledFilterPS(vtxOutTexToTex IN)
{
	pixout OUT;

	// 1st sample UV
	float2 vBaseTC = IN.baseTC.xy + texToTexParams1.zw;
	float2 vTC = vBaseTC;
	// Sample kernel position
	float2 vKernelPos = texToTexParams2.zw;

	float4 cAccumSample = 0;
	float fAccumWeight = 0;
	//[unroll]
	for ( ;
		vKernelPos.y < texToTexParams0.y;
		vKernelPos.y += texToTexParams2.y )
	{
		vTC.x = vBaseTC.x;

		//[unroll]
		for (vKernelPos.x = texToTexParams2.z;
			vKernelPos.x < texToTexParams0.x;
			vKernelPos.x += texToTexParams2.x )
		{
			const float fWeight = GetWeight(vKernelPos);
			cAccumSample += fWeight *  GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, float4(vTC * texToTexParams0.zw, 0, 0));
			fAccumWeight += fWeight;
			vTC.x += texToTexParams1.x;
		}

		vTC.y += texToTexParams1.y;
	}

	OUT.Color = cAccumSample / fAccumWeight;

	return OUT;
}

pixout DownsampleStablePS(vtxOutTexToTex IN)
{
  // High quality downsampling filter to reduce bloom flickering
	// Filter combines five 4x4 blocks (sampled bilinearly)
	// Reduces fireflies by applying tonemapping before averaging samples for each block
	
	pixout OUT = (pixout)0;

#if %_RT_SAMPLE0	
	const bool bKillFireflies = true;
#else
	const bool bKillFireflies = false;
#endif
	
	const float2 TexSize = 1 / (PS_ScreenSize.xy * 2);
	
	half3 blockTL = 0, blockTR = 0, blockBR = 0, blockBL = 0;
	half3 tex;
	
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2(-2, -2) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockTL += tex;
	
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2( 0, -2) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockTL += tex; blockTR += tex;
	
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2( 2, -2) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockTR += tex;
	
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2(-2,  0) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockTL += tex; blockBL += tex;
	
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2( 0,  0) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockTL += tex; blockTR += tex; blockBR += tex; blockBL += tex;
	
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2( 2,  0) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockTR += tex; blockBR += tex;
	
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2(-2,  2) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockBL += tex;
	
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2( 0,  2) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockBL += tex; blockBR += tex;
	
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2( 2,  2) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockBR += tex;
	
	half3 blockCC = 0;
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2(-1, -1) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockCC += tex;
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2( 1, -1) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockCC += tex;
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2( 1,  1) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockCC += tex;
	tex = GetTexture2D(Tx2Tx_Source, Tx2Tx_Sampler, IN.baseTC.xy + float2(-1,  1) * TexSize).rgb;
	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
	blockCC += tex;
	
	blockTL /= 4; blockTR /= 4; blockBR /= 4; blockBL /= 4; blockCC /= 4;
	
	if (bKillFireflies) 
	{
		// Convert back to uncompressed/linear range
		blockTL /= (1 - GetLuminance(blockTL));
		blockTR /= (1 - GetLuminance(blockTR));
		blockBR /= (1 - GetLuminance(blockBR));
		blockBL /= (1 - GetLuminance(blockBL));
		blockCC /= (1 - GetLuminance(blockCC));
	}
	
	OUT.Color.rgb = 0.5 * blockCC + 0.125 * (blockTL + blockTR + blockBR + blockBL);
	
	// Filter out NaNs
	OUT.Color.rgb = all(isfinite(OUT.Color.rgb)) ? OUT.Color.rgb : float3(0, 0, 0);
  
  return OUT;
}


Texture2D<float4> HalfResColor : register(t0);
Texture2D<float4> FullResDepth : register(t1);
Texture2D<float4> HalfResDepth : register(t2);

SamplerState SampStatePoint : register(s0)
{
	Filter = MIN_MAG_MIP_POINT;
	AddressU = Clamp;
	AddressV = Clamp;
};

SamplerState SampStateLinear : register(s1)
{
	Filter = MIN_MAG_LINEAR_MIP_POINT;
	AddressU = Clamp;
	AddressV = Clamp;
};

pixout NearestDepthUpsamplePS(vtxOutTexToTex IN)
{
	pixout OUT;

	const float  fFullResDepth = FullResDepth.Sample(SampStatePoint, IN.baseTC.xy).r;
	const float4 fHalfResDepth = HalfResDepth.Gather(SampStatePoint, IN.baseTC.xy);

	bool bDiscontinuity = false;
	uint  nBestSampleIndex = 0;
	float fBestSampleError = 1.0f;

	uint2 offsets[] = { uint2(0,0), uint2(1,0), uint2(1,1), uint2(0,1) };
	float fDepths[] = { fHalfResDepth.w, fHalfResDepth.z, fHalfResDepth.y, fHalfResDepth.x };

	for(uint i=0; i<4; ++i)
	{
		float fError  = abs(fDepths[i] - fFullResDepth);
		
		if(fError < fBestSampleError)
		{
			fBestSampleError = fError;
			nBestSampleIndex = i;
		}

		if(fError > 0.1f * fFullResDepth) // Relative error!
			bDiscontinuity = true;
	}

	[branch]
	if(!bDiscontinuity)
	{
		OUT.Color = HalfResColor.Sample(SampStateLinear, IN.baseTC.xy);
	}
	else
	{
		uint3 tcTL = uint3(floor(IN.baseTC.xy * texToTexParams0.zw - 0.5f), 0);
		OUT.Color = HalfResColor.Load(float3(tcTL + offsets[nBestSampleIndex], 0));
	}

	return OUT;
}

Texture2D<float4> MultiResOutput : register(t0);

pixout UpscaleMultiResPS(vtxOutTexToTex IN)
{
	pixout OUT = (pixout)0;

	float2 uvMultiRes = MapViewportToRaster(IN.baseTC.xy);

	OUT.Color = MultiResOutput.Sample(SampStateLinear, uvMultiRes);

	return OUT;
}

////////////////// technique /////////////////////

technique TextureToTexture
{
  pass p0
  {
    VertexShader = TexToTexVS() ResolveVS;
    PixelShader = TexToTexPS() ResolvePS;
  }
}

technique TextureToTextureReg
{
  pass p0
  {
    VertexShader = TexToTexRegVS() ResolveVS;
    PixelShader = TexToTexPS() ResolvePS;
  }
}

technique TextureToTextureTinted
{
  pass p0
  {
    VertexShader = TexToTexVS() ResolveVS;
    PixelShader = TexToTexTintedPS() ResolvePS;
  }
}

technique CubeTextureToTexture
{
  pass p0
  {
    VertexShader = TexToTexVS() ResolveVS;
    PixelShader = CubeTexToTexPS() ResolvePS;
  }
}

technique TextureToTextureResampled
{
  pass p0
  {
    VertexShader = TexToTexVS() PostProcessGameVS;            
    PixelShader = TexToTexSampledPS() PostProcessGamePS; // PostProcessGamePS for RT_SAMPLE2
  }
}

technique TextureToTextureResampledReg
{
  pass p0
  {
    VertexShader = TexToTexRegVS() PostProcessGameVS;            
    PixelShader = TexToTexSampledPS() PostProcessGamePS; // PostProcessGamePS for RT_SAMPLE2
  }
}

technique TextureToTextureTintedResampledReg
{
  pass p0
  {
    VertexShader = TexToTexRegVS() PostProcessGameVS;
    PixelShader = TexToTexTintedSampledPS() PostProcessGamePS; // PostProcessGamePS for RT_SAMPLE2
  }
}

technique TextureToTextureOneAlpha
{
  pass p0
  {
    VertexShader = TexToTexVS() PostProcessGameVS;            
    PixelShader = TexToTexOneAlphaPS() PostProcessGamePS;
  }
}

technique TextureToTextureResampleFilter
{
  pass p0
  {
    VertexShader = TexToTexVS() PostProcessGameVS;            
    PixelShader = TexToTexSampledFilterPS() PostProcessGamePS;
  }
}

technique DownsampleStable
{
  pass p0
  {
    VertexShader = TexToTexVS() PostEffectsVS;
    PixelShader = DownsampleStablePS() PostEffectsPS;
  }
}

technique NearestDepthUpsample
{
  pass p0
  {
    VertexShader = TexToTexVS() PostEffectsVS;
    PixelShader = NearestDepthUpsamplePS() PostEffectsPS;
  }
}

technique DrawLensMatchedOctagon
{
  pass p0
  {
    VertexShader = TexToTexVS() PostEffectsVS;
    GeometryShader = $AutoGS_MultiRes();
    
    CullMode = None;
  }
}

technique UpscaleMultiRes
{
  pass p0
  {
    VertexShader = TexToTexVS() PostEffectsVS;
    
    ZEnable = false;
    CullMode = None;
    
    PixelShader = UpscaleMultiResPS() PostEffectsPS;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Clear screen technique /////////////////////////////////////////////////////////////////////////

/// Specific data ////////////////////////

/// Constants ////////////////////////////

float4 clrScrParams;

/// Samplers ////////////////////////////
// none

///////////////// vertex shader //////////////////

struct vtxOutClrScr
{
  float4 HPosition  : SV_POSITION;
};

vtxOutClrScr ClearScreenVS(vtxIn IN)
{
  vtxOutClrScr OUT = (vtxOutClrScr)0; 
	OUT.HPosition = Get2dHPos(IN.Position);
  return OUT;
}

///////////////// pixel shader //////////////////
pixout ClearScreenPS(vtxOutClrScr IN)
{
  pixout OUT;  
  OUT.Color = clrScrParams;        
  return OUT;
}

////////////////// technique /////////////////////
technique ClearScreen
{
  pass p0
  {
    VertexShader = ClearScreenVS();
    PixelShader = ClearScreenPS();    
    CullMode = None;        
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Linearize Depth technique //////////////////////////////////////////////////////////////////////

Texture2D<float>   LinearizeDepth_DepthTex   : register(t0);
Texture2DMS<float> LinearizeDepth_DepthTexMS : register(t0);

float4 NearProjection;

pixout LinearizeDepthPS(vtxOutTexToTex IN)
{
	pixout OUT = (pixout) 0;

	int3 vPixCoord = int3(IN.baseTC.xy / CV_HPosScale.xy * PS_ScreenSize.xy, 0);

#if %_RT_MSAA_SAMPLEFREQ_PASS
	float fDevDepth = LinearizeDepth_DepthTexMS.Load(vPixCoord, IN.uSample);
#else
	float fDevDepth = LinearizeDepth_DepthTex.Load(vPixCoord);
#endif

#if %_RT_PROJECTION_LENS_MATCHED
	float originalDevDepth = fDevDepth;

	float4 clipPos = MapUnnormalizedRasterToClip(IN.HPosition.xy, fDevDepth, false);
	float rcpW = rcp(clipPos.w);
	fDevDepth *= rcpW;
#endif

	const float fNearestMax = g_PS_ProjRatio.y / (NearProjection.z - g_PS_ProjRatio.x);
	float fDepthLinear = g_PS_ProjRatio.y / (fDevDepth - g_PS_ProjRatio.x);

	if (fDepthLinear < fNearestMax)
	{
#if %_RT_PROJECTION_LENS_MATCHED
		// Convert from [DrawNearZRange..1] to [0..1]
		fDevDepth = (originalDevDepth - NearProjection.w) / (1.0 - NearProjection.w);
		// Unwarp
		fDevDepth *= rcpW;
		// Convert back to [DrawNearZRange..1]
		fDevDepth = fDevDepth * (1.0 - NearProjection.w) + NearProjection.w;
#endif
		fDepthLinear = NearProjection.y / (fDevDepth - NearProjection.x);
	}

	OUT.Color.x = (fDevDepth == 1.0) ? 1.0 : fDepthLinear;  // Preseve exact value of 1.0 that is used for the sky

	return OUT;
}

technique LinearizeDepth
{
  pass p0
  {
    VertexShader = TexToTexVS();
    PixelShader = LinearizeDepthPS() LinearizeDepthPS;
    CullMode = None;
  }
}

pixout FlattenDepthPS(vtxOutTexToTex IN)
{
	pixout OUT = (pixout) 0;
	float2 PixCoord = MapViewportToUnnormalizedRaster(IN.baseTC.xy);
	OUT.Color.x = LinearizeDepth_DepthTex.Load(int3(PixCoord, 0));

	return OUT;
}

technique FlattenDepth
{
  pass p0
  {
    VertexShader = TexToTexVS();
    PixelShader = FlattenDepthPS() LinearizeDepthPS;
    CullMode = None;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Downsample Depth technique /////////////////////////////////////////////////////////////////////

Texture2D<float4> DownsampleDepth_DepthTex : register(t0);
float4 DownsampleDepth_Params;

pixout DownsampleDepthPS(vtxOut IN)
{
	pixout OUT = (pixout) 0;
	
	uint2 WPos = (uint2)IN.WPos.xy;
	float2 scaledTC = (IN.WPos.xy * 2.0) * DownsampleDepth_Params.xy;
	
	float4 vMaxDepths = DownsampleDepth_DepthTex.GatherRed(SampStatePoint, float3(scaledTC, 0));
	float4 vMinDepths = DownsampleDepth_DepthTex.GatherGreen(SampStatePoint, float3(scaledTC, 0));
	float  vPrvDepth  = DownsampleDepth_DepthTex.Load(int3(2 * WPos.x + ((WPos.y & 1) ^ 1), 2 * WPos.y + ((WPos.x & 1) ^ 1), 0));
	
	// Linearize depth
#if %_RT_SAMPLE0
	vMinDepths = CV_ProjRatio.y / (vMinDepths - CV_ProjRatio.x);
	vMaxDepths = CV_ProjRatio.y / (vMaxDepths - CV_ProjRatio.x);
	vPrvDepth  = CV_ProjRatio.y / (vPrvDepth  - CV_ProjRatio.x);
#endif

#if %_RT_SAMPLE1
	vMinDepths = vMaxDepths;
#endif

	OUT.Color.x = max(max(vMaxDepths.x, vMaxDepths.y), max(vMaxDepths.z, vMaxDepths.w));
	OUT.Color.y = min(min(vMinDepths.x, vMinDepths.y), min(vMinDepths.z, vMinDepths.w));
	OUT.Color.z = (vMinDepths.x + vMinDepths.y + vMinDepths.z + vMinDepths.w) * 0.25; // Average
	OUT.Color.w = vPrvDepth; // Rotated Grid Subsample

	return OUT;
}

technique DownsampleDepth
{
	pass p0
	{
		VertexShader = FullscreenTriVS();
		PixelShader = DownsampleDepthPS() ResolvePS;
		CullMode = None;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// CopyToDeviceDepth technique ////////////////////////////////////////////////////////////////////

Texture2D<float4> CopyToDeviceDepth_Tex0 : register(t0);

void CopyToDeviceDepthPS(vtxOut IN, out float Depth : SV_Depth)
{
	float linearDepth = CopyToDeviceDepth_Tex0.Load(int3(IN.WPos.xy, 0)).x;
	Depth = g_PS_ProjRatio.y / linearDepth + g_PS_ProjRatio.x;
}

technique CopyToDeviceDepth
{
  pass p0
  {
    VertexShader = FullscreenTriVS();
    PixelShader  = CopyToDeviceDepthPS();
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Transparency Depth Fixup technique /////////////////////////////////////////////////////////////

Texture2D<float4> TZFixMrg_Source           : register(t0); 
SamplerState TZFixMrg_Sampler               : register(s0);


pixout TranspDepthFixupMergePS(vtxOutTexToTex IN)
{
	// Merge depth values using min/max blending
	pixout OUT = (pixout) 0;
	OUT.Color.x = GetTexture2D(TZFixMrg_Source, TZFixMrg_Sampler, IN.baseTC.xy).w;
	
	if (OUT.Color.x >= 0)
		discard;
	else
		OUT.Color.x = abs(OUT.Color.x);
	
	return OUT;
}

technique TranspDepthFixupMerge
{
	pass p0
	{
		VertexShader = TexToTexVS();
		PixelShader = TranspDepthFixupMergePS();
		CullMode = None;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// GaussBlurBilinear technique ////////////////////////////////////////////////////////////////////

float4 PB_psOffsets[16] < vsregister = c4; > ;
float4 psWeights[16];
float4 clampTC; // minU, maxU, minV, maxV

struct vtxOutGauss
{
  float4 HPosition : SV_POSITION;
  float4 tc0 : TEXCOORDN;    
  float4 tc1 : TEXCOORDN;    
  float4 tc2 : TEXCOORDN;    
  float4 tc3 : TEXCOORDN;    
	float4 tc4 : TEXCOORDN; 
};

struct vtxOutGaussMasked
{
  float4 HPosition : SV_POSITION;
  float4 tc0 : TEXCOORDN;    
  float4 tc1 : TEXCOORDN;    
  float2 tc2 : TEXCOORDN;    
  float2 tc3 : TEXCOORDN;    
  float2 tc4 : TEXCOORDN;    
  float2 tc5 : TEXCOORDN;      
  float2 tc6 : TEXCOORDN;    
  float2 tc7 : TEXCOORDN;    
};

vtxOutGauss GaussBlurBilinearVS(uint VertexID : SV_VertexID)
{
  vtxOutGauss OUT = (vtxOutGauss) 0;

  OUT.HPosition = GetHPos_FromTriVertexID(VertexID);
  float2 baseTC = GetBaseTC_FromTriVertexID(VertexID);
  
  OUT.tc0.xy = baseTC + PB_psOffsets[0].xy;
  OUT.tc0.zw = baseTC + PB_psOffsets[1].xy;
  OUT.tc1.xy = baseTC + PB_psOffsets[2].xy;
  OUT.tc1.zw = baseTC + PB_psOffsets[3].xy;
  OUT.tc2.xy = baseTC + PB_psOffsets[4].xy;
  OUT.tc2.zw = baseTC + PB_psOffsets[5].xy;
  OUT.tc3.xy = baseTC + PB_psOffsets[6].xy;
  OUT.tc3.zw = baseTC + PB_psOffsets[7].xy;
  OUT.tc4.xy = baseTC;  // Original coordinates

  return OUT;
}

vtxOutGaussMasked MaskedGaussBlurBilinearVS(uint VertexID : SV_VertexID)
{
  vtxOutGaussMasked OUT = (vtxOutGaussMasked) 0;
  OUT.HPosition = GetHPos_FromTriVertexID(VertexID);
  float2 baseTC = GetBaseTC_FromTriVertexID(VertexID);

  OUT.tc0.xy = baseTC + PB_psOffsets[0].xy;
  OUT.tc1.xy = baseTC + PB_psOffsets[1].xy;
  OUT.tc2.xy = baseTC + PB_psOffsets[2].xy;
  OUT.tc3.xy = baseTC + PB_psOffsets[3].xy;
  OUT.tc4.xy = baseTC + PB_psOffsets[4].xy;
  OUT.tc5.xy = baseTC + PB_psOffsets[5].xy;
  OUT.tc6.xy = baseTC + PB_psOffsets[6].xy;
  OUT.tc7.xy = baseTC + PB_psOffsets[7].xy;

  // special case for masked blur  - output with correct aspect ratio into wz
  OUT.tc0.wz = baseTC;
  OUT.tc1.wz = (baseTC -0.5 ) * float2(0.75*(ScrSize.x/ScrSize.y), 1.0) + 0.5;

  return OUT;
}

Texture2D<float4> GaussB_Source         : register(t0); 
SamplerState GaussB_Sampler             : register(s0);

pixout GaussBlurBilinearPS(vtxOutGauss IN)
{
  pixout OUT;

  half4 sum = 0;
  
  // Perform downscaling clamp post-interpolation
  IN.tc0.xyzw = clamp(IN.tc0.xyzw, clampTC.xzxz, clampTC.ywyw);
  IN.tc1.xyzw = clamp(IN.tc1.xyzw, clampTC.xzxz, clampTC.ywyw);
  IN.tc2.xyzw = clamp(IN.tc2.xyzw, clampTC.xzxz, clampTC.ywyw);
  IN.tc3.xyzw = clamp(IN.tc3.xyzw, clampTC.xzxz, clampTC.ywyw);

	half4 col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc0.xy);
	sum += col * (half) psWeights[0].x;  

	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc0.zw);
	sum += col * (half) psWeights[1].x;  
	
  col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc1.xy);
	sum += col * (half) psWeights[2].x;  

	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc1.zw);
	sum += col * (half) psWeights[3].x;

	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc2.xy);
	sum += col * (half) psWeights[4].x;  
	
	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc2.zw);
	sum += col * (half) psWeights[5].x;  
	
	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc3.xy);
	sum += col * (half) psWeights[6].x;  
	
	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc3.zw);
	sum += col * (half) psWeights[7].x;

  OUT.Color = sum;

  return OUT;
}

Texture2D<float4> GaussB_Mask         : register(t1); 

pixout MaskedGaussBlurBilinearPS(vtxOutGaussMasked IN)
{
  pixout OUT;

  half4 sum = 0;
  half4 orig = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc0.wz) ;
  half mask = GetTexture2D(GaussB_Mask, GaussB_Sampler, IN.tc1.wz).x ;
  
	half4 col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc0.xy) ;  	
  col = lerp(orig, col, mask);
	sum += col * (half) psWeights[0].x;  

	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc1.xy) ;  
  col = lerp(orig, col, mask);
	sum += col * (half) psWeights[1].x;  
	
  col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc2.xy) ;  
  col = lerp(orig, col, mask);
	sum += col * (half) psWeights[2].x;  

	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc3.xy) ;  
  col = lerp(orig, col, mask);
	sum += col * (half) psWeights[3].x;  

	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc4.xy) ;  
  col = lerp(orig, col, mask);
	sum += col * (half) psWeights[4].x;  
	
	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc5.xy) ;  
  col = lerp(orig, col, mask);
	sum += col * (half) psWeights[5].x;  
	
	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc6.xy) ;  
  col = lerp(orig, col, mask);
	sum += col * (half) psWeights[6].x;  
	
	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc7.xy) ;  
  col = lerp(orig, col, mask);
	sum += col * (half) psWeights[7].x;  

  OUT.Color = sum;
  return OUT;
}

// Optimized gauss blur version, making use of bilinear filtering
technique GaussBlurBilinear
{
  pass p0
  {
    VertexShader = GaussBlurBilinearVS();
    PixelShader = GaussBlurBilinearPS();    
  }
}

technique MaskedGaussBlurBilinear
{
  pass p0
  {
    VertexShader = MaskedGaussBlurBilinearVS();
    PixelShader = MaskedGaussBlurBilinearPS();    
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// GaussAlphaBlur technique ///////////////////////////////////////////////////////////////////////

// FIX:: optimize
struct vtxOutAlphaBlur
{
  float4 HPosition : SV_POSITION;
  float4 tc0 : TEXCOORDN;    
  float2 tc1 : TEXCOORDN;    
  float2 tc2 : TEXCOORDN;    
  float2 tc3 : TEXCOORDN;    
  float2 tc4 : TEXCOORDN;    
  float2 tc5 : TEXCOORDN;      
  float2 tc6 : TEXCOORDN;    
  float2 tc7 : TEXCOORDN;    
};

vtxOutAlphaBlur GaussAlphaBlurVS(uint VertexID : SV_VertexID)
{
  vtxOutAlphaBlur OUT = (vtxOutAlphaBlur) 0;
  OUT.HPosition = GetHPos_FromTriVertexID(VertexID);
  float2 baseTC = GetBaseTC_FromTriVertexID(VertexID);

  OUT.tc0.zw = baseTC;
  OUT.tc0.xy = baseTC + PB_psOffsets[0].xy;
  OUT.tc1.xy = baseTC + PB_psOffsets[1].xy;
  OUT.tc2.xy = baseTC + PB_psOffsets[2].xy;
  OUT.tc3.xy = baseTC + PB_psOffsets[3].xy;
  OUT.tc4.xy = baseTC + PB_psOffsets[4].xy;
  OUT.tc5.xy = baseTC + PB_psOffsets[5].xy;
  OUT.tc6.xy = baseTC + PB_psOffsets[6].xy;
  OUT.tc7.xy = baseTC + PB_psOffsets[7].xy;

  return OUT;
}

pixout GaussAlphaBlurPS(vtxOutAlphaBlur IN)
{
  pixout OUT;

  half sum = 0;
  
	half col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc0.xy).a ;  	
	sum += col * (half) psWeights[0].x;  

	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc1.xy).a ;  
	sum += col * (half) psWeights[1].x;  
	
	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc2.xy).a ;  
	sum += col * (half) psWeights[2].x;  

	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc3.xy).a ;  
	sum += col * (half) psWeights[3].x;  

	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc4.xy).a ;  
	sum += col * (half) psWeights[4].x;  
	
	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc5.xy).a ;  
	sum += col * (half) psWeights[5].x;  
	
	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc6.xy).a ;  
	sum += col * (half) psWeights[6].x;  
	
	col = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc7.xy).a ;  
	sum += col * (half) psWeights[7].x;  

	OUT.Color.xyz = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.tc0.zw).xyz; 
	OUT.Color.a = sum;
  return OUT;
}

technique GaussAlphaBlur
{
  pass p0
  {
    VertexShader = GaussAlphaBlurVS();
    PixelShader = GaussAlphaBlurPS();    
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Blur with 4 taps technique /////////////////////////////////////////////////////////////////////

pixout Blur4TapsPS(vtxOut IN)
{
  pixout OUT = (pixout)0; 

  float4 cAcc = 0;//tex2D(_tex0, IN.baseTC.xy);
  cAcc += GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + texToTexParams0.xy);
  cAcc += GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + texToTexParams0.zw);
  cAcc += GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + texToTexParams1.xy);
  cAcc += GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + texToTexParams1.zw);
  OUT.Color = cAcc * 0.25h;//blurParams0.w;
  
  return OUT;
}

technique Blur4Taps
{
  pass p0
  {
    VertexShader = BaseVS();
    PixelShader = Blur4TapsPS();    
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Directional Blur technique //////////////////////////////////////////////////////////////////////

/// Specific data ////////////////////////

pixout BlurDirectionalPS(vtxOut IN)
{
  pixout OUT;


	float2 tcJitter = 1;//(tex2D(_tex1, IN.baseTC.xy * (PS_ScreenSize.xy/64.0) )*2-1)*0.03 + 0.985;

	float4 cAcc = half4(GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + tcJitter * texToTexParams0.xy).rgb,1);// * 0.1h;
	cAcc += half4(GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + tcJitter * texToTexParams0.zw).rgb,1);// * 0.2h;

	cAcc += half4(GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + tcJitter * texToTexParams1.xy).rgb,1);// * 0.3h;
	cAcc += half4(GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + tcJitter * texToTexParams1.zw).rgb,1);// * 0.5h;

	cAcc += half4(GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy).rgb,1);// * 0.5h;

	cAcc += half4(GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + tcJitter * texToTexParams2.xy).rgb,1);// * 0.5h;
	cAcc += half4(GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + tcJitter * texToTexParams2.zw).rgb,1);// * 0.3h;

	cAcc += half4(GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + tcJitter * texToTexParams3.xy).rgb,1);// * 0.2h;
	cAcc += half4(GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy + tcJitter * texToTexParams3.zw).rgb,1);// * 0.1h;

	// normalize
	cAcc /= cAcc.w; //0.125h;//0.4545h;

	OUT.Color = cAcc;
  
	return OUT;
}

technique BlurDirectional
{
  pass p0
  {
    VertexShader = BaseVS();
    PixelShader = BlurDirectionalPS();    
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Vertical Blur technique (used for ocean "anisotropic" reflections aproximation) ////////////////

float4 blurParams0;

Texture2D verticalBlurTex : register(t0);
SamplerState verticalBlurSampler : register(s0);

///////////////// pixel shader //////////////////
pixout AnisotropicVerticalBlurPS(vtxOut IN)
{
	pixout OUT;

	float4 canis = verticalBlurTex.SampleLevel(verticalBlurSampler, IN.baseTC.xy + (float2(0.0f, blurParams0.x) * 0.125f * 0.75f), 0.0f);
	canis += verticalBlurTex.SampleLevel(verticalBlurSampler, IN.baseTC.xy + (float2(0.0f, blurParams0.y) * 0.125f * 0.75f), 0.0f);
	canis += verticalBlurTex.SampleLevel(verticalBlurSampler, IN.baseTC.xy + (float2(0.0f, blurParams0.z) * 0.125f * 0.75f), 0.0f);
	canis += verticalBlurTex.SampleLevel(verticalBlurSampler, IN.baseTC.xy + (float2(0.0f, blurParams0.w) * 0.125f * 0.75f), 0.0f);
	canis += verticalBlurTex.SampleLevel(verticalBlurSampler, IN.baseTC.xy - (float2(0.0f, blurParams0.x) * 0.75f), 0.0f);
	canis += verticalBlurTex.SampleLevel(verticalBlurSampler, IN.baseTC.xy - (float2(0.0f, blurParams0.y) * 0.75f), 0.0f);
	canis += verticalBlurTex.SampleLevel(verticalBlurSampler, IN.baseTC.xy - (float2(0.0f, blurParams0.z) * 0.75f), 0.0f);
	canis += verticalBlurTex.SampleLevel(verticalBlurSampler, IN.baseTC.xy - (float2(0.0f, blurParams0.w) * 0.75f), 0.0f);

	OUT.Color = canis / 8.0;

	return OUT;
}

////////////////// technique /////////////////////
technique AnisotropicVertical
{
	pass p0
	{
		VertexShader = FullscreenTriVS();
		PixelShader = AnisotropicVerticalBlurPS();
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Dilate technique for sprites ///////////////////////////////////////////////////////////////////

// todo: moving to outside post process, into specific shader

/// Specific data ////////////////////////

float4 vPixelOffset;			// PS 1/width,1/height,?,?
float4 vDilateParams;			// PS brightness_multiplier,?,?,?

///////////////// vertex shader //////////////////

struct vtxInDilate
{
  IN_P
  IN_TBASE
  IN_C0
};

struct vtxOutDilate
{
  float4 HPosition  : SV_POSITION;
  float3 baseTC     : TEXCOORD0;    
};

vtxOutDilate DilateVS(vtxInDilate IN)
{
  vtxOutDilate OUT = (vtxOutDilate)0; 

  float4 vPos = IN.Position;
  OUT.HPosition = mul(CV_ViewProjMatr, vPos);    
  OUT.baseTC.xy = IN.baseTC.xy;
  OUT.baseTC.z = OUT.HPosition.x;

	OUT.baseTC.xy+=0.00001f;		// lookup more in the middle of the texel - fixes white spots on DX10

  return OUT;
}

///////////////// pixel shader //////////////////
pixout DilatePS(vtxOutDilate IN)
{
  pixout OUT;

	const half2 Kernel_Neighbors[8+12] = 
	{
		half2(-1.0f,0.0f),
		half2(1.0f,0.0f),
		half2(0.0f,-1.0f),
		half2(0.0f,1.0f),

		half2(-1.0f,-1.0f),
		half2(-1.0f,1.0f),
		half2(1.0f,-1.0f),
		half2(1.0f,1.0f),

		half2(-2.0f,0.0f),
		half2(2.0f,0.0f),
		half2(0.0f,-2.0f),
		half2(0.0f,2.0f),

		half2(-2.0f,1.0f),
		half2(2.0f,1.0f),
		half2(1.0f,-2.0f),
		half2(1.0f,2.0f),

		half2(-2.0f,-1.0f),
		half2(2.0f,-1.0f),
		half2(-1.0f,-2.0f),
		half2(-1.0f,2.0f)
	};

	half4 cColor = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy);		// sun contribution

	int iSampleCount=8;

  if( GetShaderQuality() > QUALITY_LOW )
  	iSampleCount=8+12;

	// our alpha is 0 so we're not part of the tree
	if(cColor.a < 1.0/256.0)
	{
		half4 sum = 0.0h.xxxx;
		half count=0.001h;		//  0.001 to avoid division by zero

  [unroll]
		// average all the samples nearby that ARE part of the tree, and steal that colour for filtering
		for(int i=0;i<iSampleCount;i++)	
		{
			float2 vLocalOffset = IN.baseTC.xy+Kernel_Neighbors[i].xy*vPixelOffset.xy;
			half4 cVal = GetTexture2D(GaussB_Source, GaussB_Sampler, vLocalOffset);		// sun contribution
			
			if(cVal.a > cColor.a)
			{
				sum += cVal;
				count += 1.0h;
			}
		}
		
		cColor.rgb = sum.rgb/count;
	}

	OUT.Color = cColor;

	const half SpriteAlphaRef=0; // 1.0h/255.0h;

	half ref = cColor.a > SpriteAlphaRef ? 1.0h : 0.0h;
	
	OUT.Color.a = ref*cColor.a;

  return OUT;
}

pixout Dilate2PS(vtxOutDilate IN)
{
  pixout OUT;

  float4 cBase0 = GetTexture2D(GaussB_Source, GaussB_Sampler, IN.baseTC.xy);		                  // sun contribution
	
  OUT.Color = cBase0;
  
  return OUT;
}

////////////////// technique /////////////////////

technique Dilate
{
  pass p0
  {
    VertexShader = DilateVS() SpriteDilateVS;            
    PixelShader = DilatePS() SpriteDilatePS;
    CullMode = None;
  }
}

technique Dilate2
{
  pass p0
  {
    VertexShader = DilateVS() SpriteDilateVS;            
    PixelShader = Dilate2PS() SpriteDilatePS;
    CullMode = None;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Image blurring techniques //////////////////////////////////////////////////////////////////////

Texture2D blBlurredScreenScaledTex : register(t0);
Texture2D blScreenTex : register(t1);

SamplerState blPointClampSampler : register(s0) = SS_PointClamp;
SamplerState blLinearClampSampler : register(s1) = SS_TrilinearClamp;

pixout BlurInterpolationPS(vtxOut IN)
{
	pixout OUT;

	half4 screenColor = blScreenTex.SampleLevel( blPointClampSampler, IN.baseTC.xy, 0.0f );
	half4 blurredColor = blBlurredScreenScaledTex.SampleLevel( blLinearClampSampler, IN.baseTC.xy, 0.0f );

	OUT.Color = lerp(screenColor, blurredColor, psParams[0].w);

	return OUT;
}

////////////////// technique /////////////////////

technique BlurInterpolation
{
	pass p0
	{
		VertexShader = FullscreenTriVS();
		PixelShader = BlurInterpolationPS();
		CullMode = None;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Image sharpening via extrapolation + chromatic abberration

Texture2D shScreenTex : register(t0);
Texture2D shScreenScaledTex : register(t1);

SamplerState shPointClampSampler : register(s0) = SS_PointClamp;
SamplerState shLinearClampSampler : register(s1) = SS_TrilinearClamp;

pixout CA_SharpeningPS(vtxOut IN)
{
	pixout OUT;

	half4 screenColor = shScreenTex.SampleLevel( shPointClampSampler, IN.baseTC.xy, 0.0f );
	screenColor.r = shScreenTex.SampleLevel( shPointClampSampler, (IN.baseTC.xy - 0.5) * (1 + 2 * psParams[0].x * CV_ScreenSize.zw) + 0.5, 0.0f).r;
	screenColor.b = shScreenTex.SampleLevel( shPointClampSampler, (IN.baseTC.xy - 0.5) * (1 - 2 * psParams[0].x * CV_ScreenSize.zw) + 0.5, 0.0f).b;
	screenColor *= screenColor;

	half4 blurredColor = shScreenScaledTex.SampleLevel( shLinearClampSampler, IN.baseTC.xy, 0.0f );
	blurredColor *= blurredColor;
	OUT.Color = lerp(blurredColor, screenColor, psParams[0].w);

	OUT.Color = sqrt(OUT.Color);

	return OUT;
}

technique CA_Sharpening
{
	pass p0
	{
		VertexShader = FullscreenTriVS();
		PixelShader = CA_SharpeningPS();
		CullMode = None;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// UnderwaterGodRays technique /////////////////////////////////////////////////////////////////////////

float4 CausticParams		: PB_CausticsParams; // xy: caustics distance, zw: 1 / caustics distance
float4 CausticSmoothSunDir	: PB_CausticsSmoothSunDirection; 

float4 PB_GodRaysParamsVS;
float4 PB_GodRaysParamsPS;

Texture2D CausticsScreenTex : register(t0) = TS_BackBuffer;
Texture2D WavesTex : register(t1) = "%ENGINE%/EngineAssets/Textures/oceanwaves_ddn.tif";
Texture2D CausticsTex : register(t2) = "%ENGINE%/EngineAssets/Textures/caustics_sampler.dds";
Texture2D UnderwaterBumpTex : register(t1) = "%ENGINE%/EngineAssets/Textures/screen_noisy_bump.dds";
Texture2D ScreenScaledTex : register(t2) = TS_BackBufferScaled_d4;

SamplerState ugLinearClampSampler : register(s0) = SS_TrilinearClamp;
SamplerState ugTrilinearWrapSampler : register(s1) = SS_TrilinearWrap;

struct vtxOutGodRays
{
  float4 HPosition  : SV_POSITION; 
  float4 baseTC     : TEXCOORDN; // zw unused
  
  float4 waveTC      : TEXCOORDN;
  float4 causticTC0  : TEXCOORDN;
  float4 causticTC1  : TEXCOORDN;
  
  float4 vPosition : TEXCOORDN;  // w unused
};

vtxOutGodRays UnderwaterGodRaysVS(uint VertexID : SV_VertexID)
{
	vtxOutGodRays OUT = (vtxOutGodRays)0;

	// Position in screen space.
	float4 vPos;
	vPos.xy = GetHPos_FromTriVertexID(VertexID).xy;

	vPos.xy *= 1.2f; // hack: make sure to cover entire screen

	// Increase each slice distance
	vPos.z = 0.1 + 0.88 * saturate(PB_GodRaysParamsVS.z * PB_GodRaysParamsVS.w);
	vPos.w = 1;

#if %_RT_REVERSE_DEPTH
	vPos.z = vPos.w - vPos.z;
#endif

	// Project back to world space
	vPos = mul(CV_InvViewProj, vPos );
	vPos /= vPos.w;

	OUT.HPosition = mul(CV_ViewProjMatr, vPos);

	OUT.baseTC.xy = GetBaseTC_FromTriVertexID(VertexID);

	OUT.vPosition.xyz = vPos;
	OUT.vPosition.w = 1;

	// Generate projection matrix based on sun direction  
	float3 dirZ = CausticSmoothSunDir.xyz;
	float3 up = float3(0,0,1);
	float3 dirX = normalize(cross(up, dirZ));
	float3 dirY = normalize(cross(dirZ, dirX));

	float3x3 mLightView;
	mLightView[0] = dirX.xyz;
	mLightView[1] = dirY.xyz;
	mLightView[2] = dirZ.xyz;

	// Output caustics procedural texture generation 
	float2 uv = mul(mLightView, OUT.vPosition.xyz).xy * 0.5;

	// half tilling used to avoid annoying aliasing when swimming fast
	OUT.waveTC.xy =  uv * 2 * 0.01 * 0.012 + g_VS_AnimGenParams.w * 0.06;
	OUT.waveTC.wz =  uv * 2 * 0.01 * 0.01 + g_VS_AnimGenParams.w * 0.05;

	OUT.causticTC0.xy =  uv * 0.01 * 0.5 * 2+ g_VS_AnimGenParams.w * 0.1;
	OUT.causticTC0.wz =  uv.yx * 0.01 * 0.5 * 2- g_VS_AnimGenParams.w * 0.11;

	OUT.causticTC1.xy =  uv * 0.01 * 2.0 * 2+ g_VS_AnimGenParams.w * 0.1;
	OUT.causticTC1.wz =  uv.yx * 0.01 * 2.0 * 2- g_VS_AnimGenParams.w * 0.11;

	return OUT;
}

pixout UnderwaterGodRaysPS(vtxOutGodRays IN)
{
	pixout OUT;

	// temporary workaround for D3D11 hlsl compiler bug
	OUT.Color = CausticsScreenTex.SampleLevel(ugLinearClampSampler, IN.baseTC.xy, 0.0f);

	// break movement, with random patterns
	float2 wave = 0;
	wave  = GetXYNormalMap(WavesTex, ugTrilinearWrapSampler, IN.waveTC.xy);
	wave += GetXYNormalMap(WavesTex, ugTrilinearWrapSampler, IN.waveTC.wz);
	wave *= 0.02;

	half2 causticMapR = 0;
	causticMapR.xy   = GetXYNormalMap(WavesTex, ugTrilinearWrapSampler, IN.causticTC0.xy + wave);
	causticMapR.xy  += GetXYNormalMap(WavesTex, ugTrilinearWrapSampler, IN.causticTC0.wz + wave);

	half2 causticHighFreq = 0;
	causticHighFreq  = GetXYNormalMap(WavesTex, ugTrilinearWrapSampler, IN.causticTC1.xy + wave);
	causticHighFreq += GetXYNormalMap(WavesTex, ugTrilinearWrapSampler, IN.causticTC1.wz + wave);

	causticMapR.xy = causticMapR.xy * 0.5h + causticHighFreq;

	// Caustics sampler contains function: abs( 1-(abs( a) + abs(b))*0.5 ), which generates nice sharp pattern
	half3 cCaustic;
	cCaustic.x = CausticsTex.SampleLevel(ugLinearClampSampler, causticMapR.xy * 0.55 + 0.55, 0.0f).x;
	cCaustic.y = CausticsTex.SampleLevel(ugLinearClampSampler, causticMapR.xy * 0.525 + 0.525, 0.0f).x;
	cCaustic.z = CausticsTex.SampleLevel(ugLinearClampSampler, causticMapR.xy * 0.5 + 0.5, 0.0f).x;

	float slice_pos = PB_GodRaysParamsPS.z * PB_GodRaysParamsPS.w;

	// sharpen up a bit
	cCaustic *= cCaustic;

	// add very sharp highlight
	const half cMaxHightVis = 10.0;
	half fHighlightAtten =  1;//cMaxHightVis / (CausticParams.x - IN.vPosition.z);
	fHighlightAtten = saturate( fHighlightAtten ) * min( abs( fHighlightAtten ), 2);

	half fAtten = 1;// saturate( (CausticParams.x - IN.vPosition.z)*4 );

	cCaustic += pow( cCaustic, 8 );

	half4 cScreen =  CausticsScreenTex.SampleLevel(ugLinearClampSampler, IN.baseTC.xy, 0.0f);
	cScreen.xyz = cCaustic * PB_GodRaysParamsPS.w * PB_GodRaysParamsPS.y * 0.25; //saturate( CausticParams.y  )*

	half fDistToCam = length( CV_WorldViewPosition.xyz - IN.vPosition.xyz );

	fAtten *= ( slice_pos );

	cScreen.xyz *= fAtten * fHighlightAtten;

	OUT.Color = cScreen;

	return OUT;
}

pixout UnderwaterGodRaysFinalPS(vtxOut IN)
{
	pixout OUT;

	const float anim = frac(AnimGenParams * 0.01);
	half4 cBumpy = UnderwaterBumpTex.Sample(ugTrilinearWrapSampler, IN.baseTC.xy * 0.025 + anim ) * 2 - 1;
	cBumpy += UnderwaterBumpTex.Sample(ugTrilinearWrapSampler, IN.baseTC.yx * 0.033 - anim ) * 2 - 1;
	cBumpy.xyz = normalize( cBumpy ).xyz;

	half4 cScreen = CausticsScreenTex.SampleLevel(ugLinearClampSampler, IN.baseTC.xy + cBumpy.xy * 0.0125 * PB_GodRaysParamsPS.x, 0.0f);
	half4 cCaustics = ScreenScaledTex.SampleLevel(ugLinearClampSampler, IN.baseTC.xy + cBumpy.xy * 0.01, 0.0f);

	OUT.Color = cScreen + cCaustics;

	return OUT;
}

////////////////// technique /////////////////////

technique UnderwaterGodRays
{
	pass p0
	{
		VertexShader = UnderwaterGodRaysVS();
		PixelShader = UnderwaterGodRaysPS();
		CullMode = None;
	}
}

technique UnderwaterGodRaysFinal
{
	pass p0
	{
		VertexShader = FullscreenTriVS();
		PixelShader = UnderwaterGodRaysFinalPS();
		CullMode = None;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Water ripples simulation technique /////////////////////////////////////////////////////////////

Texture2D WaterRipplesTexture : register(t0);
SamplerState WaterRipplesSState : register(s0);

cbuffer CBWaterRipples : register(b0)
{
	struct
	{
		float4   params;
	} cbWaterRipples;
};


// deprecated
vtxOut WaterRipplesHitVS(vtxIn IN)
{
  vtxOut OUT = (vtxOut)0; 

  OUT.HPosition = float4(2.0 * IN.Position.x - 1.0, -2.0 * IN.Position.y + 1.0, 1.0, 1.0);
  OUT.baseTC.xy = IN.baseTC.xy;
  OUT.baseTC.z = IN.Position.z;  // ripple strength is passed in IN.Position.z

  return OUT;
}


pixout WaterRippleHitPS(vtxOut IN)
{
  pixout OUT = (pixout)0;
  
	half2 vPos = float2( IN.baseTC.xy * 2.0h - 1.0h  );  
	half fHit = sqrt( saturate( 1.0h - dot( vPos, vPos ) ) );
	OUT.Color = fHit * IN.baseTC.z; 

  return OUT;
}

pixout WaterRipplesPS(vtxOut IN)
{
	pixout OUT = (pixout)0;
  
#if %_RT_SAMPLE0
	float2 tcRipples = IN.baseTC.xy + cbWaterRipples.params.xy;
	OUT.Color = GetTexture2D(WaterRipplesTexture, WaterRipplesSState, tcRipples);
#else

	// Important note: z: frame T-1, w: frame T-2

	half4 h0  = GetTexture2D(WaterRipplesTexture, WaterRipplesSState, IN.baseTC.xy);

	half fTexSimSize = 256.0h;	
	half4 h00 = GetTexture2D(WaterRipplesTexture, WaterRipplesSState, IN.baseTC.xy + float2(-1.0/fTexSimSize, 0));
	half4 h10 = GetTexture2D(WaterRipplesTexture, WaterRipplesSState, IN.baseTC.xy + float2( 1.0/fTexSimSize, 0));
	half4 h01 = GetTexture2D(WaterRipplesTexture, WaterRipplesSState, IN.baseTC.xy + float2( 0,-1.0/fTexSimSize));
	half4 h11 = GetTexture2D(WaterRipplesTexture, WaterRipplesSState, IN.baseTC.xy + float2( 0, 1.0/fTexSimSize));	

	// Compute the acceleration of the point based upon its neighbors
	half fAcce = (h00.z + h10.z + h01.z + h11.z)*0.25 - h0.z;
  
	half dt = saturate( cbWaterRipples.params.z / 0.0333f );

	// verlet integration: x(i+1) = xi + (xi - x(i-1)) + a * dt*dt <=> 2 * xi - x(i-1) + a*dt*dt
	half3 vVerletWeights = half3(1.995h, 0.995h, 1.0h); //half3(1.95h, 1.0h, 1.0h);
	half cCurrHeight =( vVerletWeights.x * h0.z - vVerletWeights.y * h0.w + vVerletWeights.z * fAcce); //*dt*dt
	// dtsqr = waterRipplesParams.z * waterRipplesParams.z 
	 
	// vanila wave propagation
	//half cCurrHeight = (h00.z + h10.z + h01.z + h11.z)*0.5 - h0.w;
	//cCurrHeight -= cCurrHeight/32.0; ; // damping

	// todo: make it time independent - figure out good/stable solution.

	half fSimLimits = 1-saturate( dot(IN.baseTC.xy-0.5, IN.baseTC.xy-0.5) );
	
	// note: we swap zw channels for simulation double buffering (can skip aditional textures)
	OUT.Color.z = cCurrHeight;//*  fSimLimits;

	// store previous frame
	OUT.Color.w = h0.z;


	////////////////////////////////////////////////////////////////////////////////////
	// Finally compute wave normal
	//	- cheat: add yet another half texel offset for bilinear filtered fetch for smoother final normal
	half fHalfTexelOffset =0.5f /fTexSimSize;

	half4 hOrig = h0;

	h0 =  GetTexture2D(WaterRipplesTexture, WaterRipplesSState, IN.baseTC.xy + fHalfTexelOffset );
	h10 = GetTexture2D(WaterRipplesTexture, WaterRipplesSState, IN.baseTC.xy + float2( 1.0h/fTexSimSize, 0) + fHalfTexelOffset);
	h11 = GetTexture2D(WaterRipplesTexture, WaterRipplesSState, IN.baseTC.xy + float2( 0, 1.0h/fTexSimSize) + fHalfTexelOffset);

	half3 vWeights = half3(h0.w, h10.w, h11.w);
	half3 vNormal = half3( -(vWeights.x - vWeights.y), -(vWeights.x - vWeights.z), 0.05); 
	vNormal = normalize(vNormal.xyz);                                               
 
	OUT.Color.xy = vNormal.xy;
	
	half4 clampEdge = half4(0.0h, 0.0h, 0.0h, 0.0h);
	
	// Add 2 pixel border with no normals + flat heights (emulating clamp to border at earliest spot)
	OUT.Color.xyzw = (IN.baseTC.x< fHalfTexelOffset*4.0)? clampEdge.xyzw:OUT.Color.xyzw;
	OUT.Color.xyzw = (IN.baseTC.y< fHalfTexelOffset*4.0)? clampEdge.xyzw:OUT.Color.xyzw;
	OUT.Color.xyzw = (IN.baseTC.x> 1.0h - fHalfTexelOffset*4.0)? clampEdge.xyzw:OUT.Color.xyzw;
	OUT.Color.xyzw = (IN.baseTC.y> 1.0h - fHalfTexelOffset*4.0)? clampEdge.xyzw:OUT.Color.xyzw;
	
#endif

	return OUT;
}

////////////////// technique /////////////////////

technique WaterRipplesHit
{
  pass p0
  {
    VertexShader = WaterRipplesHitVS();
    PixelShader  = WaterRippleHitPS();    
  }
}

technique WaterRipplesGen
{
  pass p0
  {
    VertexShader = FullscreenTriVS() PostEffectsVS;
    PixelShader  = WaterRipplesPS()  PostEffectsPS;    
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
/// PostStereo technique /////////////////////////////////////////////////////////////////////////

Texture2D psScreenTex : register(t0);
Texture2D psDepthTex : register(t1);
Texture2D psNearMaskTex : register(t2);

SamplerState psLinearMirrorSampler : register(s0);
SamplerState psPointClampSampler : register(s1);

float4 StereoParams;
float4 HPosScale;

vtxOut StereoNearMaskVS(
	float4 Position : POSITION,
	uint VertexID : SV_VertexID)
{
	vtxOut OUT = (vtxOut)0;
	OUT.HPosition = GetHPos_FromTriVertexID(VertexID);
	OUT.baseTC.xy = GetBaseTC_FromTriVertexID(VertexID);
	OUT.HPosition.z = Position.z;
	return OUT;
}

struct _pixoutMRT
{
	half4 leftEye   : SV_Target0;
	half4 rightEye  : SV_Target1;
};

float GetStereoDepth( Texture2D depthTex, float2 ScreenTC )
{
	float linDepth = depthTex.SampleLevel(psPointClampSampler, ScreenTC.xy, 0.0f);
	
	bool isNear = psNearMaskTex.SampleLevel(psPointClampSampler, ScreenTC.xy, 0.0f).x > 0;
	
	return !isNear ? linDepth : linDepth * StereoParams.w + StereoParams.z;
}

_pixoutMRT PostStereoPS(vtxOut IN)
{
	// Screen Space Reprojection Stereo Approach

	_pixoutMRT OUT = (_pixoutMRT) 0;

	float minDepthL = 1;
	float minDepthR = 1;

	const float samples[4] = { 0.5, 0.66, 1, 1.1 };
	float2 uv = float2( 0, 0 );

	const float2 TC = IN.baseTC.xy * HPosScale.xy;

	// Take several samples to avoid ghosting and reduce artifacts
	for( int i = 0; i < 4; ++i )
	{
		uv.x = samples[i] * StereoParams.x * HPosScale.x;

		minDepthL = min( minDepthL, GetStereoDepth( psDepthTex, TC + uv ) );
		minDepthR = min( minDepthR, GetStereoDepth( psDepthTex, TC - uv ) );
	}

	const float parallaxL = StereoParams.x * (1.0 - StereoParams.y / minDepthL);
	const float parallaxR = StereoParams.x * (1.0 - StereoParams.y / minDepthR);

	OUT.leftEye.xyz = psScreenTex.SampleLevel( psLinearMirrorSampler, IN.baseTC.xy + float2( parallaxL, 0 ), 0.0f );
	OUT.rightEye.xyz = psScreenTex.SampleLevel( psLinearMirrorSampler, IN.baseTC.xy - float2( parallaxR, 0 ), 0.0f );

	// Weapon mask
	OUT.leftEye.a = psNearMaskTex.SampleLevel( psPointClampSampler, IN.baseTC.xy + float2( parallaxL, 0 ), 0.0f ).x > 0 ? 0.0 : 1.0;
	OUT.rightEye.a = psNearMaskTex.SampleLevel( psPointClampSampler, IN.baseTC.xy - float2( parallaxR, 0 ), 0.0f ).x > 0 ? 0.0 : 1.0;

	return OUT;
}

pixout StereoNearMaskPS(vtxOut IN)
{
  return (pixout)0;
}

////////////////// technique /////////////////////

technique PostStereo
{
	pass p0
	{
		VertexShader = FullscreenTriVS();
		PixelShader = PostStereoPS();
		CullMode = None;
	}
}

technique StereoNearMask
{
	pass p0
	{
		VertexShader = StereoNearMaskVS();
		PixelShader = StereoNearMaskPS();
		CullMode = None;
	}
}

//////////////////////////// Selection Silhouettes and highlights /////////////

Texture2D<float4> SelSil_Source         : register(t0); 
SamplerState SelSil_Sampler             : register(s0);


struct vtxOutSilhouette
{
    float4 HPosition : SV_POSITION;
    float4 baseTC0 : TEXCOORD0;
    float4 baseTC1 : TEXCOORD1;
    float4 baseTC2 : TEXCOORD2;
};

float outlineWidth;

vtxOutSilhouette SelectionSilhouetteVS(uint VertexID : SV_VertexID)
{
    const half uvOffsetScale = outlineWidth;

    vtxOutSilhouette OUT = (vtxOutSilhouette) 0;
    OUT.HPosition = GetHPos_FromTriVertexID(VertexID);
	float2 baseTC = GetBaseTC_FromTriVertexID(VertexID);

    OUT.baseTC0.xy = baseTC;
 
    OUT.baseTC1.xy = baseTC + uvOffsetScale * float2(0, -1) * ScrSize.zw;
    OUT.baseTC1.zw = baseTC + uvOffsetScale * float2(0,  1) * ScrSize.zw;
    OUT.baseTC2.xy = baseTC + uvOffsetScale * float2(-1, 0) * ScrSize.zw;
    OUT.baseTC2.zw = baseTC + uvOffsetScale * float2( 1, 0) * ScrSize.zw;

    return OUT;
}

float4 highlightColor;
float4 selectionColor;
float ghostAlpha;

pixout SelectionSilhouettePS(vtxOutSilhouette IN)
{
// ID flags. Make sure those are synced between CommonDebugPass.cfi and IRenderNode
#define SELECTED_FLAG    (1)
#define HIGHLIGHTED_FLAG (1 << 1)
#define HIDDEN_FLAG      (1 << 2)

    // alpha for hidden highlights.
    const float fHiddenAlpha = ghostAlpha;

    pixout OUT = (pixout) 0;

    uint pixelInfo = asuint(GetTexture2D(SelSil_Source, SelSil_Sampler, IN.baseTC0).x);
    // IDs are stored in higher 24 bits
    uint pixelID = pixelInfo >> 8;

    bool bIsHighlighted = (pixelInfo & HIGHLIGHTED_FLAG) != 0;
    bool bIsSelected    = (pixelInfo & SELECTED_FLAG) != 0;
    bool bIsHidden      = (pixelInfo & HIDDEN_FLAG) != 0;

    uint4 edgesInfo = uint4(asuint(GetTexture2D(SelSil_Source, SelSil_Sampler, IN.baseTC1.xy).x),
                            asuint(GetTexture2D(SelSil_Source, SelSil_Sampler, IN.baseTC1.zw).x),
                            asuint(GetTexture2D(SelSil_Source, SelSil_Sampler, IN.baseTC2.xy).x),
                            asuint(GetTexture2D(SelSil_Source, SelSil_Sampler, IN.baseTC2.zw).x));

    uint4 edgeIDs =    (edgesInfo >> 8);
    bool4 vbDiffMask = (edgeIDs != pixelID);
    bool  bIsEdge =    any(vbDiffMask);

    // edges are high priority, do them first
    if (bIsEdge)
    {
        bool4 vbIsHigherID        = (edgeIDs > pixelID);
        bool4 vbIsHighlightedEdge = ((edgesInfo & HIGHLIGHTED_FLAG) != 0);
        bool4 vbIsSelectedEdge    = ((edgesInfo & SELECTED_FLAG) != 0);
        bool4 vbIsHiddenEdge      = ((edgesInfo & HIDDEN_FLAG) != 0);

        // highligh outlines get priority over all other drawing
        if (any(vbIsHighlightedEdge && vbDiffMask))
        {
            if (bIsHighlighted)
            {
                bool4 vbMask = vbIsHigherID && vbIsHighlightedEdge;

                // only draw on the side with the lower ID to avoid double outlines
                if (any(vbMask))
                {
                    OUT.Color = highlightColor;
                    // if any of the two sides is visible, we need to draw an opaque outline
                    OUT.Color.a = (any(vbMask && !vbIsHiddenEdge) || !bIsHidden) ? 1.0 : fHiddenAlpha;
                }
                else if (!bIsHidden)
                {
                    OUT.Color = highlightColor;
                }
            }
            else
            {
                OUT.Color = highlightColor;
                OUT.Color.a = (any(vbIsHiddenEdge && vbIsHighlightedEdge)) ? fHiddenAlpha : 1.0;
            }
        }
        // selected outlines get similar treatment to highlight outlines
        else if (any(vbIsSelectedEdge && vbDiffMask) && !bIsHighlighted)
        {
            if (bIsSelected)
            {
                bool4 vbMask = vbIsHigherID && vbIsSelectedEdge;

                // only draw on the side with the lower ID to avoid double outlines
                if (any(vbMask))
                {
                    OUT.Color = selectionColor;
                    // if any of the two sides is visible, we need to draw an opaque outline
                    OUT.Color.a = (any(vbMask && !vbIsHiddenEdge) || !bIsHidden) ? 1.0 : fHiddenAlpha;
                }
                else if (!bIsHidden)
                {
                    OUT.Color = selectionColor;
                }
            }
            else
            {
                OUT.Color = selectionColor;
                OUT.Color.a = (any(vbIsHiddenEdge && vbIsSelectedEdge)) ? fHiddenAlpha : 1.0;
            }
        }
        else if (bIsSelected)
        {
            if (!bIsHidden)
            {
                OUT.Color = selectionColor;
            }
        }
        // Finally account for highlighted objects
        else if (bIsHighlighted)
        {
            if (!bIsHidden)
            {
                OUT.Color = highlightColor;
            }
        }
    }
    // Selection coloring will get priority even for highlighted objects, so that we know they are also selected
    else if (bIsSelected)
    {
        if (!bIsHidden)
        {
            OUT.Color = selectionColor;
        }
    }
    // Finally account for highlighted objects
    else if (bIsHighlighted)
    {
        if (!bIsHidden)
        {
            OUT.Color = highlightColor;
        }
    }

    return OUT;
}

technique SelectionSilhouetteHighlight
{
    pass p0
    {
        VertexShader = SelectionSilhouetteVS();
        PixelShader = SelectionSilhouettePS();
    }
}

/////////////////////// eof ///
