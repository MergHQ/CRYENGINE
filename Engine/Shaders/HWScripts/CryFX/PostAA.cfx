// CRYENGINE Source Code File
// Copyright 2001-2015 Crytek GmbH. All rights reserved.

#include "Common.cfi"
#include "PostEffectsLib.cfi"
#include "ShadeLib.cfi"

// Shader global descriptions
float Script : STANDARDSGLOBAL
<
  string Script =
           "NoPreview;"
           "LocalConstants;"
           "ShaderDrawType = Custom;"
           "ShaderType = PostProcess;"
>; 

/// PostAA techniques /////////////////////////////////////////////////////////////////////////

/// Specific data ////////////////////////

float4x4 mViewProjPrev;
float4x4 mReprojection;
half4 vParams;

// parameters for batched techniques into same pass
half4 vLensOpticsParams;
half4 vDebugParams;
half4 PostAAParams;

////////////////// samplers /////////////////////

sampler2D colorChartMap : register(s8);

struct vtxOutAA
{
  OUT_HPOS_IN_WPOS

  float4 baseTC      : TEXCOORD0;
  float4 CamVec      : TEXCOORD1;
};

vtxOutAA PostAA_VS(vtxInWPOS IN)
{
  vtxOutAA OUT = (vtxOutAA)0; 

  float4 vPos = IN.Position;
  vPos.y = 1 -vPos.y;
	OUT.HPosition = float4(vPos.xy*2-1, vPos.z, 1.0);

  OUT.baseTC.xy = IN.baseTC.xy;
	OUT.baseTC.zw = 1.0 / g_VS_HPosScale.xy;
  OUT.CamVec.xyz = IN.CamVec;

  return OUT;
}

///////////////// pixel shader //////////////////
float4 sqr(float4 x)
{
	return x * x;
}

float IntersectAABB(float3 rayDir, float3 rayOrg, float3 boxExt)
{
	if (length(rayDir) < 1e-6) return 1;

	// Intersection using slabs
	float3 rcpDir = rcp(rayDir);
	float3 tNeg = ( boxExt - rayOrg) * rcpDir;
	float3 tPos = (-boxExt - rayOrg) * rcpDir;
	return max(max(min(tNeg.x, tPos.x), min(tNeg.y, tPos.y)), min(tNeg.z, tPos.z));
}

float ClipHistory(half3 cHistory, half3 cM, half3 cMin, half3 cMax)
{
	// Clip color difference against neighborhood min/max AABB
	// Clipped color is cHistory + rayDir * result
	
	float3 boxCenter = (cMax + cMin) * 0.5;
	float3 boxExtents = cMax - boxCenter;
	
	float3 rayDir = cM - cHistory;
	float3 rayOrg = cHistory - boxCenter;
	
	return saturate(IntersectAABB(rayDir, rayOrg, boxExtents));
}

float3 FilterHistory(sampler2D tex, float2 texcoord, float4 texSize)
{
	const float Sharpening = 0.0;  // [-0.5, 0.5]

	float2 samplePos = texcoord * texSize.xy;
	float2 tc1 = floor(samplePos - 0.5) + 0.5;
	float2 f = samplePos - tc1;
	float2 f2 = f * f;
	float2 f3 = f * f2;

	// Catmull-Rom weights
	const float c = 0.5 + Sharpening;
	float2 w0 = -(c)       * f3 + (2.0 * c)        * f2 - (c * f);
	float2 w1 =  (2.0 - c) * f3 - (3.0 - c)        * f2            + 1.0;
	float2 w2 = -(2.0 - c) * f3 + (3.0 -  2.0 * c) * f2 + (c * f);
	float2 w3 =  (c)       * f3 - (c)              * f2;

	float2 w12  = w1 + w2;
	float2 tc0  = (tc1 - 1.0)      * texSize.zw;
	float2 tc3  = (tc1 + 2.0)      * texSize.zw;
	float2 tc12 = (tc1 + w2 / w12) * texSize.zw;
	
	// Bicubic filter using bilinear lookups, skipping the 4 corner texels
	float4 filtered = float4(tex2D(tex, float2(tc12.x, tc0.y )).rgb, 1.0) * (w12.x *  w0.y) +
	                  float4(tex2D(tex, float2(tc0.x,  tc12.y)).rgb, 1.0) * ( w0.x * w12.y) +
	                  float4(tex2D(tex, float2(tc12.x, tc12.y)).rgb, 1.0) * (w12.x * w12.y) +  // Center pixel
	                  float4(tex2D(tex, float2(tc3.x,  tc12.y)).rgb, 1.0) * ( w3.x * w12.y) +
	                  float4(tex2D(tex, float2(tc12.x, tc3.y )).rgb, 1.0) * (w12.x *  w3.y);
	
	return filtered.rgb * rcp(filtered.a);
}

Texture2D<float4> PostAA_DepthTex : register(t16);

cbuffer CBPostAA : register(b0)
{
	struct TemporalAAConstants
	{
		float4x4 matReprojection;
		float4   params;
		float4   screenSize;
	} cbPostAA;
};

pixout PostAA_PS(vtxOutAA IN)
{
  pixout OUT = (pixout) 0;

	const float2 tc = IN.baseTC.xy;
	const float2 texel = cbPostAA.screenSize.zw;
	
	// Compute velocity vector for static geometry
	#if %_RT_PROJECTION_MULTI_RES || %_RT_PROJECTION_LENS_MATCHED
		float2 sourcePos = MapViewportToUnnormalizedRaster(tc);
		float depth = PostAA_DepthTex.Load(int3(sourcePos, 0));
		#if %_RT_PROJECTION_LENS_MATCHED
			// Correct for LMS warping
			depth = MapUnnormalizedRasterToClip(sourcePos, depth).z;
		#endif
	#else
		float depth = PostAA_DepthTex.Load(int3(IN.WPos.xy, 0));
		
		#if %_RT_SAMPLE3 || !%_RT_SAMPLE2
			// Dilate depth to improve moving silhouette edges
			float depth1 = PostAA_DepthTex.Load(int3(IN.WPos.xy + int2(-1, -1), 0));
			float depth2 = PostAA_DepthTex.Load(int3(IN.WPos.xy + int2( 1, -1), 0));
			float depth3 = PostAA_DepthTex.Load(int3(IN.WPos.xy + int2(-1,  1), 0));
			float depth4 = PostAA_DepthTex.Load(int3(IN.WPos.xy + int2( 1,  1), 0));
			depth = max(max(max(max(depth1, depth2), depth3), depth4), depth);
		#endif
	#endif

	float4 vPosHPrev = mul(float4(IN.baseTC.x, IN.baseTC.y, depth, 1.0), cbPostAA.matReprojection);
	vPosHPrev.xy /= vPosHPrev.w;
	
	float2 v = vPosHPrev.xy - tc;
	
	float2 multiresTC = MapViewportToRaster(tc);

	float2 vObj = tex2D(_tex3, multiresTC);
	if (vObj.x != 0)
	{
		v = DecodeMotionVector(vObj);
		multiresTC += v;
		float2 prevTC = MapRasterToViewport(multiresTC);
		v = prevTC - tc;
	}

#if %_RT_SAMPLE3
	// TSAA
	
	half3 cCenter	= tex2D(_tex4, tc);
	half3 cN1 = tex2D(_tex4, tc + texel * float2(-1.05f, -1.05f));
	half3 cN2 = tex2D(_tex4, tc + texel * float2( 1.05f, -1.05f));
	half3 cN3 = tex2D(_tex4, tc + texel * float2(-1.05f,  1.05f));
	half3 cN4 = tex2D(_tex4, tc + texel * float2( 1.05f,  1.05f));
	
	half3 cN5 = tex2D(_tex4, tc + texel * float2(-1.0f,  0.0f));
	half3 cN6 = tex2D(_tex4, tc + texel * float2( 1.0f,  0.0f));
	half3 cN7 = tex2D(_tex4, tc + texel * float2( 0.0f, -1.0f));
	half3 cN8 = tex2D(_tex4, tc + texel * float2( 0.0f,  1.0f));
	
	// Compute color variance
	half3 m1 = cN1 + cN2 + cN3 + cN4 + cN5 + cN6 + cN7 + cN8 + cCenter;
	half3 m2 = cN1*cN1 + cN2*cN2 + cN3*cN3 + cN4*cN4 + cN5*cN5 + cN6*cN6 + cN7*cN7 + cN8*cN8 + cCenter*cCenter;
	half3 mean = m1 / 9;
	half3 stddev = sqrt(m2 / 9 - mean * mean);
	half3 cMin = mean - 1.0 * stddev;
	half3 cMax = mean + 1.0 * stddev;
	
	half4 cHistory = tex2D(_tex5, tc + v);
	cHistory.rgb = FilterHistory(_tex5, tc + v, cbPostAA.screenSize);
	
	bool offscreen = max(abs((tc.x + v.x) * 2 - 1), abs((tc.y + v.y) * 2 - 1)) >= 1.0;
	float clipLength = 1;
	float neighborDiff = 0;
	
	half4 prevTL = 0, prevTR = 0, prevBL = 0, prevBR = 0;
	half4 prevTT = 0, prevBB = 0, prevLL = 0, prevRR = 0;
	
	[branch] if (!offscreen)
	{
		clipLength = ClipHistory(cHistory.rgb, cCenter, cMin, cMax);
	
		// Try to identify subpixel changes
		prevTL = tex2Dlod(_tex5, float4(tc + v + texel * float2(-1.0f, -1.0f), 0, 0));
		prevTR = tex2Dlod(_tex5, float4(tc + v + texel * float2( 1.0f, -1.0f), 0, 0));
		prevBL = tex2Dlod(_tex5, float4(tc + v + texel * float2(-1.0f,  1.0f), 0, 0));
		prevBR = tex2Dlod(_tex5, float4(tc + v + texel * float2( 1.0f,  1.0f), 0, 0));
		
		prevTT = tex2Dlod(_tex5, float4(tc + v + texel * float2( 0.0f, -1.0f), 0, 0));
		prevBB = tex2Dlod(_tex5, float4(tc + v + texel * float2( 0.0f,  1.0f), 0, 0));
		prevLL = tex2Dlod(_tex5, float4(tc + v + texel * float2(-1.0f,  0.0f), 0, 0));
		prevRR = tex2Dlod(_tex5, float4(tc + v + texel * float2( 1.0f,  0.0f), 0, 0));
		
		float neighborDiff1 = length(clamp(prevTL.rgb, cMin, cMax) - prevTL.rgb) + length(clamp(prevTR.rgb, cMin, cMax) - prevTR.rgb) +
												  length(clamp(prevBL.rgb, cMin, cMax) - prevBL.rgb) + length(clamp(prevBR.rgb, cMin, cMax) - prevBR.rgb);
		float neighborDiff2 = length(clamp(prevTT.rgb, cMin, cMax) - prevTT.rgb) + length(clamp(prevBB.rgb, cMin, cMax) - prevBB.rgb) +
												  length(clamp(prevLL.rgb, cMin, cMax) - prevLL.rgb) + length(clamp(prevRR.rgb, cMin, cMax) - prevRR.rgb);							 
		
		neighborDiff = min(neighborDiff1, neighborDiff2);
		if (neighborDiff < cbPostAA.params.x) clipLength = 0;
	}
	
	// Apply color clipping
	cHistory.rgb = lerp(cHistory.rgb, cCenter, clipLength);
	
	half prevBlend = (cHistory.w + prevTL.w + prevTR.w + prevBL.w + prevBR.w + prevTT.w + prevBB.w + prevLL.w + prevRR.w) / 9.0;
	half currBlend = saturate(neighborDiff * 10) * 0.10 + prevBlend * 0.90;
	const float weight = lerp(0.25, 0.08, saturate(currBlend * cbPostAA.params.y));
	OUT.Color.rgb = cCenter * weight + cHistory.rgb * (1 - weight);
	OUT.Color.a = currBlend;
	
#elif %_RT_SAMPLE2
	// SMAA 1TX Mode
	float fMaxFramesL = cbPostAA.params.z;		// Frames to keep in history (low freq). Higher = less aliasing, but blurier result. Lower = sharper result, but more aliasing.
	float fMaxFramesH = cbPostAA.params.w;		// Frames to keep in history (high freq). Higher = less aliasing, but blurier result. Lower = sharper result, but more aliasing.
	
 	// Curr frame and neighbor texels
	half3 cM	= sqr(tex2D(_tex0, tc));
	half3 cTL = sqr(tex2D(_tex0, tc + texel * float2(-0.5f, -0.5f)));
	half3 cTR = sqr(tex2D(_tex0, tc + texel * float2( 0.5f, -0.5f)));
	half3 cBL = sqr(tex2D(_tex0, tc + texel * float2(-0.5f,  0.5f)));
	half3 cBR = sqr(tex2D(_tex0, tc + texel * float2( 0.5f,  0.5f)));
	
	half3 cBlur = (cTL + cTR + cBL + cBR) * 0.25f;
	cM.rgb = saturate( lerp(cBlur, cM, cbPostAA.params.x) );
		
	half3 cMin = min(min(min(min(cTL, cTR), cBL), cBR), cM);
	half3 cMax = max(max(max(max(cTL, cTR), cBL), cBR), cM);	
	
	float3 cAcc = sqr(tex2D(_tex1, (tc * IN.baseTC.zw) + v));	
	cAcc.rgb = clamp((cAcc), cMin, cMax); // Limit acc buffer color range to current frame
	
	half3 cHiFreq = sqrt(abs( cBlur.rgb - cM.rgb));
	OUT.Color.rgb = sqrt( lerp(cAcc, cM, saturate(rcp(lerp(fMaxFramesL, fMaxFramesH, cHiFreq))) ) );
	OUT.Color.a = 1-saturate(rcp(lerp(fMaxFramesL, fMaxFramesH, cHiFreq))); // debug output

#else
	// New SMAA 2TX Mode
	
	// Curr frame and neighbor texels
	half3 cM	= tex2D(_tex4, tc);
	half3 cTL = tex2D(_tex4, tc + texel * float2(-1.0f, -1.0f));
	half3 cTR = tex2D(_tex4, tc + texel * float2( 1.0f, -1.0f));
	half3 cBL = tex2D(_tex4, tc + texel * float2(-1.0f,  1.0f));
	half3 cBR = tex2D(_tex4, tc + texel * float2( 1.0f,  1.0f));
	
	half3 cMin = min(min(min(min(cTL, cTR), cBL), cBR), cM);
	half3 cMax = max(max(max(max(cTL, cTR), cBL), cBR), cM);
	
	half3 cHistory = tex2D(_tex5, tc + v);	
	
	bool offscreen = max( abs((tc.x + v.x)*2 - 1), abs((tc.y + v.y)*2 - 1) ) >= 1.0;
	float clipLength = 1;
	
	[branch] if (!offscreen)
	{
		clipLength = ClipHistory(cHistory, cM, cMin, cMax);
	
		// Try to identify subpixel changes
		half3 prevTL = tex2Dlod( _tex5, float4(tc + v + texel * float2(-1.0f, -1.0f), 0, 0) );
		half3 prevTR = tex2Dlod( _tex5, float4(tc + v + texel * float2( 1.0f, -1.0f), 0, 0) );
		half3 prevBL = tex2Dlod( _tex5, float4(tc + v + texel * float2(-1.0f,  1.0f), 0, 0) );
		half3 prevBR = tex2Dlod( _tex5, float4(tc + v + texel * float2( 1.0f,  1.0f), 0, 0) );
		
		float neighborDiff = length(clamp(prevTL, cMin, cMax) - prevTL) + length(clamp(prevTR, cMin, cMax) - prevTR) +
												 length(clamp(prevBL, cMin, cMax) - prevBL) + length(clamp(prevBR, cMin, cMax) - prevBR);
		
		if (neighborDiff < 0.02) clipLength = 0;
	}
	
	float blendAmount = saturate( length(cHistory - cM) * 10 );
	
	// Apply color clipping
	cHistory = lerp(cHistory, cM, clipLength);
	
	// Exponential moving average of current frame and history
	const float MaxFramesL = 2.5, MaxFramesH = 5;  // If too high, 8 bit sRGB precision not enough to converge
	OUT.Color.rgb = lerp( cHistory, cM, saturate(rcp(lerp(MaxFramesL, MaxFramesH, blendAmount))) );
#endif

  return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// SMAA

// medium quality
#define SMAA_THRESHOLD 0.1
#define SMAA_MAX_SEARCH_STEPS 8
#define SMAA_MAX_SEARCH_STEPS_DIAG 0
#define SMAA_CORNER_ROUNDING 0

// high quality
//#define SMAA_THRESHOLD 0.1
//#define SMAA_MAX_SEARCH_STEPS 16
//#define SMAA_MAX_SEARCH_STEPS_DIAG 8
//#define SMAA_CORNER_ROUNDING 25

#define SMAA_AREATEX_MAX_DISTANCE 16
#define SMAA_AREATEX_MAX_DISTANCE_DIAG 20

#define SMAA_AREATEX_SUBTEX_SIZE 0.1428571

#define SCALE_PIXELSIZE 2

pixout LumaEdgeDetectionSMAA_PS(vtxOut IN)
{
  pixout OUT = (pixout) 0;

	PS_ScreenSize.zw *= SCALE_PIXELSIZE * CV_HPosScale.xy;

  float2 threshold = SMAA_THRESHOLD;

  // Calculate lumas:
  float3 weights = float3(0.2126, 0.7152, 0.0722);
  float L = dot(tex2D(_tex0, IN.baseTC.xy).rgb, weights);
  float Lleft = dot(tex2D(_tex0, IN.baseTC.xy + float2(-1, 0) * PS_ScreenSize.zw).rgb, weights);
  float Ltop  = dot(tex2D(_tex0, IN.baseTC.xy + float2( 0, -1) * PS_ScreenSize.zw).rgb, weights);

  // We do the usual threshold:
  float4 delta;
  delta.xy = abs(L.xx - float2(Lleft, Ltop));
  float2 edges = step(threshold, delta.xy);

  // Then discard if there is no edge:
  if (dot(edges, 1.0) == 0.0)
      discard;// this supported on cg ? else clip(-1)

  // Calculate right and bottom deltas:
  float Lright = dot(tex2D(_tex0, IN.baseTC.xy + float2(1, 0) * PS_ScreenSize.zw).rgb, weights);
  float Lbottom  = dot(tex2D(_tex0, IN.baseTC.xy + float2(0, 1) * PS_ScreenSize.zw).rgb, weights);
  delta.zw = abs(L.xx - float2(Lright, Lbottom));

  // Calculate the maximum delta in the direct neighborhood:
  float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);

  // Calculate left-left and top-top deltas:
  float Lleftleft = dot(tex2D(_tex0, IN.baseTC.xy + float2(-2, 0) * PS_ScreenSize.zw).rgb, weights);
  float Ltoptop = dot(tex2D(_tex0, IN.baseTC.xy + float2(0, -2) * PS_ScreenSize.zw).rgb, weights);
  delta.zw = abs(float2(Lleft, Ltop) - float2(Lleftleft, Ltoptop));

  // Calculate the final maximum delta:
  maxDelta = max(max(maxDelta, delta.z), delta.w);
  edges.xy *= step(0.5 * maxDelta, delta.xy);

	OUT.Color = float4(edges, 0.0, 0.0);

	return OUT;
}

// Diagonal Search Functions

#if SMAA_MAX_SEARCH_STEPS_DIAG || SMAA_FORCE_DIAGONAL_DETECTION

// These functions allows to perform diagonal pattern searches. 
float SMAASearchDiag1(sampler2D edgesTex, float2 texcoord, float2 dir, float c)
{
  texcoord += dir * PS_ScreenSize.zw;
  float2 e = 0;
  float i = 0;
  for (i = 0; i < SMAA_MAX_SEARCH_STEPS_DIAG; i++) 
	{
      e.rg = tex2Dlod(edgesTex, float4(texcoord, 0, 0) ).rg;
      [flatten] if (dot(e, 1.0) < 1.9) break;
      texcoord += dir * PS_ScreenSize.zw;
  }
  return i + float(e.g > 0.9) * c;
}

float SMAASearchDiag2(sampler2D edgesTex, float2 texcoord, float2 dir, float c) 
{
  texcoord += dir * PS_ScreenSize.zw;
  float2 e = 0;
  float i = 0;
  for (i = 0; i < SMAA_MAX_SEARCH_STEPS_DIAG; i++) 
	{
      e.g = tex2Dlod(edgesTex, float4(texcoord, 0, 0)).g;
      e.r = tex2Dlod(edgesTex, float4(texcoord + float2(1, 0)* PS_ScreenSize.zw, 0, 0)).r;
      [flatten] if (dot(e, 1.0) < 1.9) break;
      texcoord += dir * PS_ScreenSize.zw;
  }
  return i + float(e.g > 0.9) * c;
}
 
float2 SMAAAreaDiag(sampler2D areaTex, float2 distance, float2 e, float offset) 
{
  float2 texcoord = SMAA_AREATEX_MAX_DISTANCE_DIAG * e + distance;

	float2 SMAA_AREATEX_PIXEL_SIZE = 1.0 / float2(160.0, 560.0);

  // We do a scale and bias for mapping to texel space:
  texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);

  // Diagonal areas are on the second half of the texture:
  texcoord.x += 0.5;

  // Move to proper place, according to the subpixel offset:
  texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

  return tex2Dlod(areaTex, float4(texcoord, 0, 0) ).rg;
}

//This searches for diagonal patterns and returns the corresponding weights.
float2 SMAACalculateDiagWeights(sampler2D edgesTex, sampler2D areaTex, float2 texcoord, float2 e, half4 subsampleIndices) 
{
    float2 weights = 0.0;

    float2 d;
    d.x = e.r? SMAASearchDiag1(edgesTex, texcoord, float2(-1.0,  1.0), 1.0) : 0.0;
    d.y = SMAASearchDiag1(edgesTex, texcoord, float2(1.0, -1.0), 0.0);

    [branch]
    if (d.r + d.g > 2)  // d.r + d.g + 1 > 3
		{ 
        float4 coords = mad(float4(-d.r, d.r, d.g, -d.g), PS_ScreenSize.zwzw, texcoord.xyxy);

        float4 c;
        c.x = tex2Dlod(edgesTex, float4(coords.xy + float2(-1,  0) * PS_ScreenSize.zw, 0, 0) ).g;
        c.y = tex2Dlod(edgesTex, float4(coords.xy + float2( 0,  0) * PS_ScreenSize.zw, 0, 0) ).r;
        c.z = tex2Dlod(edgesTex, float4(coords.zw + float2( 1,  0) * PS_ScreenSize.zw, 0, 0) ).g;
        c.w = tex2Dlod(edgesTex, float4(coords.zw + float2( 1, -1) * PS_ScreenSize.zw, 0, 0) ).r;
        float2 e = 2.0 * c.xz + c.yw;
        e *= step(d.rg, SMAA_MAX_SEARCH_STEPS_DIAG - 1);

        weights += SMAAAreaDiag(areaTex, d, e, subsampleIndices.z);
    }

    d.x = SMAASearchDiag2(edgesTex, texcoord, float2(-1.0, -1.0), 0.0);
    float right = tex2Dlod(edgesTex, float4(texcoord + float2(1, 0) * PS_ScreenSize.zw, 0, 0) ).r;
    d.y = right? SMAASearchDiag2(edgesTex, texcoord, float2(1.0, 1.0), 1.0) : 0.0;

    [branch]
    if (d.r + d.g > 2)  // d.r + d.g + 1 > 3
		{ 
        float4 coords = mad(float4(-d.r, -d.r, d.g, d.g), PS_ScreenSize.zwzw, texcoord.xyxy);

        float4 c;
        c.x  = tex2Dlod(edgesTex, float4(coords.xy + float2(-1,  0)* PS_ScreenSize.zw, 0, 0) ).g;
        c.y  = tex2Dlod(edgesTex, float4(coords.xy + float2( 0, -1)* PS_ScreenSize.zw, 0, 0) ).r;
        c.zw = tex2Dlod(edgesTex, float4(coords.zw + float2( 1,  0)* PS_ScreenSize.zw, 0, 0) ).gr;
        float2 e = 2.0 * c.xz + c.yw;
        e *= step(d.rg, SMAA_MAX_SEARCH_STEPS_DIAG - 1);

        weights += SMAAAreaDiag(areaTex, d, e, subsampleIndices.w).gr;
    }

    return weights;
}

#endif

// Horizontal/Vertical Search Functions
float SMAASearchLength(sampler2D searchTex, float2 e, float bias, float scale) 
{
  e.r = bias + e.r * scale;
  return 255.0 * tex2Dlod(searchTex, float4(e, 0, 0)).r;//r;
}

float SMAASearchXLeft(sampler2D edgesTex, sampler2D searchTex, float2 texcoord, float end) 
{   
  float2 e = float2(0.0, 1.0);
  while (texcoord.x > end && 
         e.g > 0.8281 && // Is there some edge not activated?
         e.r == 0.0) { // Or is there a crossing edge that breaks the line?
      e = tex2Dlod(edgesTex, float4(texcoord, 0, 0)).rg;
      texcoord -= float2(2.0, 0.0) * PS_ScreenSize.zw;
  }

  // We correct the previous (-0.25, -0.125) offset we applied:
  texcoord.x += 0.25 * PS_ScreenSize.z;

  // The searches are bias by 1, so adjust the coords accordingly:
  texcoord.x += PS_ScreenSize.z;

  // Disambiguate the length added by the last step:
  texcoord.x += 2.0 * PS_ScreenSize.z; // Undo last step
  texcoord.x -= PS_ScreenSize.z * SMAASearchLength(searchTex, e, 0.0, 0.5);

  return texcoord.x;
}

float SMAASearchXRight(sampler2D edgesTex, sampler2D searchTex, float2 texcoord, float end) 
{
	//PS_ScreenSize.zw *= SCALE_PIXELSIZE;

  float2 e = float2(0.0, 1.0);
  while (texcoord.x < end && 
         e.g > 0.8281 && // Is there some edge not activated?
         e.r == 0.0) { // Or is there a crossing edge that breaks the line?
      e = tex2Dlod(edgesTex, float4(texcoord, 0, 0)).rg;
      texcoord += float2(2.0, 0.0) * PS_ScreenSize.zw;
  }

  texcoord.x -= 0.25 * PS_ScreenSize.z;
  texcoord.x -= PS_ScreenSize.z;
  texcoord.x -= 2.0 * PS_ScreenSize.z;
  texcoord.x += PS_ScreenSize.z * SMAASearchLength(searchTex, e, 0.5, 0.5);
  return texcoord.x;
}

float SMAASearchYUp(sampler2D edgesTex, sampler2D searchTex, float2 texcoord, float end)
{
  float2 e = float2(1.0, 0.0);
  while (texcoord.y > end && 
         e.r > 0.8281 && // Is there some edge not activated?
         e.g == 0.0) { // Or is there a crossing edge that breaks the line?
      e = tex2Dlod(edgesTex, float4(texcoord, 0, 0)).rg;
      texcoord -= float2(0.0, 2.0) * PS_ScreenSize.zw;
  }

  texcoord.y += 0.25 * PS_ScreenSize.w;
  texcoord.y += PS_ScreenSize.w;
  texcoord.y += 2.0 * PS_ScreenSize.w;
  texcoord.y -= PS_ScreenSize.w * SMAASearchLength(searchTex, e.gr, 0.0, 0.5);
  return texcoord.y;
}

float SMAASearchYDown(sampler2D edgesTex, sampler2D searchTex, float2 texcoord, float end) 
{
  float2 e = float2(1.0, 0.0);
  while (texcoord.y < end && 
         e.r > 0.8281 && // Is there some edge not activated?
         e.g == 0.0) { // Or is there a crossing edge that breaks the line?
      e = tex2Dlod(edgesTex, float4(texcoord, 0, 0)).rg;
      texcoord += float2(0.0, 2.0) * PS_ScreenSize.zw;
  }
  
  texcoord.y -= 0.25 * PS_ScreenSize.w;
  texcoord.y -= PS_ScreenSize.w;
  texcoord.y -= 2.0 * PS_ScreenSize.w;
  texcoord.y += PS_ScreenSize.w * SMAASearchLength(searchTex, e.gr, 0.5, 0.5);
  return texcoord.y;
}

//Ok, we have the distance and both crossing edges. So, what are the areas
//at each side of current edge? 
float2 SMAAArea(sampler2D areaTex, float2 distance, float e1, float e2, float offset) 
{
  // Rounding prevents precision errors of bilinear filtering:
  float2 texcoord = SMAA_AREATEX_MAX_DISTANCE * round(4.0 * float2(e1, e2)) + distance;
  
	float2 SMAA_AREATEX_PIXEL_SIZE = 1.0 / float2(160.0, 560.0);

  // We do a scale and bias for mapping to texel space:
  texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);

  // Move to proper place, according to the subpixel offset:
  texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

  return tex2Dlod(areaTex, float4(texcoord, 0, 0)).rg;
}

// Corner Detection Functions
void SMAADetectHorizontalCornerPattern(sampler2D edgesTex, inout float2 weights, float2 texcoord, float2 d) 
{
#if SMAA_CORNER_ROUNDING || SMAA_FORCE_CORNER_DETECTION

    float4 coords = mad(float4(d.x, 0.0, d.y, 0.0),
                        PS_ScreenSize.zwzw, texcoord.xyxy);
    float2 e;
    e.r = tex2Dlod(edgesTex, float4(coords.xy + float2(0.0,  1.0) * PS_ScreenSize.zw, 0, 0) ).r;
    bool left = abs(d.x) < abs(d.y);
    e.g = tex2Dlod(edgesTex, float4(coords.xy + float2(0.0, -2.0)* PS_ScreenSize.zw, 0, 0) ).r;
    if (left) 
			weights *= saturate(SMAA_CORNER_ROUNDING / 100.0 + 1.0 - e);

    e.r = tex2Dlod(edgesTex, float4(coords.zw + float2(1.0,  1.0)* PS_ScreenSize.zw, 0, 0) ).r;
    e.g = tex2Dlod(edgesTex, float4(coords.zw + float2(1.0, -2.0)* PS_ScreenSize.zw, 0, 0) ).r;
    if (!left) 
			weights *= saturate(SMAA_CORNER_ROUNDING / 100.0 + 1.0 - e);

#endif
}

void SMAADetectVerticalCornerPattern(sampler2D edgesTex, inout float2 weights, float2 texcoord, float2 d) 
{
#if SMAA_CORNER_ROUNDING || SMAA_FORCE_CORNER_DETECTION

    float4 coords = mad(float4(0.0, d.x, 0.0, d.y),
                        PS_ScreenSize.zwzw, texcoord.xyxy);
    float2 e;
    e.r = tex2Dlod(edgesTex, float4(coords.xy+float2( 1.0, 0.0)*PS_ScreenSize.zw, 0, 0) ).g;
    bool left = abs(d.x) < abs(d.y);
    e.g = tex2Dlod(edgesTex, float4(coords.xy+float2(-2.0, 0.0)*PS_ScreenSize.zw, 0, 0) ).g;
    if (left) 
			weights *= saturate(SMAA_CORNER_ROUNDING / 100.0 + 1.0 - e);

    e.r = tex2Dlod(edgesTex, float4(coords.zw+float2( 1.0, 1.0)*PS_ScreenSize.zw, 0, 0) ).g;
    e.g = tex2Dlod(edgesTex, float4(coords.zw+float2(-2.0, 1.0)*PS_ScreenSize.zw, 0, 0) ).g;
    if (!left) 
			weights *= saturate(SMAA_CORNER_ROUNDING / 100.0 + 1.0 - e);

#endif
}

// Second pass: Blending Weight Calculation
pixout BlendWeightSMAA_PS(vtxOut IN)
{
	pixout OUT = (pixout) 0;
	// tex0 = edgesTex
	// tex1 = areaTex
	// tex2 = searchTex

  float4 weights = 0.0;
	
	// todo prebake on vs
	PS_ScreenSize.zw *= SCALE_PIXELSIZE;

	float2 pixcoord = IN.baseTC.xy /PS_ScreenSize.zw;	
	float4 offset[3] =
	{
		float4(IN.baseTC.xyxy + float4(-0.25, -0.125,  1.25, -0.125) * PS_ScreenSize.zwzw),
		float4(IN.baseTC.xyxy + float4(-0.125, -0.25, -0.125,  1.25) * PS_ScreenSize.zwzw),
		float4(IN.baseTC.xyxy)
	};

	offset[2] = float4(offset[0].xz, offset[1].yw) + float4(-2, 2, -2, 2) * PS_ScreenSize.zzww * SMAA_MAX_SEARCH_STEPS;

  float2 e = tex2D(_tex0, IN.baseTC.xy).rg;
	const float4 vSubSampleIndices = 0;

  [branch]
  if (e.g > 0.0h) // Edge at north
	{ 
      #if SMAA_MAX_SEARCH_STEPS_DIAG || SMAA_FORCE_DIAGONAL_DETECTION
      weights.rg = SMAACalculateDiagWeights(_tex0, _tex1, IN.baseTC.xy, e, vSubSampleIndices);

      // We give priority to diagonals, so if we find a diagonal we skip 
      // horizontal/vertical processing.
      [branch]
      if (dot(weights.rg, 1.0) == 0.0) {

      #endif

      float2 d;

      // Find the distance to the left:
      float2 coords;
      coords.x = SMAASearchXLeft(_tex0, _tex2, offset[0].xy, offset[2].x);
      coords.y = offset[1].y;
      d.x = coords.x;

      // Now fetch the left crossing edges, two at a time using bilinear
      // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
      // discern what value each edge has:
      float e1 = tex2Dlod(_tex0, float4(coords, 0, 0)).r; //IN.baseTC.xy

      // Find the distance to the right:
      coords.x = SMAASearchXRight(_tex0, _tex2, offset[0].zw, offset[2].y);
      d.y = coords.x; //IN.baseTC.x;

      // We want the distances to be in pixel units (doing this here allow to
      // better interleave arithmetic and memory accesses):
      d = d / PS_ScreenSize.z - pixcoord.x;

      // SMAAArea below needs a sqrt, as the areas texture is compressed 
      // quadratically:
      float2 sqrt_d = sqrt(abs(d));

      // Fetch the right crossing edges:
      float e2 = tex2Dlod(_tex0, float4(coords + float2(1, 0) * PS_ScreenSize.zw, 0, 0)).r;; //IN.baseTC.xy

      // Ok, we know how this pattern looks like, now it is time for getting
      // the actual area:
      weights.rg = SMAAArea(_tex1, sqrt_d, e1, e2, vSubSampleIndices.y);

      // Fix corners:
      SMAADetectHorizontalCornerPattern(_tex0, weights.rg, IN.baseTC.xy, d); //texcoord

      #if SMAA_MAX_SEARCH_STEPS_DIAG || SMAA_FORCE_DIAGONAL_DETECTION

      } 
			else
			{
          e.r = 0.0; // Skip vertical processing.
			}

      #endif
  }

  [branch]
  if (e.r > 0.0f)		// Edge at west
	{ 
      float2 d;

      // Find the distance to the top:
      float2 coords;
      coords.y = SMAASearchYUp(_tex0, _tex2, offset[1].xy, offset[2].z);
      coords.x = offset[0].x;
      d.x = coords.y;

      // Fetch the top crossing edges:
      float e1 = tex2Dlod(_tex0, float4(coords, 0, 0)).g;

      // Find the distance to the bottom:
      coords.y = SMAASearchYDown(_tex0, _tex2, offset[1].zw, offset[2].w);
      d.y = coords.y;

      // We want the distances to be in pixel units:
      d = d / PS_ScreenSize.w - pixcoord.y;

      // SMAAArea below needs a sqrt, as the areas texture is compressed 
      // quadratically:
      float2 sqrt_d = sqrt(abs(d));

      // Fetch the bottom crossing edges:
      float e2 = tex2Dlod(_tex0, float4(coords + float2(0, 1)*PS_ScreenSize.zw, 0, 0)).g;

      // Get the area for this direction:
      weights.ba = SMAAArea(_tex1, sqrt_d, e1, e2, vSubSampleIndices.x);

      // Fix corners:
      SMAADetectVerticalCornerPattern(_tex0, weights.ba, IN.baseTC.xy, d);
  }

	OUT.Color = weights;//*10;

  return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

pixout NeighborhoodBlendingSMAA_PS(vtxOut IN)
{
	pixout OUT = (pixout) 0;

	PS_ScreenSize.zw *= SCALE_PIXELSIZE;;

  // Fetch the blending weights for current pixel:
  float4 topLeft = tex2D(_tex0, IN.baseTC.xy);
  float bottom = tex2D(_tex0, IN.baseTC.xy + float2(0, 1) * PS_ScreenSize.zw).g;
  float right = tex2D(_tex0,  IN.baseTC.xy + float2(1, 0) * PS_ScreenSize.zw).a;
  float4 a = float4(topLeft.r, bottom, topLeft.b, right);

  [branch]
  if (dot(a, 1.0) < 1e-5)
	{
		OUT.Color = tex2Dlod(_tex1, float4(IN.baseTC.xy, 0, 0));
    return OUT;
	}
  else 
	{
      float4 color = 0.0;

      // Up to 4 lines can be crossing a pixel (one through each edge). We
      // favor blending by choosing the line with the maximum weight for each
      // direction:
      float2 offset;
      offset.x = a.a > a.b? a.a : -a.b; // left vs. right 
      offset.y = a.g > a.r? a.g : -a.r; // top vs. bottom

      // Then we go in the direction that has the maximum weight:
      if (abs(offset.x) > abs(offset.y)) // horizontal vs. vertical
          offset.y = 0.0;
      else
          offset.x = 0.0;

      // Fetch the opposite color and lerp by hand:
      float4 C = tex2Dlod(_tex1, float4(IN.baseTC.xy, 0, 0));
      IN.baseTC.xy += sign(offset) * PS_ScreenSize.zw;
      float4 Cop = tex2Dlod(_tex1, float4(IN.baseTC.xy, 0, 0));
			
			// convert to linear
			C *= C;
			Cop *= Cop;

      float s = abs(offset.x) > abs(offset.y)? abs(offset.x) : abs(offset.y);
      OUT.Color = lerp(C, Cop, s);

			// convert back to gamma 2.0
			OUT.Color = sqrt( OUT.Color );

			return OUT;
  }

	return OUT;
}

////////////////// technique /////////////////////

technique PostAA
{
  pass p0
  {
    VertexShader = PostAA_VS() PostAA_VS;
    PixelShader = PostAA_PS() PostAA_PS;
    CullMode = None;        
  }
}

// SMAA

technique LumaEdgeDetectionSMAA
{
  pass p0
  {
    VertexShader = FullscreenTriVS();
    PixelShader = LumaEdgeDetectionSMAA_PS() PostAA_PS;
    CullMode = None;        
  }
}

technique BlendWeightSMAA
{
  pass p0
  {
    VertexShader = FullscreenTriVS();
    PixelShader = BlendWeightSMAA_PS() PostAA_PS;
    CullMode = None;        
  }
}

technique NeighborhoodBlendingSMAA
{
  pass p0
  {
    VertexShader = FullscreenTriVS() PostAA_VS;
    PixelShader = NeighborhoodBlendingSMAA_PS() PostAA_PS;
    CullMode = None;        
  }
}

//////////////////////// 
// Debug modes for MSAA

pixout MsaaDebugPS(vtxOut IN)
{
  pixout OUT = (pixout) 0;
  half4 c0 = tex2D(_tex0, IN.baseTC.xy).x; 
#if !%_RT_SAMPLE0
	clip(c0.x-0.5);
#endif
	OUT.Color = half4(c0.x, 0, 0, 1);
  return OUT;
}

technique MsaaDebug
{
  pass p0
  {
    VertexShader = FsQuadVS() PostAA_VS;
    PixelShader = MsaaDebugPS() PostAA_PS;
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

sampler3D filmGrainMap : register(s6);

float4 HDRParams;
float4 HDREyeAdaptation;
float Time = {PB_time};

// Grain technique was moved out of HDR post process, since TAA filters pixel sized noise out
void ApplyFilmGrain(inout half4 cScene, in half3 cColor, float4 baseTC)
{
	const float fSceneLum = tex2D(_tex7, baseTC).x;
	const half fSceneKey = 1.03h - 2.0h / (2.0h + log2(fSceneLum + 1.0));
	const half fExposure = clamp(fSceneKey / fSceneLum, HDREyeAdaptation.y, HDREyeAdaptation.z);

	// Film grain simulation
	half fFilmGrain = tex3D(filmGrainMap, float4(baseTC.xy * 4.0f * float2(PS_ScreenSize.x / PS_ScreenSize.y, 1.0f), Time * 3, 0)).x;
	fFilmGrain = lerp(0.5h, fFilmGrain, HDRParams.w);
	fFilmGrain = lerp(fFilmGrain, 0.5h, sqrt(fExposure));

	// Overlay blending
	cScene.xyz = step(0.5, cColor.xyz);
	cScene.xyz = lerp((cColor.xyz * fFilmGrain * 2.h), (1.h - (2.h * (1.h - cColor.xyz) * (1.h - fFilmGrain))), cScene.xyz);
}

pixout PostAAComposites_PS(vtxOut IN)
{
  pixout OUT = (pixout) 0;

	OUT.Color = tex2D(_tex0, IN.baseTC);
	
#if %_RT_SAMPLE2	
	// Apply sharpening
	half3 cTL = sqr(tex2D(_tex0, IN.baseTC + PS_ScreenSize.zw * 2 * float2(-0.5, -0.5)));
	half3 cTR = sqr(tex2D(_tex0, IN.baseTC + PS_ScreenSize.zw * 2 * float2( 0.5, -0.5)));
	half3 cBL = sqr(tex2D(_tex0, IN.baseTC + PS_ScreenSize.zw * 2 * float2(-0.5,  0.5)));
	half3 cBR = sqr(tex2D(_tex0, IN.baseTC + PS_ScreenSize.zw * 2 * float2( 0.5,  0.5)));
	half3 cFiltered = (cTL + cTR + cBL + cBR) * 0.25h;
	OUT.Color.rgb = sqrt( saturate(lerp( cFiltered, OUT.Color.rgb * OUT.Color.rgb, vParams.x )) );
#endif

#if %_RT_SAMPLE2	
	OUT.Color.rgb = LinearToSRGB(OUT.Color.rgb);
#endif
	
	ApplyFilmGrain(OUT.Color, OUT.Color, IN.baseTC);

	// Apply lens composite
#if %_RT_SAMPLE1
	half4 cLensOpticsComposite = tex2D(_tex5, IN.baseTC.xy);
	#if %_RT_SAMPLE3
		half2 vTexelSize = 2.0h * PS_ScreenSize.zw * vLensOpticsParams.w;
		cLensOpticsComposite.r = tex2D(_tex5, (IN.baseTC.xy-0.5) * (1 + vTexelSize)+ 0.5).r;
	#endif
		float3 cLensOptics = cLensOpticsComposite * (1 - OUT.Color.rgb);// should blend in linear space, but increases cost further
	#if %_RT_SAMPLE5
		TexColorChart2D(colorChartMap, cLensOptics.rgb);
	#endif
	OUT.Color.rgb += cLensOptics;
#endif
		
	// Range rescaling
#if %_RT_SAMPLE4
	OUT.Color.xyz = (16.0/255.0) + OUT.Color.xyz * ((235.0 - 16.0) / 255.0);
#endif

	return OUT;
}

technique PostAAComposites
{
  pass p0
  {
    VertexShader = FullscreenTriVS();
    PixelShader = PostAAComposites_PS() PostAA_PS;
    CullMode = None;        
  }
}

pixout DebugPostAA_PS(vtxOutAA IN)
{
  pixout OUT = (pixout) 0;
	vDebugParams.xy = clamp(vDebugParams.xy, 0, PS_ScreenSize.xy);
	OUT.Color = tex2D(_tex0, IN.WPos.xy * PS_ScreenSize.zw * 2.0); 
	
	const float2 tcZoomed = ((IN.WPos.xy - vDebugParams.xy) * rcp(vDebugParams.w) + vDebugParams.xy) * PS_ScreenSize.zw * 2.0;	
	const float2 vArea = (IN.WPos.xy-(vDebugParams.xy - PS_ScreenSize.xy * 0.25 ));	
	const float2 vZoomedArea = (vArea > 0 && vArea < PS_ScreenSize.xy * 0.5) ? float2(1,1) : float2(0,0);
	const float2 vBorder = (((vArea.xy >= 0 && vArea.xy < 1) || (vArea.xy >= PS_ScreenSize.xy*0.5-1 && vArea.xy < PS_ScreenSize.xy*0.5)) && vArea.yx > 0 && vArea.yx < PS_ScreenSize.yx*0.5) ? float2(1,1) : float2(0,0);

	OUT.Color = lerp(OUT.Color, tex2D(_tex0, tcZoomed), min(vZoomedArea.x, vZoomedArea.y));		
	OUT.Color = max(OUT.Color, max(vBorder.x, vBorder.y));

  return OUT;
}

technique DebugPostAA
{
  pass p0
  {
    VertexShader = PostAA_VS() PostAA_VS;
    PixelShader = DebugPostAA_PS() PostAA_PS;
    CullMode = None;        
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

SamplerState subsampledSS : register(s0) = SS_BilinearClamp;
Texture2D subsampledTex : register(t0);

pixout UpscaleImagePS(vtxOut IN)
{
	// vParams.xy: source width, source height
	float2 texCoords = IN.baseTC.xy * vParams.xy + 0.5f;
	float2 intPart = floor(texCoords);
	float2 f = texCoords - intPart;

	// Apply smoothstep function to get a mixture between nearest neighbor and linear filtering
	f = f * f * (3 - 2 * f);

	texCoords = intPart + f;
	texCoords = (texCoords - 0.5) / vParams.xy;

	return (pixout)subsampledTex.Sample(subsampledSS, texCoords);
}

technique UpscaleImage
{
	pass p0
	{
		VertexShader = BaseVS();
		PixelShader = UpscaleImagePS() PostAA_PS;
	}
}
