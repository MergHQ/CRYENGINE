// Copyright 2001-2018 Crytek GmbH / Crytek Group. All rights reserved.

DISSOLVE_NOISE_MAP

//////////////////////////////////////////////////////////////////////////////////////////////////

struct OutputVS
{
	float4 HPosition : SV_POSITION;

	float4 baseTC    : TEXCOORDN;   // zw = orig tc

#if %_RT_ANIM_BLEND || %_RT_PARTICLE_SHADOW
	float4 blendTC   : TEXCOORDN; // w: sun shadow
#endif

	half4 alphaClip  : TEXCOORDN;

#if (FEATURE_PARTICLES_TESSELLATION && !%_RT_NO_TESSELLATION) || %BUMP_MAP || USE_MATERIAL
	half4 vWorldPos  : TEXCOORDN;
#endif
#if USE_MATERIAL
	half4 vTangent   : TEXCOORDN;
#endif

#if !%REFRACTION
	#if %_RT_FOG
		half4 localFogColor : TEXCOORDN;
	#endif
#endif

	half4 vNormal  : TEXCOORDN;
	half4 cColor : TEXCOORDN;
	half4 lightData0 : TEXCOORDN;
	half4 lightData1 : TEXCOORDN;
};

struct pixoutParticle
{
	half4 Color        : SV_Target0;

#if %DEPTH_FIXUP
	half4 BlendFactors : SV_Target1;
#endif
};

//////////////////////////////////////////////////////////////////////////////////////////////////

void ParticlesDebugVertex(inout SParticleVertex OUT, float4 debugColor)
{
#if %_RT_DEBUG0
	OUT.Color = lerp(debugColor, float4(0.35, 0.35, 0.35, 1), saturate(OUT.HPosition.w / 100.0));
#endif
}

bool ParticlesDebugPixel(inout pixoutParticle OUT, OutputVS IN)
{
#if %_RT_DEBUG0
	[branch]
	if (CP_Custom_ViewMode.x == 0)  // Wireframe
	{
		OUT.Color = IN.cColor;
	}
	else if (CP_Custom_ViewMode.x == 1)  // Texel density
	{
		float2 diffuseTexRes = 0;
		diffuseTex.GetDimensions(diffuseTexRes.x, diffuseTexRes.y);

		float3 ddx_P = ddx(IN.vWorldPos.xyz);
		float3 ddy_P = ddy(IN.vWorldPos.xyz);
		float2 ddx_T = ddx(IN.baseTC.xy);
		float2 ddy_T = ddy(IN.baseTC.xy);

		float tx = length(ddx_T) / length(ddx_P) * diffuseTexRes.x * 0.5 / CP_Custom_ViewMode.y;
		float ty = length(ddy_T) / length(ddy_P) * diffuseTexRes.y * 0.5 / CP_Custom_ViewMode.y;
		float t = max(tx, ty);

		float2 p = frac(IN.baseTC.xy * diffuseTexRes / 16.0); // 16x16 texels are a 2x2 checkerboard block
		float checker = p.x < 0.5 ? (p.y < 0.5 ? 0.9 : 1) : (p.y < 0.5 ? 1 : 0.9);

		// Sample diffuse tex so texture modificator in VS gets properly applied
		// Multiply by very small number and use result so compiler doesn't optimize tex fetch away
		float3 c = GetDiffuseTex(diffuseTex, IN.baseTC.xy) * 0.0001;
		c += GetTexture2D(dissolveNoiseTex, ssMaterialBilinearClamp, float2(t, 0.25));

		OUT.Color = float4(c * checker, 1);
	}
	return true;
#endif
	return false;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

void Particle_Convert_TC( float4 baseTC, inout SParticleVertex OUT )
{
	// Save original coords
	OUT.baseTC.zw = baseTC.xy;
	
	// Apply tiling params to TCs
	OUT.baseTC.xy = baseTC.xy * particleParams.tileSize.xy;
	
#if %_RT_ANIM_BLEND
	// Compute coords of 2nd blended tile
	OUT.blendTC.xy = OUT.baseTC.xy;
	float tileBlend = baseTC.z * 255.0 + 1.0;
	
	// Detect wrap to 1st frame when looping
	if (floor((tileBlend - particleParams.firstTile) / particleParams.frameCount) > floor((baseTC.z * 255.0 - particleParams.firstTile) / particleParams.frameCount))
		tileBlend -= particleParams.frameCount;
	float tileXBlend = tileBlend * particleParams.tileSize.x;
	OUT.blendTC.x += frac(tileXBlend);
	OUT.blendTC.y += floor(tileXBlend) * particleParams.tileSize.y;
	OUT.blendTC.z = baseTC.w;
#endif

	float tileX = baseTC.z * 255.0 * particleParams.tileSize.x;
	OUT.baseTC.x += frac(tileX);
	OUT.baseTC.y += floor(tileX) * particleParams.tileSize.y;
	OUT.baseTC.y *= particleParams.textureFrequency;
}

float GetShadowOccl(float3 worldPos)
{
	ShadowCascades shadowCascades;
	shadowCascades.shadowMap0 = texShadowMap0;
	shadowCascades.shadowMap1 = texShadowMap1;
	shadowCascades.shadowMap2 = texShadowMap2;
	shadowCascades.shadowMap3 = texShadowMap3;
	shadowCascades.cloudShadowTex = texCloudShadowMap;

	ShadowSamplingContext samplingContext;
	samplingContext.comparisonSampler = ssForwardComparison;
	samplingContext.pointSamplerWrap = ssPointWrap;
	samplingContext.pointSamplerClamp = ssPointClamp;
	samplingContext.bilinearSamplerWrap = ssForwardBilinearWrap;

	return ShadowDepthTest(GetShadowSamplingParams(), shadowCascades, samplingContext, worldPos, true, true);
}

//////////////////////////////////////////////////////////////////////////////////////////////////
SParticleVertex ParticleCommonVertexOutput(in float4 vPos, in app2vertParticleGeneral IN, in half4 vSSCenterMotion, const float4 debugColor)
{
	SParticleVertex OUT = (SParticleVertex)0;
	
#if %_RT_DEBUG0
	float3 vCenter = vPos.xyz;
#endif

#if %_RT_SOFT_PARTICLE
	// soft particle thickness in .w
	float fSoftScale = vPos.w;
	vPos.w = 1;
#endif

	Particle_Setup_General( vPos, IN, OUT);
	

	//////////////////////////////////////////////////////

	// Apply tiling params to tcs
	Particle_Convert_TC(IN.baseTC, OUT);

	OUT.Color = IN.Color;

	// Compute alpha clipping params from input alpha
	OUT.alphaClip.xyz = particleParams.alphaTestMin.xyz + particleParams.alphaTestMax.xyz * IN.Color.aaa;
	OUT.alphaClip.z = clamp(OUT.alphaClip.z, 0.001, 1 - OUT.alphaClip.y);
	OUT.alphaClip.x /= OUT.alphaClip.z;

#if FEATURE_PARTICLES_TESSELLATION && !%_RT_NO_TESSELLATION
	OUT.lightData0 = 0;
	OUT.lightData1 = half4(OUT.Color.rgb, particleParams.backLighting);		// Backlight ratio
#else	
	half shadowOccl = 1.0f;

	#if %_RT_PARTICLE_SHADOW
		shadowOccl = GetShadowOccl(OUT.vWorldPos.xyz);
		OUT.blendTC.w = shadowOccl;
	#endif

	const float backLightning = particleParams.backLighting;
	SParticleLightInfo lightInfo;
	ProjectLightVolume(OUT.vWorldPos.xyz, shadowOccl, backLightning, lightInfo);
	ToLightData(lightInfo, OUT.lightData0, OUT.lightData1);

#endif
#if %_RT_SOFT_PARTICLE
	// soft particle thickness in .w
	OUT.alphaClip.w = fSoftScale;
#endif

#if %_RT_FOG && !%REFRACTION
	const float3 camToWorld = vPos.xyz - GetWorldViewPos();
	OUT.localFogColor = Fwd_GetLocalFogColor(vPos.xyz, camToWorld);
#endif

	ParticlesDebugVertex(OUT, debugColor);

	return OUT;
}

//////////////////////////////////////////////////////////////////////
// Unify inputs from SParticleVertex into vertex ouput structure

OutputVS UnifyParticleOutputVS(in SParticleVertex pCommon)
{
	OutputVS OUT = (OutputVS) 0;

	OUT.HPosition = pCommon.HPosition;

	OUT.baseTC = pCommon.baseTC;

#if %_RT_ANIM_BLEND || %_RT_PARTICLE_SHADOW
	OUT.blendTC = pCommon.blendTC;
#endif

	OUT.alphaClip = pCommon.alphaClip;

#if (FEATURE_PARTICLES_TESSELLATION && !%_RT_NO_TESSELLATION) || %BUMP_MAP || USE_MATERIAL
	OUT.vWorldPos = pCommon.vWorldPos;
#endif
#if USE_MATERIAL
	OUT.vTangent = pCommon.vTangent;
#endif

#if %_RT_FOG && !%REFRACTION
	OUT.localFogColor = pCommon.localFogColor;
#endif

	OUT.vNormal = pCommon.vNormal;
	OUT.cColor = pCommon.Color;

	OUT.lightData0 = pCommon.lightData0;
	OUT.lightData1 = pCommon.lightData1;

	return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

half4 CenterMotion()
{
#if %_RT_MOTION_BLUR
	const half4 vCenterPos = TransformPosition(IN.Position);
	const half4 vCenterPosPrev = mul(ViewProjMatrPrev, IN.Position);
	// Current screen space position of particle center (xy), screen space camera motion vector (zw)
	half4 vSSCenterMotion = half4(vCenterPos.xy/vCenterPos.w, vCenterPosPrev.xy/vCenterPosPrev.w);
	vSSCenterMotion.zw = vSSCenterMotion.xy - vSSCenterMotion.zw;
	return vSSCenterMotion;
#else
	return 0;
#endif
}

void ParticleSpriteCommon(inout float4 Position, inout app2vertParticleGeneral IN)
{
	IN.baseTC = GetInputColor(IN.baseTC);
	IN.Color = GetInputColor(IN.Color);

#if %_RT_SOFT_PARTICLE
	// soft particle 1/thickness^2 in Position.w
	float3 vAxis = (IN.XAxis + IN.YAxis) * (0.5 * particleParams.softnessMultiplier);
	Position.w = 1 / dot(vAxis, vAxis);
#endif
}



OutputVS ParticleVS(
	in float4 Position: POSITION, app2vertParticleGeneral IN,
	uint vertID: SV_VertexID)
{
	ParticleSpriteCommon(Position, IN);

#if %_RT_SPRITE
	// Vertex data is instanced
	[branch] if (IN.baseTC.x)
	{
		// Octagonal shape
		static const half2 avOctVerts[] =
		{
			half2(0.294h, 0.h),    //0
			half2(0.706h, 0.h),    //1
			half2(0.h,    0.294h), //7
			half2(1.h,    0.294h), //2
			half2(0.h,    0.706h), //6
			half2(1.h,    0.706h), //3
			half2(0.294h, 1.h),    //5
			half2(0.706h, 1.h),    //4
		};
		IN.baseTC.xy = avOctVerts[vertID];
	}
	else
	{
		// Quad shape
		IN.baseTC.x = vertID & 1;
		IN.baseTC.y = vertID & 2 ? 1 : 0;
	}
#endif

	const float4 debugColor = float4(0.8, 1.0, 0.0, 1.0);

	SParticleVertex MID = ParticleCommonVertexOutput(Position, IN, CenterMotion(), debugColor);
	return UnifyParticleOutputVS(MID);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Packaging


float UbyteToFloat(uint v)
{
	const float conv = 1.0 / 255.0;
	return float(v * conv);
}


float4 UintToFloat4(uint v)
{
	float4 res;
	res.x = UbyteToFloat(v&0xff);
	res.y = UbyteToFloat((v>>8)&0xff);
	res.z = UbyteToFloat((v>>16)&0xff);
	res.w = UbyteToFloat((v>>24)&0xff);
	return res;
}


////////////////////////////////////////////////////////////////////////////////////////////////////


OutputVS PulledParticleVS(uint vertID: SV_VertexID)
{
#if %_RT_SPRITE
	const uint particleId = (vertID>>2) + particleInstance.vertexOffset;

	float4 Position = float4(positionsSRV[particleId].position, 1.0);

	app2vertParticleGeneral IN = (app2vertParticleGeneral)0;
	IN.XAxis = axesSRV[particleId].XAxis;
	IN.YAxis = axesSRV[particleId].YAxis;
	IN.Color = UintToFloat4(colorSTsSRV[particleId].Color);
	IN.baseTC = UintToFloat4(colorSTsSRV[particleId].baseTC);

	ParticleSpriteCommon(Position, IN);

	IN.baseTC.x = vertID & 1;
	IN.baseTC.y = vertID & 2 ? 1 : 0;

	const float4 debugColor = float4(0.8, 1.0, 0.0, 1.0);

#else
	const uint vertexId = (vertID>>1) + particleInstance.vertexOffset;
	const bool isDegen  = colorSTsSRV[vertexId].baseTC & 0x10000;
	const bool isOdd    = vertID & 1;
	const uint offset   = (isDegen && isOdd) ? 1 : 0;

	float4 Position = float4(positionsSRV[vertexId+offset].position, 1.0);
	app2vertParticleGeneral IN = (app2vertParticleGeneral)0;
	IN.XAxis = axesSRV[vertexId+offset].XAxis;
	IN.YAxis = axesSRV[vertexId+offset].YAxis;
	IN.Color = UintToFloat4(colorSTsSRV[vertexId+offset].Color);
	IN.baseTC = UintToFloat4(colorSTsSRV[vertexId+offset].baseTC);

	ParticleSpriteCommon(Position, IN);

	IN.baseTC.x = isDegen != isOdd ? 1 : 0;

	const float4 debugColor = isDegen ? float4(1.0, 0.0, 0.0, 1.0) : float4(0.6, 1.0, 0.2, 1.0);

#endif

	SParticleVertex MID = ParticleCommonVertexOutput(Position, IN, CenterMotion(), debugColor);
	return UnifyParticleOutputVS(MID);
}
////////////////////////////////////////////////////////////////////////////////////////////////////

OutputVS GpuParticleVS(uint vertID : SV_VertexID)
{
	const uint particleId = vertID / 6;

	float4 Position = float4(gpuParticleSRV[particleId].position, 1.0);
	app2vertParticleGeneral IN = (app2vertParticleGeneral)0;
	uint color = gpuParticleSRV[particleId].color;
	SAuxData auxData = UnpackAuxData(gpuParticleSRV[particleId].auxData);
	float size = auxData.size;
#if %GPU_FACING_VELOCITY
	const float3 vel = gpuParticleSRV[particleId].velocity;
	float length2 = length(vel);
	float3 moveDirection = -CV_CameraRightVector;
	if (length2 > 0.0)
		moveDirection = vel / length2;
	float3 normal = normalize(Position - g_VS_WorldViewPos);
	float axisSize = max(size, length2 * particleParams.axisScale);
	IN.XAxis = moveDirection*axisSize;
	IN.YAxis = cross(-moveDirection, normal)*size;
#else
	IN.XAxis = CV_CameraRightVector * size;
	IN.YAxis = -CV_CameraUpVector * size;
#endif
	IN.Color = UintToFloat4(color);
	float animPos = auxData.normalAge * particleParams.frameCount;

	ParticleSpriteCommon(Position, IN);

	const uint spriteIndices[6] = {0, 1, 2, 2, 1, 3};
	const uint indexId = spriteIndices[vertID % 6];
	IN.baseTC.x = indexId & 1;
	IN.baseTC.y = indexId & 2 ? 1 : 0;
	IN.baseTC.z = int(animPos) / 255.f;
	IN.baseTC.w = (animPos - int(animPos));

	const float4 debugColor = float4(1.0, 0.8, 0.0, 1.0);

	SParticleVertex MID = ParticleCommonVertexOutput(Position, IN, CenterMotion(), debugColor);
	return UnifyParticleOutputVS(MID);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// DX11 specifics

struct ParticleHSInput
{
	float4 Position: TEXCOORD6;
	app2vertParticleGeneral VSIn;
};

ParticleHSInput ParticleTessVS(float4 Position: POSITION, app2vertParticleGeneral IN)
{
	ParticleHSInput OUT;
	OUT.Position = Position;
	OUT.VSIn = IN;
	ParticleSpriteCommon(OUT.Position, OUT.VSIn);
	return OUT;
}

struct ControlPointHS
{
	float4 HPosition : TEXCOORDN;

	float4 baseTC    : TEXCOORDN;
#if %_RT_ANIM_BLEND || %_RT_PARTICLE_SHADOW
	float4 blendTC   : TEXCOORDN;
#endif
	half4 alphaClip : TEXCOORDN;

	half4 vWorldPos : TEXCOORDN;
#if !%_RT_SPRITE
	half3 vYAxis : TEXCOORDN;
#endif

#if USE_MATERIAL
	half4 vTangent  : TEXCOORDN;
#endif

#if !%REFRACTION
	#if %_RT_FOG
	half4 localFogColor : TEXCOORDN;
	#endif
#endif

	half4 vNormal   : TEXCOORDN;
	half4 cColor : TEXCOORDN;
	half4 lightData0 : TEXCOORDN;
	half4 lightData1 : TEXCOORDN;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
struct TessFactorsHS
{
	float Edges[4]  : SV_TessFactor;
	float Inside[2] : SV_InsideTessFactor;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
TessFactorsHS ParticleConstFuncHS(OutputPatch<ControlPointHS, 4> p)
{
	TessFactorsHS OUT = (TessFactorsHS)0;
	bool bFrustumCulled = ViewFrustumCull(p[0].vWorldPos.xyz, p[1].vWorldPos.xyz, p[2].vWorldPos.xyz, p[3].vWorldPos.xyz, CV_FrustumPlaneEquation, 5.0);
	if (bFrustumCulled)
		return OUT;

	float fTrianglePixSize = CV_TessInfo.w;

	float2 Scr[4];

	[unroll] for (int i = 0; i < 4; i++)
	{
		float4 ScrPos = HPosToScreenTC( p[i].HPosition );
		Scr[i] = ScrPos.xy / (ScrPos.w * fTrianglePixSize) * CV_ScreenSize.xy;
	}
	float4 EdgeTess = float4
	(
		length(Scr[0] - Scr[2]),
		length(Scr[0] - Scr[1]),
		length(Scr[1] - Scr[3]),
		length(Scr[2] - Scr[3])
	);

#if %_RT_PARTICLE_SHADOW || !%_RT_SPRITE
	// higher tessellation if particle receives shadows, or if tessellating curved connected particles
	const float fMaxTessFactor = 64;
#else
	const float fMaxTessFactor = 8;
#endif	
	EdgeTess = min(EdgeTess, fMaxTessFactor);

	// Assign tessellation levels. 
	OUT.Edges[0] = EdgeTess.x;
	OUT.Edges[1] = EdgeTess.y;
	OUT.Edges[2] = EdgeTess.z;
	OUT.Edges[3] = EdgeTess.w;

	OUT.Inside[1] = (EdgeTess.x + EdgeTess.z) * 0.5;
	OUT.Inside[0] = (EdgeTess.y + EdgeTess.w) * 0.5;

	return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

[domain("quad")]
[partitioning("fractional_even")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(4)]
[patchconstantfunc("ParticleConstFuncHS")]
[maxtessfactor(64)]
ControlPointHS ParticleHS(
#if %_RT_SPRITE
	InputPatch<ParticleHSInput, 1> inputPatch,
#else
	InputPatch<ParticleHSInput, 4> inputPatch,
#endif
	uint uCPID : SV_OutputControlPointID)
{
	// Modify tex coords for 4 patch corners
#if %_RT_SPRITE
	ParticleHSInput IN = inputPatch[0];
	IN.VSIn.baseTC.x = uCPID & 1;
	IN.VSIn.baseTC.y = uCPID & 2 ? 1 : 0;
#else
	ParticleHSInput IN = inputPatch[uCPID];
#endif

	const float4 debugColor = float4(0.0, 0.5, 1.0, 1.0);
	SParticleVertex MID = ParticleCommonVertexOutput(IN.Position, IN.VSIn, 0, debugColor);

	ControlPointHS OUT = (ControlPointHS)0;

	OUT.HPosition = MID.HPosition;

	OUT.baseTC = MID.baseTC;
#if %_RT_ANIM_BLEND
	OUT.blendTC = MID.blendTC;
#endif
	OUT.alphaClip = MID.alphaClip;

	OUT.vWorldPos = MID.vWorldPos;

#if !%_RT_SPRITE
	OUT.vYAxis = half3(IN.VSIn.YAxis);
#endif

#if USE_MATERIAL
	OUT.vTangent = MID.vTangent;
#endif

#if %_RT_FOG && !%REFRACTION
	OUT.localFogColor = MID.localFogColor;
#endif

	OUT.vNormal = MID.vNormal;
	OUT.cColor = MID.Color;

	OUT.lightData0 = MID.lightData0;
	OUT.lightData1 = MID.lightData1;

	return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

[domain("quad")]
OutputVS ParticleDS(float2 QuadUV : SV_DomainLocation, const OutputPatch<ControlPointHS, 4> ControlPt, TessFactorsHS TessFactorsInput)
{
	OutputVS OUT = (OutputVS)0;

	float4 vWorldPos = BilinearInterp(QuadUV, ControlPt[0].vWorldPos, ControlPt[1].vWorldPos, ControlPt[2].vWorldPos, ControlPt[3].vWorldPos);

#if !%_RT_SPRITE
	// Add curve coeffs
	float uut = (1-QuadUV.y) * (1-QuadUV.y) * QuadUV.y;
	float utt = QuadUV.y * QuadUV.y * (1-QuadUV.y);

	float3 vY0 = lerp(ControlPt[0].vYAxis, ControlPt[1].vYAxis, QuadUV.x);
	float3 vY1 = lerp(ControlPt[2].vYAxis, ControlPt[3].vYAxis, QuadUV.x);
	float3 vDP = lerp(ControlPt[2].vWorldPos - ControlPt[0].vWorldPos,
										ControlPt[3].vWorldPos - ControlPt[1].vWorldPos, QuadUV.x);
	vWorldPos.xyz += vDP * (utt - uut) + vY0 * uut - vY1 * utt;
#endif

	OUT.HPosition = TransformPosition(float4(vWorldPos.xyz, 1));

	OUT.baseTC = BilinearInterp(QuadUV, ControlPt[0].baseTC, ControlPt[1].baseTC, ControlPt[2].baseTC, ControlPt[3].baseTC);
#if %_RT_ANIM_BLEND || %_RT_PARTICLE_SHADOW
	OUT.blendTC = BilinearInterp(QuadUV, ControlPt[0].blendTC.xyzw, ControlPt[1].blendTC.xyzw, ControlPt[2].blendTC.xyzw, ControlPt[3].blendTC.xyzw);
#endif
	OUT.alphaClip = BilinearInterp(QuadUV, ControlPt[0].alphaClip, ControlPt[1].alphaClip, ControlPt[2].alphaClip, ControlPt[3].alphaClip);


#if %ENVIRONMENT_MAP || USE_MATERIAL
	OUT.vWorldPos = vWorldPos;
#endif
#if USE_MATERIAL
	OUT.vTangent = BilinearInterp(QuadUV, ControlPt[0].vTangent, ControlPt[1].vTangent, ControlPt[2].vTangent, ControlPt[3].vTangent);
#endif

#if %_RT_FOG && !%REFRACTION
	OUT.localFogColor = BilinearInterp(QuadUV, ControlPt[0].localFogColor, ControlPt[1].localFogColor, ControlPt[2].localFogColor, ControlPt[3].localFogColor);
#endif

	OUT.cColor = BilinearInterp(QuadUV, ControlPt[0].cColor, ControlPt[1].cColor, ControlPt[2].cColor, ControlPt[3].cColor);

	float3 vNormal = 0;
	OUT.vNormal = BilinearInterp(QuadUV, ControlPt[0].vNormal, ControlPt[1].vNormal, ControlPt[2].vNormal, ControlPt[3].vNormal);
	vNormal = OUT.vNormal;
	
	half shadowOccl = 1;// Sun shadows
	#if %_RT_PARTICLE_SHADOW
		shadowOccl = GetShadowOccl(vWorldPos.xyz);
		OUT.blendTC.w = shadowOccl;
	#endif

	const float backLighting = particleParams.backLighting;
	SParticleLightInfo lightInfo;
	ProjectLightVolume(vWorldPos.xyz, shadowOccl, backLighting, lightInfo);
	ToLightData(lightInfo, OUT.lightData0, OUT.lightData1);

	return OUT;
}

//////////////////////////////////////////////////////////////////////
	
void ApplyTexCoordsDeformation( inout OutputVS IN, float4 WPos )
{
#if USE_MATERIAL

	half4 baseColor = GetDiffuseTex(diffuseTex, IN.baseTC.xy);

	#if %SCREEN_SPACE_DEFORMATION

		half3 vBump = half3(0,0,1);
		// apply rescale
		PerturbationScale *= WPos.w* 0.05;

		float2 tcProj = WPos.xy;
		float2 tcAnim = float2(0.5, CV_AnimGenParams.y * AnimSpeed + 0.5);
		PerturbationScale *= (tcProj-0.5);

		vBump.xy  = GetXYNormalMap(customTex, PerturbationScale + tcAnim);
		vBump.xy += GetXYNormalMap(customTex, PerturbationScale * 1.5 + tcAnim);

		IN.baseTC.xy += vBump.xy * PerturbationStrength * baseColor.w;

	#elif %DEFORMATION
	
		float2 tcDeform = IN.baseTC.zw;
		float4 tcAnim = CV_AnimGenParams.y * DeformAnimSpeed * float4(0.9, 0.9, 2, 2) + float4(0.5, 0.5, 0.75, 1.0);
		float4 tcBump = (tcDeform.xyxy - 0.5)* DeformTile * float4(1,1,2,2) + tcAnim.xyzw;

		half2 vBump = GetXYNormalMap(customTex, tcBump.xy);
		vBump.xy   += GetXYNormalMap(customTex, tcBump.zw);

		IN.baseTC.xy += vBump.xy * DeformAmount;
		#if %_RT_ANIM_BLEND
			IN.blendTC.xy += vBump.xy * DeformAmount;
		#endif
		
	#endif	

#endif
}

//////////////////////////////////////////////////////////////////////
void ApplyColorLookup( in OutputVS IN, inout half4 cBaseColor )
{
#if USE_MATERIAL
	// are artist using this at all ? if not remove

	#if %COLOR_LOOKUP
	half fLum = dot(cBaseColor.xyz, 0.333 );
	cBaseColor.xyz = saturate ( cBaseColor.w *ColLookupAmplitude * GetCustomSecTex(customSecondaryTex,  ColLookupColPhase * fLum  ) );
		#endif
#endif
}

//////////////////////////////////////////////////////////////////////
half4 GetDiffuseMap(OutputVS IN)
{
	half4 cDiffuseMap = GetDiffuseTex(diffuseTex, IN.baseTC.xy);

#if %_RT_ANIM_BLEND
	// Blend in second tile
	half4 cDiffuseMapSec = GetDiffuseTex(diffuseTex, IN.blendTC.xy);
	cDiffuseMap += (cDiffuseMapSec - cDiffuseMap) * IN.blendTC.z;
#endif

	ApplyColorLookup( IN, cDiffuseMap );

	//cDiffuseMap *= IN.Color; // baked in lighting

	return cDiffuseMap;
}

//////////////////////////////////////////////////////////////////////
half4 GetGlowMap(OutputVS IN)
{
	half4 cGlowMap = 1.0;
#if %GLOW_MAP
	cGlowMap = GetEmittanceTex(glowTex, IN.baseTC.xy);
#if %_RT_ANIM_BLEND
	half4 cGlowMapSec = GetEmittanceTex(glowTex, IN.blendTC.xy);
	cGlowMap += (cGlowMapSec - cGlowMap) * IN.blendTC.z;
#endif
#endif
	return cGlowMap;
}

//////////////////////////////////////////////////////////////////////
half3 GetNormalMap(OutputVS IN)
{
#if %NORMAL_MAP
	half3 cNormalMap = GetNormalMap(normalsTex, IN.baseTC.xy);
	#if %_RT_ANIM_BLEND
	half3 cNormalMapSec = GetNormalMap(normalsTex, IN.blendTC.xy);
	cNormalMap += (cNormalMapSec - cNormalMap) * IN.blendTC.z;
	#endif
	return cNormalMap;
#endif
	return half3(0, 0, 1);
}
//////////////////////////////////////////////////////////////////////
half4 GetRefractionMap( OutputVS IN, float4 tcScreen, half3 cNormalMap)
{
#if USE_MATERIAL
	#if %REFRACTION
	half2 tcRefraction = tcScreen + cNormalMap.xy * RefrBumpScale.x * IN.alphaClip.x;
	return texSceneTarget.Sample(ssForwardBilinearWrap, tcRefraction);
	#endif
#endif
	return 0;
}

//////////////////////////////////////////////////////////////////////
half ApplySoftIntersection( inout half4 cFinal, float4 WPos, half fThicknessK )
{
#if %_RT_MSAA_QUALITY || %_RT_MSAA_QUALITY1
	const int nMsaaSamples = GetMSAASampleNum();		
	half fDepth = 0.0f;		
	for (int s=0; s<nMsaaSamples; s++) // Ideally would use pre-resolved depth target (note that existing resolved versions use sample0 for proper pixel/sample passes - having a max depth target will require extra mem)
		fDepth =  max(fDepth, GetDecodedSceneDepthMS(WPos.xy, nMsaaSamples, s));
#else
	const half fDepth = linearDepthMap.Sample(ssForwardBilinearWrap, WPos.xy).x * CV_NearFarClipDist.y;
#endif

	const half fDist = max(min(fDepth-WPos.w, WPos.w), 0.0);
	const half fSoftParticle = 1.0 - exp(-fDist*fDist*fThicknessK);
	cFinal.a *= fSoftParticle;

#if !%_RT_ALPHABLEND
	cFinal.rgb *= fSoftParticle;
#endif

	return fSoftParticle;
}

//////////////////////////////////////////////////////////////////////
void ApplyFog( inout half4 cFinal, half4 avgFogVolumeContrib, in OutputVS IN )
{
#if %_RT_FOG && !%REFRACTION
#if !%_RT_VOLUMETRIC_FOG
	#if %_RT_ALPHABLEND
		cFinal.xyz = lerp( IN.localFogColor.xyz, cFinal.xyz, IN.localFogColor.w );
		cFinal.xyz = lerp( avgFogVolumeContrib.xyz, cFinal.xyz, avgFogVolumeContrib.w );
	#else
		cFinal.xyz *= IN.localFogColor.w;
		cFinal.xyz *= avgFogVolumeContrib.w;
	#endif
#else
	SVolumetricFogParams params = GetVolumetricFogParams();
	VolumetricFogSampling vfs = GetVolumetricFogSampling();
	VolumetricFogTexcoord vtc = GetVolumetricFogTexcoordParamByScreenPos(params, IN.HPosition);
	float4 vf = GetVolumetricFogValue(vfs, vtc);

	#if %_RT_ALPHABLEND
		// apply volumetric fog for alpha blend mode.
		ApplyVolumetricFog(params, vf, IN.localFogColor, vtc, cFinal.rgb);
	#else
		// apply transmittance for additive blend mode.
		ApplyVolumetricFogTransmittance(params, vf, IN.localFogColor, vtc, cFinal.rgb);
	#endif
#endif
#endif
}

//////////////////////////////////////////////////////////////////////

float4 GetScreenCoords( float4 WPos )
{ 
#if %_RT_PROJECTION_MULTI_RES || %_RT_PROJECTION_LENS_MATCHED
	float4 tcScreen = WPos * float4(NvGetProjectionData().TextureSizeInv, 1, 1);
#else
	float4 tcScreen = WPos * float4(CV_ScreenSize.zw * 2.0, 1, 1); //todo: zw should not be half pixel, should be pixel size
#endif

	return tcScreen;
}

#if !ORBIS
[earlydepthstencil]
#endif
pixoutParticle ParticlePS(OutputVS IN)
{
	pixoutParticle OUT = (pixoutParticle) 0;

	if (ParticlesDebugPixel(OUT, IN))
		return OUT;
	
	float4 tcScreen = GetScreenCoords( IN.HPosition );

	ApplyTexCoordsDeformation( IN, tcScreen );

	half4 cDiffuseMap = GetDiffuseMap(IN);
	half4 cGlowMap = GetGlowMap(IN);
	
	// Early-out alpha clipping and scaling
	cDiffuseMap.a -= IN.alphaClip.y;
	if (cDiffuseMap.a <= 0.004)
		discard;

	cDiffuseMap.a = min(cDiffuseMap.a, IN.alphaClip.z) * IN.alphaClip.x;
	cDiffuseMap.a = saturate(cDiffuseMap.a);

	#if USE_MATERIAL
		cDiffuseMap.rgb *= MatDifColor; // for backward compatibility - art should just use particle color as diffuse
	#endif

	half3 cNormalMap = GetNormalMap(IN);

	half4 cDiffuseAcc = 0;

	half3 vNormal;

	#if USE_MATERIAL
	const half3x3 mTangentToWS = half3x3(IN.vTangent.xyz, float3(IN.vNormal.w, IN.vTangent.w, IN.vWorldPos.w), IN.vNormal.xyz);
	vNormal = mul(cNormalMap, mTangentToWS);
	#else
	vNormal = IN.vNormal.xyz;
	#endif

	vNormal = normalize(vNormal);

	SParticleLightInfo lightInfo = FromLightData(IN.lightData0, IN.lightData1);
	cDiffuseAcc.rgb = GetEnvLighting(
		lightInfo, vNormal,
		particleParams.diffuseLighting, particleParams.emissiveLighting, particleParams.backLighting);

#if %_RT_ENVIRONMENT_CUBEMAP
	uint envMapIndex;
	float4 envMapColor;
	
	if (particleInstance.envCubemapIndex < TILED_SHADING_MAX_NUM_LIGHTS)
	{
		envMapIndex = Fwd_TiledLightsShadeInfo[particleInstance.envCubemapIndex].resIndex;
		envMapColor = Fwd_TiledLightsShadeInfo[particleInstance.envCubemapIndex].color;
		float3 envDiffuseColor = Fwd_DiffuseCubeArray.SampleLevel(
			ssMaterialTrilinearClamp,
			float4(vNormal.xyz, envMapIndex), 0.0).rgb;
		envDiffuseColor *= envMapColor.rgb * particleParams.diffuseLighting;
		cDiffuseAcc.rgb += envDiffuseColor;
	}
#endif  

	half4 cFinal = float4(cDiffuseAcc.rgb, cDiffuseMap.a);

	// Apply material color
	cFinal.xyz *= cDiffuseMap.xyz;

#if USE_MATERIAL
	#if %REFRACTION
		cFinal.rgb = GetRefractionMap( IN, tcScreen, cNormalMap );
		#if %REFRACTION_TINTING
			cFinal.rgb *= cDiffuseMap.rgb;
		#endif
	#endif

	#if %SPECULAR_LIGHTING
		{
			half3 cSpecularAcc = 0;
			half3 vView = normalize(CV_WorldViewPosition.xyz-IN.vWorldPos.xyz);
			half fGloss = MatSpecColor.w;

			#if %_RT_ENVIRONMENT_CUBEMAP
				if (particleInstance.envCubemapIndex < TILED_SHADING_MAX_NUM_LIGHTS)
				{
					half fNdotE = saturate( dot(vView.xyz, vNormal.xyz));
					half3 vReflVec = (2.0h * fNdotE * vNormal.xyz) - vView.xyz;
					// #PFX2_TODO : copy-pasted from ShadeLib.cfi. tileShading also uses the exact same thing. Make it consistent.
					const float numCMapMips = 6.0;
					const float fGlossinessLod = numCMapMips - fGloss * numCMapMips;
					cSpecularAcc.rgb = Fwd_SpecCubeArray.SampleLevel(ssMaterialTrilinearClamp, float4(vNormal.xyz, envMapIndex), fGlossinessLod).rgb;
					cSpecularAcc.rgb *= envMapColor.rgb * envMapColor.a;
				}
			#endif	
			
			// sun spec
			float3 sunIntensity = CV_SunColor.rgb;
	
			#if %_RT_PARTICLE_SHADOW
				sunIntensity *= IN.blendTC.w;
			#endif
			
			cSpecularAcc.rgb += BlinnBRDF(vNormal, vView, CV_SunLightDir, fGloss) * saturate(dot(vNormal, CV_SunLightDir.xyz)) * sunIntensity;
			cSpecularAcc *= MatSpecColor.rgb;

			// combine with diffuse, but make sure we stay energy conservant
			cFinal.rgb *= saturate( 1 - GetLuminance( MatSpecColor ) );
			cFinal.rgb += cSpecularAcc;
		}
	#endif
#endif

	// Add particle glow 
	cFinal.rgb += cDiffuseMap.a * cDiffuseMap.rgb * cGlowMap.rgb * particleInstance.glowParams.rgb;

	// add particle color
	cFinal.rgb *= IN.cColor.rgb;

	// Premultiplied alpha for additive particles
#if !%_RT_ALPHABLEND
	cFinal.xyz *= cFinal.w;
#endif

#if %_RT_SOFT_PARTICLE
	ApplySoftIntersection(cFinal, tcScreen, IN.alphaClip.w);
#endif

#if %_RT_FOG && !%REFRACTION
	ApplyFog(cFinal, particleInstance.avgFogVolumeContrib, IN);
#endif

#if !%REFRACTION
	cFinal.rgb *= PS_HDR_RANGE_ADAPT_MAX; // Re-scale hdr range for consoles
#endif

	OUT.Color = cFinal;

#if %DEPTH_FIXUP
	const float fZ = tcScreen.w * CV_NearFarClipDist.w;
	OUT.Color.a = cFinal.a > DepthFixupThreshold ? -fZ : 1;
	OUT.BlendFactors = cFinal.a;
#endif

	return OUT;
}


//////////////////////////////////////////////////////////////////////
// Fog density injection
//////////////////////////////////////////////////////////////////////
struct OutputParticleVolumeFogVS
{
	float4 HPosition	: POSITION;

	float4 baseTC			: TEXCOORDN; // xy: texcoords, zw: SParticleVertex::blendTC.xy

	float4 alphaClip	: TEXCOORDN; // xyz: aplpha clip params, w: linear depth

	float4 color			: TEXCORRDN; // xyz: vertex color, w: thickness

#if %_RT_ANIM_BLEND
	float blendTC		: TEXCOORDN; // SParticleVertex::blendTC.z
#endif
};

struct OutputParticleVolumeFogGS
{
	float4 HPosition	: POSITION;

	float4 baseTC			: TEXCOORDN; // xy: texcoords, zw: SParticleVertex::blendTC.xy

	float4 alphaClip	: TEXCOORDN; //xyz: aplpha clip params, w: depth of voxel

	float4 color			: TEXCORRDN; // xyz: vertex color, w: SParticleVertex::blendTC.z

	float4 volume			: TEXCOORDN;

	uint rtindex			: SV_RenderTargetArrayIndex;
};

struct pixoutParticleVolumeFogPS
{
	half4 Color  : SV_Target0;
	half4 Color1 : SV_Target1;
	half4 Color2 : SV_Target2;
};

cbuffer CBPerPassVolFogInj : register(b5)
{
	// Voxel-based volumetric fog parameters
	struct
	{
		float4 vfSamplingParams;
		float4 vfDistributionParams;
		float4 vfScatteringParams;
		float4 vfScatteringBlendParams;
		float4 vfScatteringColor;
		float4 vfScatteringSecondaryColor;
		float4 vfHeightDensityParams;
		float4 vfHeightDensityRampParams;
		float4 vfDistanceParams;
		float4 vfGlobalEnvProbeParams0;
		float4 vfGlobalEnvProbeParams1;
	} cbVolFogInj;
};

SVolumetricFogParams GetVolumetricFogInjParams()
{
	SVolumetricFogParams params;

	params.sunDir = CV_SunLightDir.xyz;
	params.padding0 = 0.0f;

	params.nearDist = cbVolFogInj.vfSamplingParams.x;
	params.invFarMinusNearDist = cbVolFogInj.vfSamplingParams.y;
	params.maxIndex = cbVolFogInj.vfSamplingParams.z;
	params.invMaxIndex = cbVolFogInj.vfSamplingParams.w;

	params.screenSize = CV_ScreenSize.xy;
	params.farMinusNearDist = cbVolFogInj.vfDistributionParams.y;
	params.invMaxIndexMinusOne = cbVolFogInj.vfDistributionParams.z;

	params.viewPos = g_VS_WorldViewPos.xyz;
	params.framwCountJitter = cbVolFogInj.vfDistributionParams.w;

	params.scatterCoefficient = cbVolFogInj.vfScatteringParams.x;
	params.extinctionCoefficient = cbVolFogInj.vfScatteringParams.y;
	params.blendFactor = cbVolFogInj.vfScatteringBlendParams.x;
	params.blendMode = cbVolFogInj.vfScatteringBlendParams.y;

	params.cDiffuse1 = cbVolFogInj.vfScatteringColor.xyz;
	params.padding1 = 0.0f;

	params.cDiffuse2 = cbVolFogInj.vfScatteringSecondaryColor.xyz;
	params.padding2 = 0.0f;

	params.anisotropy1.x = cbVolFogInj.vfScatteringParams.z;
	params.anisotropy1.y = cbVolFogInj.vfScatteringParams.w;
	params.anisotropy2.x = cbVolFogInj.vfScatteringColor.w;
	params.anisotropy2.y = cbVolFogInj.vfScatteringSecondaryColor.w;

	params.heightDensityScale = cbVolFogInj.vfHeightDensityParams.x;
	params.densityAtViewer = cbVolFogInj.vfHeightDensityParams.y;
	params.fogVisibility = cbVolFogInj.vfHeightDensityParams.z;
	params.clampTransmittance = cbVolFogInj.vfHeightDensityParams.w;

	params.rampStart = cbVolFogInj.vfHeightDensityRampParams.x;
	params.rampEnd = cbVolFogInj.vfHeightDensityRampParams.y;
	params.oneOverRampDiff = cbVolFogInj.vfHeightDensityRampParams.z;
	params.rampStartOverRampDiff = cbVolFogInj.vfHeightDensityRampParams.w;

	params.farDistTopLeft = cbVolFogInj.vfDistanceParams.x;
	params.farDistTopCenter = cbVolFogInj.vfDistanceParams.y;
	params.farDistCenterLeft = cbVolFogInj.vfDistanceParams.z;
	params.farDistCenter = cbVolFogInj.vfDistanceParams.w;

	params.globalProbeColor0 = cbVolFogInj.vfGlobalEnvProbeParams0.xyz;
	params.globalProbeAttenuation0 = cbVolFogInj.vfGlobalEnvProbeParams0.w;

	params.globalProbeColor1 = cbVolFogInj.vfGlobalEnvProbeParams1.xyz;
	params.globalProbeAttenuation1 = cbVolFogInj.vfGlobalEnvProbeParams1.w;

	params.timeParams.x = CV_AnimGenParams.z;
	params.timeParams.y = CV_AnimGenParams.z * 0.5f;
	params.timeParams.z = CV_AnimGenParams.y;
	params.timeParams.w = CV_AnimGenParams.w;

	return params;
}

OutputParticleVolumeFogVS ParticleVolumeFogVS(in float4 Position: POSITION, app2vertParticleGeneral IN, uint vertID: SV_VertexID)
{
	ParticleSpriteCommon(Position, IN);

#if %_RT_SPRITE
	// Vertex data is instanced
	[branch] if (IN.baseTC.x)
	{
		// Octagonal shape
		static const half2 avOctVerts[] =
		{
			half2(0.294h, 0.h),    //0
			half2(0.706h, 0.h),    //1
			half2(0.h,    0.294h), //7
			half2(1.h,    0.294h), //2
			half2(0.h,    0.706h), //6
			half2(1.h,    0.706h), //3
			half2(0.294h, 1.h),    //5
			half2(0.706h, 1.h),    //4
		};
		IN.baseTC.xy = avOctVerts[vertID];
	}
	else
	{
		// Quad shape
		IN.baseTC.x = vertID & 1;
		IN.baseTC.y = vertID & 2 ? 1 : 0;
	}
#endif
	const float4 debugColor = float4(0.0f, 1.0f, 1.0f, 1.0f);
	SParticleVertex MID = ParticleCommonVertexOutput(Position, IN, CenterMotion(), debugColor);

	Position.w = 1.0f;
	float4 hPosition = TransformPosition(Position);

	// scale aplha to fog density.
	MID.alphaClip.x *= 0.25f;

	// calculate thickness
	float thickness = length(IN.XAxis + IN.YAxis);
	thickness *= particleParams.thickness;

	OutputParticleVolumeFogVS OUT;
	OUT.HPosition = MID.HPosition;
	OUT.baseTC = MID.baseTC;
#if %_RT_ANIM_BLEND
	OUT.baseTC.zw = MID.blendTC.xy;
	OUT.blendTC.x = MID.blendTC.z;
#endif
	OUT.alphaClip.xyz = MID.alphaClip.xyz;
	OUT.alphaClip.w = hPosition.w;// this is due to using same depth on every triangles in a particle.
	OUT.color.xyz = MID.Color.xyz;
	OUT.color.w = thickness;

	return OUT;
}

// max 16 slices per one particle sprite
[maxvertexcount(48)]
void ParticleVolumeFogGS( triangle OutputParticleVolumeFogVS IN[3], inout TriangleStream<OutputParticleVolumeFogGS> outputStream )
{
	const float maxRange = cbVolFogInj.vfDistributionParams.x + cbVolFogInj.vfDistributionParams.y;
	const float rcpMaxSlices = cbVolFogInj.vfSamplingParams.w;
	const float maxThickness = 7.0f * rcpMaxSlices * maxRange;//max length of half thickness is less than 7 slices.
	const float thickness = min(maxThickness, IN[0].color.w);

	const float linearDepth = IN[0].alphaClip.w;
	const float linearDepthFront = linearDepth - thickness;
	const float linearDepthBack = linearDepth + thickness;

	SVolumetricFogParams params = GetVolumetricFogInjParams();

	const float depthIndexFront = cbVolFogInj.vfSamplingParams.z * GetVolumetricFogDepthTexcoord(params, linearDepthFront);
	const float depthIndexBack = cbVolFogInj.vfSamplingParams.z * GetVolumetricFogDepthTexcoord(params, linearDepthBack);
	const uint sliceStartIndex = max(0.0f, floor(depthIndexFront));
	const uint sliceEndIndex = min(cbVolFogInj.vfSamplingParams.z - 2, ceil(depthIndexBack));

	for(uint i = sliceStartIndex; i <= sliceEndIndex; ++i)
	{
		OutputParticleVolumeFogGS OUT;
		OUT.rtindex = i;

		float depthFront0 = GetVolumetricFogLinearDepth(params, i - 1.0f);
		float depthFront1 = GetVolumetricFogLinearDepth(params, i);
		float depthBack1 = GetVolumetricFogLinearDepth(params, i + 1.0f);
		OUT.volume = float4(linearDepthFront, linearDepthBack, depthFront0, depthFront1);

		[unroll] for(uint j = 0; j < 3; ++j)
		{
			OUT.HPosition = IN[j].HPosition;
			OUT.baseTC = IN[j].baseTC;
			OUT.alphaClip.xyz = IN[j].alphaClip.xyz;
			OUT.alphaClip.w = depthBack1;
			OUT.color = IN[j].color;
#if %_RT_ANIM_BLEND
			OUT.color.w = IN[j].blendTC.x;
#endif

			outputStream.Append(OUT);
		}
		outputStream.RestartStrip();
	}
}

pixoutParticleVolumeFogPS ParticleVolumeFogPS(OutputParticleVolumeFogGS IN)
{
	pixoutParticleVolumeFogPS OUT = (pixoutParticleVolumeFogPS) 0;

#if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
	return OUT;
#endif
	
	half4 cDiffuseMap = GetDiffuseTex(diffuseTex, IN.baseTC.xy);
#if %_RT_ANIM_BLEND
	// Blend in second tile
	const float3 blendTC = float3(IN.baseTC.x, IN.baseTC.y, IN.color.w);
	half4 cDiffuseMapSec = GetDiffuseTex(diffuseTex, blendTC.xy);
	cDiffuseMap += (cDiffuseMapSec - cDiffuseMap) * blendTC.z;
#endif

	cDiffuseMap.rgb *= IN.color.rgb;
	
	// Early-out alpha clipping and scaling
	cDiffuseMap.a -= IN.alphaClip.y;
	if (cDiffuseMap.a <= 0.01)
		discard;

	cDiffuseMap.a = min(cDiffuseMap.a, IN.alphaClip.z) * IN.alphaClip.x;
	cDiffuseMap.a = saturate(cDiffuseMap.a);

	// calculate jittered coverage of voxel
	const float frameCount = cbVolFogInj.vfDistributionParams.w;
	float jitter = GetJitterInternal(IN.HPosition.xy, frameCount.xx);
	const float depthFront0 = IN.volume.z;
	const float depthFront1 = IN.volume.w;
	const float depthBack0 = depthFront1;
	const float depthBack1 = IN.alphaClip.w;
	const float linearDepthFront = IN.volume.x;
	const float linearDepthBack = IN.volume.y;
	float voxelFront = lerp(depthFront0, depthFront1, jitter);
	float voxelBack = lerp(depthBack0, depthBack1, jitter);
	float frontDepth = clamp(linearDepthFront, voxelFront, voxelBack);
	float backDepth = clamp(linearDepthBack, voxelFront, voxelBack);
	float dist = voxelBack - voxelFront;
	dist = (dist > 0.0001f) ? dist : 0.0001f;
	const half coverage = (backDepth - frontDepth) / dist;

	cDiffuseMap.a *= coverage;
	half4 cFinal = float4(cDiffuseMap.rgb * cDiffuseMap.a, cDiffuseMap.a);
	half3 emission = particleParams.emissiveLighting * cDiffuseMap.a;

	OUT.Color.xyz = cFinal.xyz;
	OUT.Color1.x = cFinal.w;
	OUT.Color2.xyz = emission.xyz;

	return OUT;
}


/////////////////////////////////
// technique
// Needs to match the technique numbers in CRenderer::EF_GetParticleListAndBatchFlags function.

technique ParticlesTessellated
{
	pass p0
	{
		VertexShader = ParticleTessVS();
		HullShader   = ParticleHS();
		DomainShader = ParticleDS();    
		GeometryShader = $AutoGS_MultiRes();
		PixelShader  = ParticlePS();  

		ZEnable = true;
		ZWriteEnable = false;
		CullMode = None;
	}
}

technique Particles
{
	pass p0
	{
 		VertexShader = ParticleVS() ParticleVS;
		GeometryShader = $AutoGS_MultiRes();
		PixelShader  = ParticlePS();

		ZEnable = true;
		ZWriteEnable = false;
		CullMode = None;
	}
}

technique ParticlesPulled
{
	pass p0
	{
		VertexShader = PulledParticleVS() ParticleVS;
		GeometryShader = $AutoGS_MultiRes();
		PixelShader  = ParticlePS();

		ZEnable = true;
		ZWriteEnable = false;
		CullMode = None;
	}
}

technique ParticlesGpu
{
	pass p0
	{
		VertexShader = GpuParticleVS() ParticleVS;
		GeometryShader = $AutoGS_MultiRes();
		PixelShader  = ParticlePS();

		ZEnable = true;
		ZWriteEnable = false;
		CullMode = None;
	}
}

technique ParticlesVolumeFog
{
	pass p0
	{
		VertexShader = ParticleVolumeFogVS() ParticleVS;
		GeometryShader = ParticleVolumeFogGS() ParticleGS;
		PixelShader  = ParticleVolumeFogPS() ParticlePS;

		ZEnable = false;
		ZWriteEnable = false;
		CullMode = None;

		SrcBlend = ONE;
		DestBlend = ONE;
		AlphaBlendEnable = true;
	}
}

